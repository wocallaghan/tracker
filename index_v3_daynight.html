<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OneWeb Constellation Tracker</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
    --bg-primary: #050a14;
    --bg-panel: rgba(8, 16, 32, 0.88);
    --bg-panel-hover: rgba(12, 24, 48, 0.92);
    --border: rgba(0, 163, 224, 0.15);
    --border-bright: rgba(0, 163, 224, 0.35);
    --accent: #00a3e0;
    --accent-bright: #00e5ff;
    --accent-glow: rgba(0, 229, 255, 0.15);
    --orange: #ff6b35;
    --text-primary: #e0e8f0;
    --text-secondary: #6a7b90;
    --text-dim: #3a4a5a;
    --success: #00e676;
    --font-ui: 'Inter', -apple-system, sans-serif;
    --font-mono: 'JetBrains Mono', 'SF Mono', monospace;
}

html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: var(--bg-primary);
    color: var(--text-primary);
    font-family: var(--font-ui);
}

#canvas-container {
    position: fixed;
    inset: 0;
    z-index: 0;
}

canvas { display: block; }

/* === LOADING SCREEN === */
#loading-screen {
    position: fixed; inset: 0; z-index: 1000;
    background: var(--bg-primary);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    transition: opacity 0.8s ease, visibility 0.8s ease;
}
#loading-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

.loading-logo {
    font-size: 28px; font-weight: 700; letter-spacing: 2px;
    color: var(--accent-bright);
    margin-bottom: 32px;
}
.loading-logo span { color: var(--text-secondary); font-weight: 300; }

.loading-spinner {
    width: 48px; height: 48px;
    border: 2px solid var(--border);
    border-top-color: var(--accent-bright);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
}
@keyframes spin { to { transform: rotate(360deg); } }

.loading-status {
    font-size: 13px; color: var(--text-secondary);
    font-family: var(--font-mono);
}

/* === HEADER === */
#header {
    position: fixed; top: 0; left: 0; right: 0; z-index: 10;
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 24px;
    background: linear-gradient(180deg, rgba(5,10,20,0.95) 0%, rgba(5,10,20,0) 100%);
    pointer-events: none;
}
#header > * { pointer-events: auto; }

.logo-area {
    display: flex; align-items: center; gap: 14px;
}
.logo-mark {
    width: 36px; height: 36px;
    border-radius: 8px;
    background: linear-gradient(135deg, var(--accent) 0%, var(--accent-bright) 100%);
    display: flex; align-items: center; justify-content: center;
    font-weight: 700; font-size: 14px; color: #050a14;
}
.logo-text h1 {
    font-size: 16px; font-weight: 600; letter-spacing: 0.5px;
    line-height: 1.2;
}
.logo-text p {
    font-size: 11px; color: var(--text-secondary);
    font-family: var(--font-mono); letter-spacing: 1px;
    text-transform: uppercase;
}

.header-stats {
    display: flex; gap: 28px; align-items: center;
}
.stat-item {
    text-align: center;
}
.stat-value {
    font-family: var(--font-mono); font-size: 20px; font-weight: 600;
    color: var(--accent-bright); line-height: 1.2;
}
.stat-label {
    font-size: 10px; color: var(--text-secondary);
    text-transform: uppercase; letter-spacing: 1.5px;
    margin-top: 2px;
}

/* === CLOCK === */
#clock {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    z-index: 10;
    display: flex; align-items: center; gap: 16px;
    padding: 10px 22px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
}
.clock-time {
    font-family: var(--font-mono); font-size: 16px; font-weight: 500;
    color: var(--accent-bright);
}
.clock-label {
    font-size: 10px; color: var(--text-secondary);
    text-transform: uppercase; letter-spacing: 1.5px;
}
.clock-divider {
    width: 1px; height: 24px;
    background: var(--border);
}
.speed-controls {
    display: flex; gap: 4px;
}
.speed-btn {
    padding: 4px 10px;
    font-family: var(--font-mono); font-size: 11px;
    background: transparent; border: 1px solid var(--border);
    color: var(--text-secondary); border-radius: 6px;
    cursor: pointer; transition: all 0.2s;
}
.speed-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.speed-btn.active {
    background: var(--accent-glow);
    border-color: var(--accent);
    color: var(--accent-bright);
}

/* === SIDE PANEL === */
#side-panel {
    position: fixed; top: 80px; right: 16px; bottom: 80px;
    width: 320px; z-index: 10;
    display: flex; flex-direction: column;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 14px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
    transition: transform 0.3s ease, opacity 0.3s ease;
}
#side-panel.collapsed {
    transform: translateX(340px); opacity: 0; pointer-events: none;
}

.panel-header {
    padding: 16px 18px;
    border-bottom: 1px solid var(--border);
    display: flex; flex-direction: column; gap: 10px;
}
.panel-title {
    font-size: 12px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 1.5px;
    color: var(--text-secondary);
}
.search-box {
    position: relative;
}
.search-box input {
    width: 100%; padding: 8px 12px 8px 34px;
    background: rgba(0,0,0,0.3); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text-primary);
    font-family: var(--font-ui); font-size: 13px;
    outline: none; transition: border-color 0.2s;
}
.search-box input::placeholder { color: var(--text-dim); }
.search-box input:focus { border-color: var(--accent); }
.search-icon {
    position: absolute; left: 10px; top: 50%; transform: translateY(-50%);
    color: var(--text-dim); font-size: 14px;
}

.sat-list {
    flex: 1; overflow-y: auto; padding: 6px;
}
.sat-list::-webkit-scrollbar { width: 4px; }
.sat-list::-webkit-scrollbar-track { background: transparent; }
.sat-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.sat-item {
    padding: 10px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.15s;
    display: flex; align-items: center; gap: 10px;
    border: 1px solid transparent;
}
.sat-item:hover { background: rgba(0, 163, 224, 0.06); }
.sat-item.selected {
    background: var(--accent-glow);
    border-color: var(--border-bright);
}
.sat-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--accent-bright);
    box-shadow: 0 0 6px var(--accent-bright);
    flex-shrink: 0;
}
.sat-item.selected .sat-dot { background: var(--orange); box-shadow: 0 0 6px var(--orange); }
.sat-info { flex: 1; min-width: 0; }
.sat-name {
    font-size: 12px; font-weight: 500;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.sat-meta {
    font-family: var(--font-mono); font-size: 10px;
    color: var(--text-secondary); margin-top: 2px;
}

.plane-item {
    padding: 10px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.15s;
    display: none;
    align-items: center; gap: 10px;
    border: 1px solid transparent;
}
.plane-item:hover { background: rgba(255, 107, 53, 0.08); }
.plane-item.selected {
    background: rgba(255, 107, 53, 0.12);
    border-color: var(--orange);
}
.plane-item .plane-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--orange);
    box-shadow: 0 0 6px var(--orange);
    flex-shrink: 0;
}
.plane-item .sat-name { color: var(--orange); font-weight: 600; }
.plane-item .sat-meta { color: var(--text-secondary); }

/* === DETAIL PANEL === */
#detail-panel {
    position: fixed; top: 80px; left: 16px;
    width: 300px; z-index: 10;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 14px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
    transition: transform 0.3s ease, opacity 0.3s ease;
}
#detail-panel.hidden {
    transform: translateX(-320px); opacity: 0; pointer-events: none;
}

.detail-header {
    padding: 16px 18px;
    border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: space-between;
}
.detail-name {
    font-size: 15px; font-weight: 600;
}
.detail-close {
    width: 28px; height: 28px; display: flex;
    align-items: center; justify-content: center;
    background: transparent; border: 1px solid var(--border);
    border-radius: 6px; color: var(--text-secondary);
    cursor: pointer; font-size: 16px;
    transition: all 0.2s;
}
.detail-close:hover { border-color: var(--accent); color: var(--text-primary); }

.detail-body { padding: 16px 18px; }
.detail-section {
    margin-bottom: 16px;
}
.detail-section-title {
    font-size: 10px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 1.5px;
    color: var(--text-secondary);
    margin-bottom: 8px;
}
.detail-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
}
.detail-field {}
.detail-field-label {
    font-size: 10px; color: var(--text-dim);
    text-transform: uppercase; letter-spacing: 0.5px;
}
.detail-field-value {
    font-family: var(--font-mono); font-size: 13px;
    color: var(--text-primary); margin-top: 1px;
}
.detail-track-row { padding: 4px 0 8px; }
.detail-track-btn {
    width: 100%; padding: 8px;
    background: transparent;
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-secondary);
    font-family: var(--font-mono); font-size: 11px;
    cursor: pointer; transition: all 0.2s;
}
.detail-track-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.detail-track-btn.active {
    border-color: var(--orange); color: var(--orange);
    background: rgba(255, 107, 53, 0.08);
}

.detail-field-value.accent { color: var(--accent-bright); }

/* === TOGGLE BUTTON === */
#panel-toggle {
    position: fixed; right: 16px; top: 50%;
    transform: translateY(-50%);
    z-index: 11;
    width: 32px; height: 80px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; color: var(--text-secondary);
    font-size: 14px;
    transition: all 0.3s;
}
#panel-toggle:hover { border-color: var(--accent); color: var(--text-primary); }
#panel-toggle.panel-open { right: 348px; }

/* === TOOLTIP === */
#tooltip {
    position: fixed; z-index: 20;
    padding: 8px 12px;
    background: rgba(5, 10, 20, 0.95);
    border: 1px solid var(--border-bright);
    border-radius: 8px;
    font-size: 12px; font-family: var(--font-mono);
    pointer-events: none;
    opacity: 0; transition: opacity 0.15s;
    white-space: nowrap;
}
#tooltip.visible { opacity: 1; }

.live-indicator {
    display: flex; align-items: center; gap: 8px; flex-direction: row;
    cursor: pointer;
    padding: 4px 10px;
    border-radius: 8px;
    border: 1px solid transparent;
    transition: border-color 0.2s;
}
.live-indicator:hover { border-color: var(--border-bright); }
.live-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--text-dim);
    box-shadow: none;
    transition: background 0.3s, box-shadow 0.3s;
}
.live-indicator.is-live .live-dot {
    background: var(--success);
    box-shadow: 0 0 8px var(--success);
    animation: pulse 2s ease-in-out infinite;
}
.live-indicator:not(.is-live) .live-dot {
    animation: none;
}
.live-indicator .stat-label {
    transition: color 0.3s;
}
.live-indicator:not(.is-live) .stat-label {
    color: var(--text-dim);
}
@keyframes pulse {
    0%, 100% { opacity: 1; box-shadow: 0 0 8px var(--success); }
    50% { opacity: 0.5; box-shadow: 0 0 4px var(--success); }
}

/* === GROUND STATIONS === */
.ground-station {
    position: fixed; z-index: 9;
    pointer-events: none;
    display: flex; align-items: center; gap: 6px;
    transition: opacity 0.3s;
}
.ground-station.gs-hidden { opacity: 0; pointer-events: none; }
.ground-station.behind-globe { opacity: 0; }

/* TT&C markers — diamond */
.gs-marker-ttc {
    width: 10px; height: 10px;
    border: 2px solid #ff6b9d;
    border-radius: 2px;
    transform: rotate(45deg);
    box-shadow: 0 0 8px rgba(255, 107, 157, 0.5);
    flex-shrink: 0;
}
.gs-label-ttc {
    font-family: var(--font-mono);
    font-size: 11px; font-weight: 500;
    color: #ff6b9d;
    text-shadow: 0 1px 6px rgba(0,0,0,0.9), 0 0 12px rgba(0,0,0,0.7);
    white-space: nowrap;
}

/* Gateway markers — circle */
.gs-marker-gw {
    width: 8px; height: 8px;
    border: 2px solid #4ecdc4;
    border-radius: 50%;
    box-shadow: 0 0 6px rgba(78, 205, 196, 0.5);
    flex-shrink: 0;
}
.gs-label-gw {
    font-family: var(--font-mono);
    font-size: 10px; font-weight: 500;
    color: #4ecdc4;
    text-shadow: 0 1px 6px rgba(0,0,0,0.9), 0 0 12px rgba(0,0,0,0.7);
    white-space: nowrap;
}

.gs-sublabel {
    font-size: 9px; font-weight: 400;
    color: var(--text-secondary);
    display: block;
}

/* === STATION TOGGLES PANEL === */
#gs-controls {
    position: fixed; bottom: 70px; left: 16px; z-index: 10;
    display: flex; flex-direction: column; gap: 6px;
}
.gs-toggle-btn {
    display: flex; align-items: center; gap: 8px;
    padding: 7px 14px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    cursor: pointer; transition: all 0.2s;
    font-family: var(--font-ui); font-size: 11px;
    color: var(--text-secondary);
    user-select: none;
    white-space: nowrap;
}
.gs-toggle-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.gs-toggle-btn.active-ttc { border-color: #ff6b9d; color: #ff6b9d; }
.gs-toggle-btn.active-gw { border-color: #4ecdc4; color: #4ecdc4; }
.gs-toggle-icon {
    width: 14px; height: 14px;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
}
.gs-toggle-icon .diamond {
    width: 7px; height: 7px;
    border: 1.5px solid var(--text-dim);
    border-radius: 1px;
    transform: rotate(45deg);
    transition: border-color 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-ttc .diamond {
    border-color: #ff6b9d;
    box-shadow: 0 0 4px #ff6b9d;
}
.gs-toggle-icon .circle {
    width: 6px; height: 6px;
    border: 1.5px solid var(--text-dim);
    border-radius: 50%;
    transition: border-color 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-gw .circle {
    border-color: #4ecdc4;
    box-shadow: 0 0 4px #4ecdc4;
}
.gs-toggle-btn.active-sun { border-color: #ffb74d; color: #ffb74d; }
.gs-toggle-icon .sun-icon {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--text-dim);
    transition: background 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-sun .sun-icon {
    background: #ffb74d;
    box-shadow: 0 0 6px #ffb74d;
}

/* === RESET VIEW === */
#reset-view {
    position: fixed; bottom: 74px; left: 50%; transform: translateX(-50%);
    z-index: 10;
    padding: 8px 20px;
    background: var(--bg-panel);
    border: 1px solid var(--orange);
    border-radius: 10px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    cursor: pointer;
    font-family: var(--font-mono); font-size: 12px;
    color: var(--orange);
    transition: all 0.3s;
    user-select: none;
}
#reset-view:hover { background: rgba(255, 107, 53, 0.15); }

/* === ROTATE BUTTONS === */
.rotate-btn {
    position: fixed; bottom: 24px; z-index: 10;
    padding: 8px 14px;
    background: var(--bg-panel);
    border: 1px solid var(--accent);
    border-radius: 10px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    cursor: pointer;
    font-family: var(--font-mono); font-size: 12px;
    color: var(--accent-bright);
    transition: all 0.2s, opacity 0.3s, visibility 0.3s;
    user-select: none;
    white-space: nowrap;
    opacity: 0; visibility: hidden; pointer-events: none;
}
.rotate-btn.visible { opacity: 1; visibility: visible; pointer-events: auto; }
#rotate-minus { right: calc(50% + 170px); }
#rotate-plus { left: calc(50% + 170px); }
.rotate-btn:hover {
    background: var(--accent-glow);
    border-color: var(--accent-bright);
}

/* === RESPONSIVE === */
@media (max-width: 768px) {
    #side-panel { width: 260px; right: 8px; top: 70px; bottom: 70px; }
    #detail-panel { width: 260px; left: 8px; }
    .header-stats { gap: 16px; }
    .stat-value { font-size: 16px; }
    #panel-toggle.panel-open { right: 278px; }
}
</style>
</head>
<body>

<!-- Loading Screen -->
<div id="loading-screen">
    <div class="loading-logo">OW<span>TRACK</span></div>
    <div class="loading-spinner"></div>
    <div class="loading-status" id="loading-status">Initializing...</div>
</div>

<!-- 3D Canvas -->
<div id="canvas-container"></div>

<!-- Header -->
<div id="header">
    <div class="logo-area">
        <div class="logo-mark">OW</div>
        <div class="logo-text">
            <h1>OneWeb Constellation Tracker</h1>
            <p>Real-time LEO Satellite Monitoring</p>
        </div>
    </div>
    <div class="header-stats">
        <div class="stat-item live-indicator is-live" id="live-btn" title="Click to sync to real time">
            <div class="live-dot"></div>
            <div class="stat-label">LIVE</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="stat-total">--</div>
            <div class="stat-label">Satellites</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="stat-planes">--</div>
            <div class="stat-label">Planes</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="stat-altitude">--</div>
            <div class="stat-label">Avg Alt (km)</div>
        </div>
    </div>
</div>

<!-- Clock / Time Controls -->
<button class="rotate-btn" id="rotate-minus">&minus;90&deg;</button>
<button class="rotate-btn" id="rotate-plus">+90&deg;</button>

<div id="clock">
    <div>
        <div class="clock-time" id="clock-time">--:--:--</div>
        <div class="clock-label">UTC</div>
    </div>
    <div class="clock-divider"></div>
    <div class="speed-controls">
        <button class="speed-btn active" data-speed="1">1x</button>
        <button class="speed-btn" data-speed="10">10x</button>
        <button class="speed-btn" data-speed="60">60x</button>
        <button class="speed-btn" data-speed="300">5m</button>
    </div>
</div>

<!-- Side Panel: Satellite List -->
<div id="side-panel">
    <div class="panel-header">
        <div class="panel-title">Constellation</div>
        <div class="search-box">
            <span class="search-icon">&gt;</span>
            <input type="text" id="search-input" placeholder="Search satellites...">
        </div>
    </div>
    <div class="sat-list" id="sat-list"></div>
</div>

<!-- Panel Toggle -->
<div id="panel-toggle" class="panel-open" title="Toggle satellite list">&#x25C0;</div>

<!-- Detail Panel (selected satellite) -->
<div id="detail-panel" class="hidden">
    <div class="detail-header">
        <div class="detail-name" id="detail-name">--</div>
        <button class="detail-close" id="detail-close">&times;</button>
    </div>
    <div class="detail-body">
        <div class="detail-section">
            <div class="detail-section-title">Position</div>
            <div class="detail-grid">
                <div class="detail-field">
                    <div class="detail-field-label">Latitude</div>
                    <div class="detail-field-value" id="detail-lat">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Longitude</div>
                    <div class="detail-field-value" id="detail-lon">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Altitude</div>
                    <div class="detail-field-value accent" id="detail-alt">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Velocity</div>
                    <div class="detail-field-value" id="detail-vel">--</div>
                </div>
            </div>
        </div>
        <div class="detail-section">
            <div class="detail-section-title">Orbital Elements</div>
            <div class="detail-grid">
                <div class="detail-field">
                    <div class="detail-field-label">Inclination</div>
                    <div class="detail-field-value" id="detail-inc">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Eccentricity</div>
                    <div class="detail-field-value" id="detail-ecc">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Period</div>
                    <div class="detail-field-value" id="detail-period">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">NORAD ID</div>
                    <div class="detail-field-value" id="detail-norad">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">RAAN</div>
                    <div class="detail-field-value" id="detail-raan">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Arg of Latitude</div>
                    <div class="detail-field-value" id="detail-aol">--</div>
                </div>
            </div>
        </div>
        <div class="detail-track-row">
            <button class="detail-track-btn" id="detail-track">Follow Satellite</button>
        </div>
    </div>
</div>

<!-- TT&C Station Labels -->
<div class="ground-station gs-ttc" id="gs-svalbard">
    <div class="gs-marker-ttc"></div>
    <div class="gs-label-ttc">Svalbard<span class="gs-sublabel">TT&C Station</span></div>
</div>
<div class="ground-station gs-ttc" id="gs-inuvik">
    <div class="gs-marker-ttc"></div>
    <div class="gs-label-ttc">Inuvik<span class="gs-sublabel">TT&C Station</span></div>
</div>

<!-- Gateway / SNP Station Labels -->
<div class="ground-station gs-gw" id="gs-talkeetna">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Talkeetna<span class="gs-sublabel">SNP &middot; Alaska</span></div>
</div>
<div class="ground-station gs-gw" id="gs-connecticut">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Connecticut<span class="gs-sublabel">SNP</span></div>
</div>
<div class="ground-station gs-gw" id="gs-florida">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Florida<span class="gs-sublabel">SNP</span></div>
</div>
<div class="ground-station gs-gw" id="gs-hawaii">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Hawaii<span class="gs-sublabel">SNP</span></div>
</div>
<div class="ground-station gs-gw" id="gs-yellowknife">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Yellowknife<span class="gs-sublabel">SNP &middot; Canada</span></div>
</div>
<div class="ground-station gs-gw" id="gs-toluca">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Toluca<span class="gs-sublabel">SNP &middot; Mexico</span></div>
</div>
<div class="ground-station gs-gw" id="gs-santiago">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Santiago<span class="gs-sublabel">SNP &middot; Chile</span></div>
</div>
<div class="ground-station gs-gw" id="gs-arica">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Arica<span class="gs-sublabel">SNP &middot; Chile</span></div>
</div>
<div class="ground-station gs-gw" id="gs-cali">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Cali<span class="gs-sublabel">SNP &middot; Colombia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-marica">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Maric&aacute;<span class="gs-sublabel">SNP &middot; Brazil</span></div>
</div>
<div class="ground-station gs-gw" id="gs-tahiti">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Tahiti<span class="gs-sublabel">SNP &middot; French Polynesia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-rambouillet">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Rambouillet<span class="gs-sublabel">SNP &middot; France</span></div>
</div>
<div class="ground-station gs-gw" id="gs-sintra">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Sintra<span class="gs-sublabel">SNP &middot; Portugal</span></div>
</div>
<div class="ground-station gs-gw" id="gs-bulgaria">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Sofia<span class="gs-sublabel">SNP &middot; Bulgaria</span></div>
</div>
<div class="ground-station gs-gw" id="gs-pitea">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Pite&aring;<span class="gs-sublabel">SNP &middot; Sweden</span></div>
</div>
<div class="ground-station gs-gw" id="gs-tabuk">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Tabuk<span class="gs-sublabel">SNP &middot; Saudi Arabia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-luanda">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Luanda<span class="gs-sublabel">SNP &middot; Angola</span></div>
</div>
<div class="ground-station gs-gw" id="gs-darwin">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Darwin<span class="gs-sublabel">SNP &middot; Australia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-toowoomba">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Toowoomba<span class="gs-sublabel">SNP &middot; Australia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-wangara">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Perth<span class="gs-sublabel">SNP &middot; Australia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-sirindhorn">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Sirindhorn<span class="gs-sublabel">SNP &middot; Thailand</span></div>
</div>
<div class="ground-station gs-gw" id="gs-gujarat">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Gujarat<span class="gs-sublabel">SNP &middot; India</span></div>
</div>

<!-- Toggle Controls -->
<div id="gs-controls">
    <div class="gs-toggle-btn active-ttc" id="toggle-ttc">
        <div class="gs-toggle-icon"><div class="diamond"></div></div>
        TT&C Stations
    </div>
    <div class="gs-toggle-btn active-gw" id="toggle-gw">
        <div class="gs-toggle-icon"><div class="circle"></div></div>
        Gateway Stations
    </div>
    <div class="gs-toggle-btn active-sun" id="toggle-sun">
        <div class="gs-toggle-icon"><div class="sun-icon"></div></div>
        Sun Lighting
    </div>
</div>

<!-- Reset View -->
<div id="reset-view">Reset View</div>

<!-- Tooltip -->
<div id="tooltip"></div>

<script src="https://cdn.jsdelivr.net/npm/satellite.js@5.0.0/dist/satellite.min.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ============================================================
// CONSTANTS
// ============================================================
const EARTH_RADIUS = 5;
const EARTH_RADIUS_KM = 6371;
const SAT_SCALE = EARTH_RADIUS / EARTH_RADIUS_KM;
const TLE_URL = 'https://celestrak.org/NORAD/elements/gp.php?GROUP=oneweb&FORMAT=tle';
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// ============================================================
// STATE
// ============================================================
let scene, camera, renderer, controls;
let ambientLight, sunLight;
let sunEnabled = true;
let earthGroup, earthMesh, atmosphereMesh, starField;
let earthDayNightMat = null;
let satPointCloud, satGeometry, satColorAttr;
let planeGlowCloud = null, planeGlowGeo = null, planeGlowIndices = [];
let satellites = [];
let selectedIndex = -1;
let orbitLine = null;
let groundTrack = null;
let pastOrbitLine = null;
let pastGroundTrack = null;
let trackingHalo = null;
let trackingArrow = null;
let haloTexture = null; // shared texture for tracking halo
let raycaster, mouse, hoveredIndex = -1;
let simTime = new Date();
let timeMultiplier = 1;
let lastFrameTime = performance.now();
let panelOpen = true;

// Tracking / focus state
let trackingIndex = -1;
let followMode = false;
let cameraAnim = null; // { startDir, endDir, dist, startTarget, endTarget, progress, duration }
// Default camera facing the UK (lat ~54, lon ~-2)
const ukLat = 54 * Math.PI / 180;
const ukLon = -(-2) * Math.PI / 180; // negate for Three.js convention
const defaultDist = 14;
let defaultCameraPos = new THREE.Vector3(
    defaultDist * Math.cos(ukLat) * Math.cos(ukLon),
    defaultDist * Math.sin(ukLat),
    defaultDist * Math.cos(ukLat) * Math.sin(ukLon)
);
let defaultCameraTarget = new THREE.Vector3(0, 0, 0);
let ttcVisible = true;
let gwVisible = true;
let selectedPlane = -1;

// TT&C stations (Svalbard + Inuvik)
const TTC_STATIONS = [
    { id: 'gs-svalbard', lat: 78.2306, lon: 15.3894 },
    { id: 'gs-inuvik', lat: 68.3607, lon: -133.723 },
];

// Gateway / SNP stations (verified OneWeb Satellite Network Portals)
const GW_STATIONS = [
    // Americas (SSC-installed)
    { id: 'gs-talkeetna',    lat: 62.3209, lon: -150.1066 },  // Alaska
    { id: 'gs-connecticut',  lat: 41.3400, lon: -72.9200 },   // Connecticut, USA
    { id: 'gs-florida',      lat: 28.4885, lon: -80.5780 },   // Florida, USA
    { id: 'gs-hawaii',       lat: 21.5728, lon: -158.1134 },  // Hawaii, USA
    { id: 'gs-yellowknife',  lat: 62.4540, lon: -114.3718 },  // Yellowknife, Canada
    { id: 'gs-toluca',       lat: 19.2826, lon: -99.6557 },   // Toluca, Mexico
    { id: 'gs-santiago',     lat: -33.4489, lon: -70.6693 },  // Santiago, Chile
    { id: 'gs-arica',        lat: -18.4783, lon: -70.3126 },  // Arica, Chile
    { id: 'gs-cali',         lat: 3.4516,  lon: -76.5320 },   // Cali, Colombia
    { id: 'gs-marica',       lat: -22.9195, lon: -42.8190 },  // Maricá, Brazil
    { id: 'gs-tahiti',       lat: -17.5516, lon: -149.5585 }, // Tahiti, French Polynesia
    // Europe
    { id: 'gs-rambouillet',  lat: 48.6443, lon: 1.8352 },     // Rambouillet, France (Eutelsat teleport)
    { id: 'gs-sintra',       lat: 38.7998, lon: -9.3817 },    // Sintra, Portugal
    { id: 'gs-bulgaria',     lat: 42.6977, lon: 23.3219 },    // Bulgaria (Vivacom)
    { id: 'gs-pitea',        lat: 65.3173, lon: 21.4798 },    // Piteå, Sweden (Arctic Space)
    // Middle East & Africa
    { id: 'gs-tabuk',        lat: 28.3838, lon: 36.5550 },    // Tabuk, Saudi Arabia (stc)
    { id: 'gs-luanda',       lat: -8.8390, lon: 13.2894 },    // Luanda, Angola
    // Asia-Pacific
    { id: 'gs-darwin',       lat: -12.4634, lon: 130.8456 },  // Darwin, Australia (Telstra)
    { id: 'gs-toowoomba',    lat: -27.5598, lon: 151.9507 },  // Toowoomba, Australia (Telstra)
    { id: 'gs-wangara',      lat: -31.7881, lon: 115.8283 },  // Perth/Wangara, Australia (Telstra)
    { id: 'gs-sirindhorn',   lat: 15.1400, lon: 105.4300 },   // Sirindhorn, Thailand
    { id: 'gs-gujarat',      lat: 22.3072, lon: 70.8022 },    // Gujarat, India
];

// Combined for label projection
const ALL_STATIONS = [...TTC_STATIONS, ...GW_STATIONS];

// ============================================================
// DOM REFS
// ============================================================
const $loading = document.getElementById('loading-screen');
const $loadingStatus = document.getElementById('loading-status');
const $statTotal = document.getElementById('stat-total');
const $statPlanes = document.getElementById('stat-planes');
const $statAlt = document.getElementById('stat-altitude');
const $clockTime = document.getElementById('clock-time');
const $satList = document.getElementById('sat-list');
const $searchInput = document.getElementById('search-input');
const $detailPanel = document.getElementById('detail-panel');
const $tooltip = document.getElementById('tooltip');

// ============================================================
// INIT THREE.JS
// ============================================================
function initScene() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.copy(defaultCameraPos);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 2;
    controls.maxDistance = 40;
    controls.enablePan = false;
    controls.rotateSpeed = 0.5;

    raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 0.15;
    mouse = new THREE.Vector2(-999, -999);

    // Ambient light
    ambientLight = new THREE.AmbientLight(0x335577, 0.6);
    scene.add(ambientLight);

    // Directional light (sun)
    sunLight = new THREE.DirectionalLight(0xffeedd, 2.0);
    sunLight.position.set(10, 5, 8);
    scene.add(sunLight);

    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('click', onMouseClick);
}

// ============================================================
// SUN DIRECTION (simplified solar ephemeris)
// ============================================================
function computeSunDirection(date) {
    // Julian date from JS Date
    const JD = date.getTime() / 86400000 + 2440587.5;
    const n = JD - 2451545.0; // days since J2000.0

    // Mean longitude & mean anomaly (degrees)
    const L = (280.460 + 0.9856474 * n) % 360;
    const g = ((357.528 + 0.9856003 * n) % 360) * DEG2RAD;

    // Ecliptic longitude (degrees)
    const lambda = (L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2 * g)) * DEG2RAD;

    // Obliquity of ecliptic
    const epsilon = 23.439 * DEG2RAD;

    // Right ascension & declination
    const ra = Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
    const dec = Math.asin(Math.sin(epsilon) * Math.sin(lambda));

    // Greenwich sidereal time (using satellite.js)
    const gmst = satellite.gstime(date);

    // Sun geographic longitude (hour angle from Greenwich)
    const sunLon = ra - gmst;

    // Convert to Three.js world coords (same convention as sat positions: lon negated, Y up)
    const x = Math.cos(dec) * Math.cos(-sunLon);
    const y = Math.sin(dec);
    const z = Math.cos(dec) * Math.sin(-sunLon);

    return new THREE.Vector3(x, y, z).normalize();
}

// ============================================================
// EARTH DAY/NIGHT SHADER MATERIAL
// ============================================================
function buildEarthShaderMaterial(dayTex, nightTex) {
    return new THREE.ShaderMaterial({
        uniforms: {
            dayMap: { value: dayTex },
            nightMap: { value: nightTex },
            sunDirection: { value: new THREE.Vector3(1, 0, 0) },
            sunEnabled: { value: true },
        },
        vertexShader: `
            varying vec2 vUv;
            varying vec3 vWorldNormal;
            void main() {
                vUv = uv;
                vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D dayMap;
            uniform sampler2D nightMap;
            uniform vec3 sunDirection;
            uniform bool sunEnabled;
            varying vec2 vUv;
            varying vec3 vWorldNormal;

            void main() {
                vec4 dayColor = texture2D(dayMap, vUv);
                vec4 nightColor = texture2D(nightMap, vUv);

                if (!sunEnabled) {
                    // Flat-lit day texture, no night lights
                    gl_FragColor = vec4(dayColor.rgb * 0.85, 1.0);
                    return;
                }

                float NdotL = dot(vWorldNormal, sunDirection);
                float blend = smoothstep(-0.02, 0.08, NdotL);

                // Sunlit side: day texture with diffuse shading
                vec3 lit = dayColor.rgb * (0.08 + 0.92 * max(NdotL, 0.0));

                // Dark side: deep dark with bright city lights
                vec3 dark = dayColor.rgb * 0.03 + nightColor.rgb * 1.8;

                gl_FragColor = vec4(mix(dark, lit, blend), 1.0);
            }
        `,
    });
}

// ============================================================
// CREATE EARTH
// ============================================================
function createEarth() {
    earthGroup = new THREE.Group();
    scene.add(earthGroup);

    const textureLoader = new THREE.TextureLoader();

    // Earth sphere
    const earthGeo = new THREE.SphereGeometry(EARTH_RADIUS, 96, 64);

    // Create procedural fallback texture
    const fallbackMat = new THREE.MeshPhongMaterial({
        color: 0x0a1628,
        emissive: 0x040810,
        shininess: 15,
    });

    earthMesh = new THREE.Mesh(earthGeo, fallbackMat);
    earthGroup.add(earthMesh);

    // Load day + night textures in parallel
    const dayUrl = 'https://unpkg.com/three-globe@2.31.1/example/img/earth-blue-marble.jpg';
    const nightUrl = 'https://unpkg.com/three-globe@2.31.1/example/img/earth-night.jpg';
    let dayTex = null, nightTex = null;

    function tryBuildMaterial() {
        if (!dayTex || !nightTex) return;
        earthDayNightMat = buildEarthShaderMaterial(dayTex, nightTex);
        // Set initial sun direction
        const sunDir = computeSunDirection(simTime);
        earthDayNightMat.uniforms.sunDirection.value.copy(sunDir);
        earthDayNightMat.uniforms.sunEnabled.value = sunEnabled;
        earthMesh.material = earthDayNightMat;
    }

    textureLoader.load(dayUrl, (tex) => { dayTex = tex; tryBuildMaterial(); },
        undefined, () => console.warn('Failed to load day earth texture'));
    textureLoader.load(nightUrl, (tex) => { nightTex = tex; tryBuildMaterial(); },
        undefined, () => console.warn('Failed to load night earth texture'));

    // Atmosphere glow (back-side shader)
    const atmosGeo = new THREE.SphereGeometry(EARTH_RADIUS * 1.025, 64, 64);
    const atmosMat = new THREE.ShaderMaterial({
        uniforms: {
            sunDirection: { value: new THREE.Vector3(1, 0, 0) },
            sunEnabled: { value: true },
        },
        vertexShader: `
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 sunDirection;
            uniform bool sunEnabled;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            void main() {
                float intensity = pow(0.72 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.5);
                vec3 color = mix(vec3(0.1, 0.4, 0.8), vec3(0.2, 0.7, 1.0), intensity);
                float alpha = intensity * 0.65;
                if (sunEnabled) {
                    float atmosBoost = smoothstep(-0.3, 0.5, dot(normalize(vWorldPos), sunDirection));
                    alpha *= mix(0.25, 1.0, atmosBoost);
                }
                gl_FragColor = vec4(color, alpha);
            }
        `,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide,
        transparent: true,
        depthWrite: false,
    });
    atmosphereMesh = new THREE.Mesh(atmosGeo, atmosMat);
    earthGroup.add(atmosphereMesh);

    // Subtle lat/lon grid
    const gridMat = new THREE.LineBasicMaterial({ color: 0x1a3050, transparent: true, opacity: 0.2 });
    for (let lat = -60; lat <= 60; lat += 30) {
        const pts = [];
        const r = EARTH_RADIUS * 1.001;
        const phi = (90 - lat) * DEG2RAD;
        for (let lon = 0; lon <= 360; lon += 2) {
            const theta = lon * DEG2RAD;
            pts.push(new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            ));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        earthGroup.add(new THREE.Line(geo, gridMat));
    }
    for (let lon = 0; lon < 360; lon += 30) {
        const pts = [];
        const r = EARTH_RADIUS * 1.001;
        const theta = lon * DEG2RAD;
        for (let lat = -90; lat <= 90; lat += 2) {
            const phi = (90 - lat) * DEG2RAD;
            pts.push(new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            ));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        earthGroup.add(new THREE.Line(geo, gridMat));
    }
}

// ============================================================
// CREATE STARS
// ============================================================
function createStars() {
    const starsGeo = new THREE.BufferGeometry();
    const count = 6000;
    const positions = new Float32Array(count * 3);
    const sizes = new Float32Array(count);
    for (let i = 0; i < count; i++) {
        const r = 80 + Math.random() * 120;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);
        sizes[i] = 0.5 + Math.random() * 1.5;
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    starsGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const starsMat = new THREE.PointsMaterial({
        color: 0xccddff,
        size: 0.12,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true,
    });
    starField = new THREE.Points(starsGeo, starsMat);
    scene.add(starField);
}

// ============================================================
// SATELLITE DATA
// ============================================================
async function loadTLEData() {
    $loadingStatus.textContent = 'Fetching TLE data from CelesTrak...';

    let tleText;
    try {
        const resp = await fetch(TLE_URL);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        tleText = await resp.text();
    } catch (e) {
        console.warn('Direct fetch failed, trying CORS proxy...', e);
        $loadingStatus.textContent = 'Trying alternate data source...';
        try {
            const resp = await fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(TLE_URL));
            if (!resp.ok) throw new Error(`Proxy HTTP ${resp.status}`);
            tleText = await resp.text();
        } catch (e2) {
            console.error('All fetches failed:', e2);
            $loadingStatus.textContent = 'Failed to load satellite data. Please use a local server.';
            return;
        }
    }

    $loadingStatus.textContent = 'Parsing orbital elements...';
    parseTLEData(tleText);
}

function parseTLEData(text) {
    const lines = text.trim().split('\n').map(l => l.trim()).filter(l => l.length > 0);
    satellites = [];

    for (let i = 0; i < lines.length - 2; i++) {
        // TLE format: name line, then line1 (starts with 1), then line2 (starts with 2)
        if (lines[i + 1]?.[0] === '1' && lines[i + 2]?.[0] === '2') {
            const name = lines[i];
            const line1 = lines[i + 1];
            const line2 = lines[i + 2];
            try {
                const satrec = satellite.twoline2satrec(line1, line2);
                if (satrec.error === 0) {
                    const inclination = satrec.inclo * RAD2DEG;
                    const eccentricity = satrec.ecco;
                    const meanMotion = satrec.no * (1440 / (2 * Math.PI)); // rev/day
                    const period = 1440 / meanMotion; // minutes

                    satellites.push({
                        name,
                        satrec,
                        noradId: satrec.satnum,
                        inclination,
                        eccentricity,
                        period,
                        // Updated each frame:
                        lat: 0, lon: 0, alt: 0,
                        vx: 0, vy: 0, vz: 0,
                        x: 0, y: 0, z: 0,
                    });
                }
            } catch (e) { /* skip bad TLEs */ }
            i += 2;
        }
    }

    console.log(`Parsed ${satellites.length} satellites`);
    $loadingStatus.textContent = `Loaded ${satellites.length} satellites. Building visualization...`;

    classifyPlanes();
    createSatellitePoints();
    buildSatList();
    updateStats();
}

function classifyPlanes() {
    // Only nominal sats: inclination ~87.5-88.5 deg, mean motion ~13.1-13.3 rev/day
    const nominal = [];
    for (const sat of satellites) {
        const mm = sat.satrec.no * (1440 / (2 * Math.PI));
        if (sat.inclination >= 87.5 && sat.inclination <= 88.5 && mm >= 13.1 && mm <= 13.3) {
            const raan = (sat.satrec.nodeo * RAD2DEG % 360 + 360) % 360;
            nominal.push({ sat, raan });
        } else {
            sat.plane = 0;
        }
    }

    if (nominal.length === 0) return;

    // Brute-force best offset for 12 bins at 15 deg spacing (Walker-Star, 180 deg span)
    const SPACING = 15;
    let bestOffset = 0, bestError = Infinity;
    for (let off = 0; off < SPACING; off += 0.5) {
        let err = 0;
        for (const { raan } of nominal) {
            const binCenter = Math.round((raan - off) / SPACING) * SPACING + off;
            let d = raan - binCenter;
            if (d > 180) d -= 360;
            if (d < -180) d += 360;
            err += d * d;
        }
        if (err < bestError) { bestError = err; bestOffset = off; }
    }

    // Assign to bins, compute mean RAAN per bin
    const bins = new Map(); // binKey -> { sats: [], raanSum, count }
    for (const entry of nominal) {
        const binKey = Math.round((entry.raan - bestOffset) / SPACING);
        if (!bins.has(binKey)) bins.set(binKey, { sats: [], raanSum: 0, count: 0 });
        const b = bins.get(binKey);
        b.sats.push(entry.sat);
        b.raanSum += entry.raan;
        b.count++;
    }

    // Sort bins by mean RAAN, assign plane 1-12
    const sorted = [...bins.values()].sort((a, b) => (a.raanSum / a.count) - (b.raanSum / b.count));
    sorted.forEach((bin, i) => {
        const planeNum = i + 1;
        for (const sat of bin.sats) sat.plane = planeNum;
    });

    // Any nominal sat not in a bin (shouldn't happen) gets plane 0
    for (const { sat } of nominal) {
        if (sat.plane === undefined) sat.plane = 0;
    }

    console.log(`Classified ${nominal.length} nominal sats into ${sorted.length} planes`);
}

// ============================================================
// SATELLITE RENDERING
// ============================================================
function createSatellitePoints() {
    const count = satellites.length;
    satGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);

    satGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    satGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    satColorAttr = satGeometry.getAttribute('color');

    // Point texture
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.2, 'rgba(0,229,255,0.9)');
    gradient.addColorStop(0.5, 'rgba(0,163,224,0.3)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    const pointTexture = new THREE.CanvasTexture(canvas);

    const mat = new THREE.PointsMaterial({
        size: 0.22,
        map: pointTexture,
        vertexColors: true,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
    });

    satPointCloud = new THREE.Points(satGeometry, mat);
    scene.add(satPointCloud);

    // Set initial colors
    const baseColor = new THREE.Color(0x00e5ff);
    for (let i = 0; i < count; i++) {
        colors[i * 3] = baseColor.r;
        colors[i * 3 + 1] = baseColor.g;
        colors[i * 3 + 2] = baseColor.b;
    }
    satColorAttr.needsUpdate = true;

    // First position update
    updateSatellitePositions();

    // Hide loading
    setTimeout(() => $loading.classList.add('hidden'), 400);
}

function showPlaneGlow(planeNum) {
    removePlaneGlow();

    // Collect indices of satellites in this plane
    planeGlowIndices = [];
    for (let i = 0; i < satellites.length; i++) {
        if (satellites[i].plane === planeNum) planeGlowIndices.push(i);
    }
    if (planeGlowIndices.length === 0) return;

    const count = planeGlowIndices.length;
    planeGlowGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);

    // Copy current positions from main geometry
    const mainPos = satGeometry.getAttribute('position');
    for (let j = 0; j < count; j++) {
        const i = planeGlowIndices[j];
        positions[j * 3] = mainPos.getX(i);
        positions[j * 3 + 1] = mainPos.getY(i);
        positions[j * 3 + 2] = mainPos.getZ(i);
    }
    planeGlowGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // Big soft blue glow texture
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.1, 'rgba(100,200,255,0.9)');
    gradient.addColorStop(0.3, 'rgba(0,180,255,0.5)');
    gradient.addColorStop(0.6, 'rgba(0,120,255,0.15)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);
    const glowTexture = new THREE.CanvasTexture(canvas);

    const mat = new THREE.PointsMaterial({
        size: 0.65,
        map: glowTexture,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
        color: 0x44bbff,
    });

    planeGlowCloud = new THREE.Points(planeGlowGeo, mat);
    scene.add(planeGlowCloud);
}

function removePlaneGlow() {
    if (planeGlowCloud) {
        scene.remove(planeGlowCloud);
        planeGlowGeo.dispose();
        planeGlowCloud.material.map.dispose();
        planeGlowCloud.material.dispose();
        planeGlowCloud = null;
        planeGlowGeo = null;
        planeGlowIndices = [];
    }
    // Hide rotate buttons
    document.getElementById('rotate-minus')?.classList.remove('visible');
    document.getElementById('rotate-plus')?.classList.remove('visible');
}

function updatePlaneGlow() {
    if (!planeGlowCloud || !planeGlowGeo || planeGlowIndices.length === 0) return;
    const mainPos = satGeometry.getAttribute('position');
    const glowPos = planeGlowGeo.getAttribute('position');
    for (let j = 0; j < planeGlowIndices.length; j++) {
        const i = planeGlowIndices[j];
        glowPos.setXYZ(j, mainPos.getX(i), mainPos.getY(i), mainPos.getZ(i));
    }
    glowPos.needsUpdate = true;
}

function geoToVec3(latDeg, lonDeg, altKm) {
    const r = EARTH_RADIUS + altKm * SAT_SCALE;
    const latRad = latDeg * DEG2RAD;
    const lonRad = -lonDeg * DEG2RAD; // negate for Three.js convention
    return new THREE.Vector3(
        r * Math.cos(latRad) * Math.cos(lonRad),
        r * Math.sin(latRad),
        r * Math.cos(latRad) * Math.sin(lonRad)
    );
}

function updateSatellitePositions() {
    if (!satellites.length || !satGeometry) return;

    const posAttr = satGeometry.getAttribute('position');
    const gmst = satellite.gstime(simTime);
    let totalAlt = 0;
    let validCount = 0;

    for (let i = 0; i < satellites.length; i++) {
        const sat = satellites[i];
        const posVel = satellite.propagate(sat.satrec, simTime);

        if (posVel.position && typeof posVel.position !== 'boolean') {
            const eci = posVel.position;
            const geo = satellite.eciToGeodetic(eci, gmst);

            sat.lat = satellite.degreesLat(geo.latitude);
            sat.lon = satellite.degreesLong(geo.longitude);
            sat.alt = geo.height;

            if (posVel.velocity) {
                const v = posVel.velocity;
                sat.speed = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
            }

            const vec = geoToVec3(sat.lat, sat.lon, sat.alt);
            sat.x = vec.x;
            sat.y = vec.y;
            sat.z = vec.z;

            posAttr.setXYZ(i, vec.x, vec.y, vec.z);
            totalAlt += sat.alt;
            validCount++;
        }
    }

    posAttr.needsUpdate = true;

    // Sync plane glow overlay positions
    updatePlaneGlow();

    // Update average altitude stat
    if (validCount > 0) {
        $statAlt.textContent = Math.round(totalAlt / validCount).toLocaleString();
    }
}

// ============================================================
// ORBIT PATH FOR SELECTED SAT
// ============================================================
function computePathPoints(sat, startMs, endMs, steps) {
    const dt = (endMs - startMs) / steps;
    const orbitPts = [];
    const trackPts = [];
    for (let s = 0; s <= steps; s++) {
        const t = new Date(startMs + s * dt);
        const pv = satellite.propagate(sat.satrec, t);
        if (pv.position && typeof pv.position !== 'boolean') {
            const gmst = satellite.gstime(t);
            const geo = satellite.eciToGeodetic(pv.position, gmst);
            const lat = satellite.degreesLat(geo.latitude);
            const lon = satellite.degreesLong(geo.longitude);
            const alt = geo.height;
            orbitPts.push(geoToVec3(lat, lon, alt));
            trackPts.push(geoToVec3(lat, lon, 0));
        }
    }
    return { orbitPts, trackPts };
}

function makeLine(pts, color, opacity, additive) {
    if (pts.length < 2) return null;
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({
        color, transparent: true, opacity, depthWrite: false,
        blending: additive ? THREE.AdditiveBlending : THREE.NormalBlending,
    });
    const line = new THREE.Line(geo, mat);
    scene.add(line);
    return line;
}

function disposeLine(line) {
    if (!line) return null;
    scene.remove(line);
    line.geometry.dispose();
    return null;
}

function showOrbitPath(satIndex) {
    clearOrbitPath();
    if (satIndex < 0 || satIndex >= satellites.length) return;

    const sat = satellites[satIndex];
    const periodMs = sat.period * 60 * 1000;
    const nowMs = simTime.getTime();
    const isTracking = trackingIndex === satIndex;

    if (isTracking) {
        // Past: vivid green, 2 revolutions back
        const past = computePathPoints(sat, nowMs - periodMs * 2, nowMs, 400);
        pastOrbitLine = makeLine(past.orbitPts, 0x00ff88, 0.85, true);
        pastGroundTrack = makeLine(past.trackPts, 0x00ff88, 0.2, false);
    } else {
        // Default select: orange, 1 revolution forward
        const fwd = computePathPoints(sat, nowMs, nowMs + periodMs, 200);
        orbitLine = makeLine(fwd.orbitPts, 0xff6b35, 0.6, false);
        groundTrack = makeLine(fwd.trackPts, 0xff6b35, 0.15, false);
    }
}

function clearOrbitPath() {
    orbitLine = disposeLine(orbitLine);
    groundTrack = disposeLine(groundTrack);
    pastOrbitLine = disposeLine(pastOrbitLine);
    pastGroundTrack = disposeLine(pastGroundTrack);
}

// ============================================================
// TRACKING HALO
// ============================================================
function getHaloTexture() {
    if (haloTexture) return haloTexture;
    const size = 128;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    gradient.addColorStop(0, 'rgba(255,140,50,1)');
    gradient.addColorStop(0.15, 'rgba(255,107,53,0.8)');
    gradient.addColorStop(0.4, 'rgba(255,80,30,0.25)');
    gradient.addColorStop(1, 'rgba(255,50,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);
    haloTexture = new THREE.CanvasTexture(canvas);
    return haloTexture;
}

function createTrackingHalo() {
    if (trackingHalo) return;
    const mat = new THREE.SpriteMaterial({
        map: getHaloTexture(),
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
    });
    trackingHalo = new THREE.Sprite(mat);
    trackingHalo.scale.set(1.2, 1.2, 1);
    scene.add(trackingHalo);
}

function removeTrackingHalo() {
    if (!trackingHalo) return;
    scene.remove(trackingHalo);
    trackingHalo.material.map.dispose();
    trackingHalo.material.dispose();
    trackingHalo = null;
}

function updateTrackingHalo() {
    if (trackingIndex < 0 || !trackingHalo) return;
    const sat = satellites[trackingIndex];
    trackingHalo.position.set(sat.x, sat.y, sat.z);
}

function createTrackingArrow() {
    if (trackingArrow) return;
    const shaftGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.35, 8);
    const headGeo = new THREE.ConeGeometry(0.035, 0.1, 8);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.55 });
    const shaft = new THREE.Mesh(shaftGeo, mat);
    shaft.position.y = 0.175;
    const head = new THREE.Mesh(headGeo, mat.clone());
    head.position.y = 0.45;
    trackingArrow = new THREE.Group();
    trackingArrow.add(shaft);
    trackingArrow.add(head);
    scene.add(trackingArrow);
}

function removeTrackingArrow() {
    if (!trackingArrow) return;
    scene.remove(trackingArrow);
    trackingArrow.traverse(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
    });
    trackingArrow = null;
}

function updateTrackingArrow() {
    if (trackingIndex < 0 || !trackingArrow) return;
    const sat = satellites[trackingIndex];
    const satPos = new THREE.Vector3(sat.x, sat.y, sat.z);

    // Compute velocity direction by propagating a tiny step forward
    const dtMs = 2000;
    const futureTime = new Date(simTime.getTime() + dtMs);
    const posVel = satellite.propagate(sat.satrec, futureTime);
    if (!posVel.position || typeof posVel.position === 'boolean') return;
    const gmst = satellite.gstime(futureTime);
    const geo = satellite.eciToGeodetic(posVel.position, gmst);
    const futureVec = geoToVec3(satellite.degreesLat(geo.latitude), satellite.degreesLong(geo.longitude), geo.height);
    const velDir = futureVec.sub(satPos).normalize();

    // Position arrow ahead of the satellite along its velocity
    const arrowOrigin = satPos.clone().add(velDir.clone().multiplyScalar(0.3));
    trackingArrow.position.copy(arrowOrigin);

    // Orient arrow along velocity direction
    const up = new THREE.Vector3(0, 1, 0);
    const quat = new THREE.Quaternion().setFromUnitVectors(up, velDir);
    trackingArrow.quaternion.copy(quat);
}

// ============================================================
// UI: SATELLITE LIST
// ============================================================
function buildSatList() {
    $satList.innerHTML = '';
    const frag = document.createDocumentFragment();

    // Count sats per plane for the plane items
    const planeCounts = {};
    for (const sat of satellites) {
        if (sat.plane > 0) planeCounts[sat.plane] = (planeCounts[sat.plane] || 0) + 1;
    }

    // Insert plane group items (hidden by default, shown during search)
    for (let p = 1; p <= 12; p++) {
        if (!planeCounts[p]) continue;
        const div = document.createElement('div');
        div.className = 'plane-item';
        div.dataset.plane = p;
        div.innerHTML = `
            <div class="plane-dot"></div>
            <div class="sat-info">
                <div class="sat-name">Plane ${p}</div>
                <div class="sat-meta">${planeCounts[p]} satellites</div>
            </div>
        `;
        div.addEventListener('click', () => selectPlane(p));
        frag.appendChild(div);
    }

    satellites.forEach((sat, i) => {
        const div = document.createElement('div');
        div.className = 'sat-item';
        div.dataset.index = i;
        const planePart = sat.plane > 0 ? ` &middot; Plane ${sat.plane}` : '';
        div.innerHTML = `
            <div class="sat-dot"></div>
            <div class="sat-info">
                <div class="sat-name">${sat.name}</div>
                <div class="sat-meta">ID ${sat.noradId}${planePart} &middot; ${sat.inclination.toFixed(1)}&deg; inc</div>
            </div>
        `;
        div.addEventListener('click', () => selectSatellite(i));
        frag.appendChild(div);
    });

    $satList.appendChild(frag);
}

function filterSatList(query) {
    const q = query.trim();
    const ql = q.toLowerCase();
    const planeItems = $satList.querySelectorAll('.plane-item');
    const satItems = $satList.querySelectorAll('.sat-item');
    const planeExact = q.match(/^plane\s*(\d+)$/i);
    const planePartial = ql && ('plane'.startsWith(ql) || ql.startsWith('plane'));

    // Show/hide plane group items
    planeItems.forEach(item => {
        const p = parseInt(item.dataset.plane, 10);
        if (planeExact) {
            item.style.display = p === parseInt(planeExact[1], 10) ? 'flex' : 'none';
        } else if (planePartial) {
            item.style.display = 'flex';
        } else {
            item.style.display = 'none';
        }
        // Update selected state
        item.classList.toggle('selected', selectedPlane === p);
    });

    // Show/hide satellite items
    if (planeExact) {
        const planeNum = parseInt(planeExact[1], 10);
        satItems.forEach(item => {
            const i = parseInt(item.dataset.index, 10);
            item.style.display = satellites[i].plane === planeNum ? '' : 'none';
        });
    } else {
        satItems.forEach(item => {
            const i = parseInt(item.dataset.index, 10);
            const sat = satellites[i];
            const match = !ql || sat.name.toLowerCase().includes(ql) || String(sat.noradId).includes(ql);
            item.style.display = match ? '' : 'none';
        });
    }
}

// ============================================================
// SELECTION
// ============================================================
function selectSatellite(index) {
    // Clear plane selection if active
    if (selectedPlane >= 0) {
        const oldPlaneItem = $satList.querySelector('.plane-item.selected');
        if (oldPlaneItem) oldPlaneItem.classList.remove('selected');
        selectedPlane = -1;
        removePlaneGlow();
        restoreAllSatColors();
    }

    // Deselect old
    if (selectedIndex >= 0) {
        const oldItem = $satList.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        resetSatColor(selectedIndex);
    }

    if (index === selectedIndex) {
        // Toggle off — stop tracking but keep camera where it is
        stopTracking();
        selectedIndex = -1;
        $detailPanel.classList.add('hidden');
        clearOrbitPath();
        return;
    }

    // If we were tracking something else, stop without resetting view
    if (trackingIndex >= 0 && trackingIndex !== index) {
        stopTracking();
    }

    selectedIndex = index;
    const item = $satList.querySelector(`.sat-item[data-index="${index}"]`);
    if (item) {
        item.classList.add('selected');
        item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }

    // Update detail panel
    $detailPanel.classList.remove('hidden');
    updateDetailPanel();

    // Always track the selected satellite
    focusSatellite(index);

}

function setSatColor(index, r, g, b) {
    if (!satColorAttr) return;
    satColorAttr.setXYZ(index, r, g, b);
    satColorAttr.needsUpdate = true;
}

function resetSatColor(index) {
    if (trackingIndex >= 0 && index !== trackingIndex) {
        // In tracking mode, non-tracked satellites stay dim
        setSatColor(index, 0.08, 0.12, 0.18);
    } else if (selectedPlane >= 0) {
        if (satellites[index].plane === selectedPlane) {
            setSatColor(index, 0.2, 0.85, 1.0);
        } else {
            setSatColor(index, 0.05, 0.08, 0.12);
        }
    } else {
        setSatColor(index, 0, 0.9, 1.0);
    }
}

function updateDetailPanel() {
    if (selectedIndex < 0) return;
    const sat = satellites[selectedIndex];
    document.getElementById('detail-name').textContent = sat.name;
    document.getElementById('detail-lat').textContent = sat.lat.toFixed(3) + '\u00B0';
    document.getElementById('detail-lon').textContent = sat.lon.toFixed(3) + '\u00B0';
    document.getElementById('detail-alt').textContent = Math.round(sat.alt).toLocaleString() + ' km';
    document.getElementById('detail-vel').textContent = (sat.speed || 0).toFixed(1) + ' km/s';
    document.getElementById('detail-inc').textContent = sat.inclination.toFixed(2) + '\u00B0';
    document.getElementById('detail-ecc').textContent = sat.eccentricity.toFixed(6);
    document.getElementById('detail-period').textContent = sat.period.toFixed(1) + ' min';
    document.getElementById('detail-norad').textContent = sat.noradId;

    // RAAN from satrec (epoch value)
    const raan = (sat.satrec.nodeo * RAD2DEG % 360 + 360) % 360;
    document.getElementById('detail-raan').textContent = raan.toFixed(2) + '\u00B0';

    // Argument of Latitude = arg of perigee + true anomaly (current)
    const argp = sat.satrec.argpo * RAD2DEG;
    const ma = sat.satrec.mo * RAD2DEG;
    // For near-circular orbits (OneWeb e≈0), mean anomaly ≈ true anomaly
    // Propagate to get current mean anomaly
    const pv = satellite.propagate(sat.satrec, simTime);
    if (pv.position && typeof pv.position !== 'boolean') {
        const gmst = satellite.gstime(simTime);
        const geo = satellite.eciToGeodetic(pv.position, gmst);
        // Use ECI position to compute AOL: angle from ascending node in orbital plane
        const eci = pv.position;
        const r = Math.sqrt(eci.x * eci.x + eci.y * eci.y + eci.z * eci.z);
        const raanRad = sat.satrec.nodeo;
        const incRad = sat.satrec.inclo;
        // Node vector
        const nx = Math.cos(raanRad), ny = Math.sin(raanRad);
        // Position in node frame
        const px = eci.x * nx + eci.y * ny;
        const py = (-eci.x * ny + eci.y * nx) * Math.cos(incRad) + eci.z * Math.sin(incRad);
        const aol = ((Math.atan2(py, px) * RAD2DEG) % 360 + 360) % 360;
        document.getElementById('detail-aol').textContent = aol.toFixed(2) + '\u00B0';
    }
}

function updateStats() {
    $statTotal.textContent = satellites.length;
    $statPlanes.textContent = 12;
}

// ============================================================
// GROUND STATION LABELS
// ============================================================
function updateGroundStationLabels() {
    if (!camera || !renderer) return;
    const widthHalf = window.innerWidth / 2;
    const heightHalf = window.innerHeight / 2;
    const earthSphere = new THREE.Sphere(new THREE.Vector3(0,0,0), EARTH_RADIUS);
    const intersectPt = new THREE.Vector3();

    for (const gs of ALL_STATIONS) {
        const el = document.getElementById(gs.id);
        if (!el) continue;

        const worldPos = geoToVec3(gs.lat, gs.lon, 0);
        worldPos.multiplyScalar(1.01);

        // Check if behind globe
        const camToStation = worldPos.clone().sub(camera.position).normalize();
        const raySt = new THREE.Raycaster(camera.position, camToStation);
        const hits = raySt.ray.intersectSphere(earthSphere, intersectPt);
        const distToStation = camera.position.distanceTo(worldPos);
        const isBehind = hits && camera.position.distanceTo(intersectPt) < distToStation * 0.98;
        el.classList.toggle('behind-globe', isBehind);

        // Project to screen
        const projected = worldPos.clone().project(camera);
        const x = (projected.x * widthHalf) + widthHalf;
        const y = -(projected.y * heightHalf) + heightHalf;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
    }
}

// ============================================================
// CAMERA ANIMATION / TRACKING
// ============================================================
function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function focusSatellite(index) {
    if (index < 0 || index >= satellites.length) return;

    // If already tracking this one, stop tracking
    if (trackingIndex === index) {
        resetView();
        return;
    }

    // Select it if not already selected
    if (selectedIndex !== index) {
        selectSatellite(index);
    }

    trackingIndex = index;
    const sat = satellites[index];
    const satPos = new THREE.Vector3(sat.x, sat.y, sat.z);
    const endDir = satPos.clone().normalize();

    // Keep current distance, rotate around the globe to face the satellite
    const dist = camera.position.length();
    const cp = camera.position;

    // Convert start/end to lat/lon so we rotate around rather than over the globe
    const startLat = Math.asin(cp.y / dist);
    const startLon = Math.atan2(cp.z, cp.x);
    const endLat = Math.asin(endDir.y);
    const endLon = Math.atan2(endDir.z, endDir.x);

    // Shortest longitude path (wrap around)
    let dLon = endLon - startLon;
    if (dLon > Math.PI) dLon -= 2 * Math.PI;
    if (dLon < -Math.PI) dLon += 2 * Math.PI;

    // Duration based on total angular distance (lon dominates)
    const totalAngle = Math.abs(dLon) + Math.abs(endLat - startLat);
    const ratio = totalAngle / Math.PI;
    const duration = 1.0 + ratio * ratio * 5.0;
    cameraAnim = {
        startLat, startLon, endLat, dLon,
        dist: dist,
        startTarget: controls.target.clone(),
        endTarget: new THREE.Vector3(0, 0, 0),
        progress: 0,
        duration: duration,
    };

    // Refresh orbit path with past/future tracking colours
    showOrbitPath(index);

    // Dim all non-selected satellites
    dimOtherSatellites(index);

    // Show tracking halo + direction arrow
    createTrackingHalo();
    updateTrackingHalo();
    createTrackingArrow();
    updateTrackingArrow();

    // Reset follow mode
    followMode = false;
    document.getElementById('detail-track').classList.remove('active');
    document.getElementById('detail-track').textContent = 'Follow Satellite';
}

function panToPlane(planeNum) {
    // Compute the orbital plane normal, then rotate 90° so the camera
    // looks along the plane edge-on from the equator — one half of the
    // satellite ring visible as a vertical line, the other half behind Earth.
    const positions = [];
    for (const sat of satellites) {
        if (sat.plane === planeNum) {
            positions.push(new THREE.Vector3(sat.x, sat.y, sat.z));
        }
    }
    if (positions.length < 2) return;

    // Average cross-products of well-spaced position pairs → plane normal
    const normal = new THREE.Vector3(0, 0, 0);
    const quarter = Math.max(1, Math.floor(positions.length / 4));
    for (let i = 0; i < positions.length; i++) {
        const j = (i + quarter) % positions.length;
        const cross = new THREE.Vector3().crossVectors(positions[i], positions[j]);
        normal.add(cross);
    }
    normal.normalize();

    // Project normal onto equatorial plane (y=0), then rotate 90° so the
    // camera looks along the plane (edge-on) — one half of the ring visible
    // as a vertical line of satellites, the other half behind the Earth.
    let nx = normal.x, nz = normal.z;
    if (Math.sqrt(nx * nx + nz * nz) < 0.01) {
        // Degenerate — fall back to RAAN-based direction
        const sat0 = satellites.find(s => s.plane === planeNum);
        const raan = sat0.satrec.nodeo;
        const gmst = satellite.gstime(simTime);
        const geoLon = raan - gmst;
        nx = Math.cos(geoLon); nz = Math.sin(geoLon);
    }
    // 90° rotation in XZ plane: (x,z) → (-z,x)
    const viewDir = new THREE.Vector3(-nz, 0, nx).normalize();

    const dist = camera.position.length();
    const cp = camera.position;
    const startLat = Math.asin(cp.y / dist);
    const startLon = Math.atan2(cp.z, cp.x);

    const endLat = 0; // equator — side of the Earth

    // Two candidate longitudes (normal and anti-normal), pick closest
    const lon1 = Math.atan2(viewDir.z, viewDir.x);
    const lon2 = Math.atan2(-viewDir.z, -viewDir.x);

    let dLon1 = lon1 - startLon;
    if (dLon1 > Math.PI) dLon1 -= 2 * Math.PI;
    if (dLon1 < -Math.PI) dLon1 += 2 * Math.PI;

    let dLon2 = lon2 - startLon;
    if (dLon2 > Math.PI) dLon2 -= 2 * Math.PI;
    if (dLon2 < -Math.PI) dLon2 += 2 * Math.PI;

    const dLon = Math.abs(dLon1) <= Math.abs(dLon2) ? dLon1 : dLon2;

    const totalAngle = Math.abs(dLon) + Math.abs(endLat - startLat);
    const ratio = totalAngle / Math.PI;
    const duration = 1.0 + ratio * ratio * 5.0;
    cameraAnim = {
        startLat, startLon, endLat, dLon,
        dist: dist,
        startTarget: controls.target.clone(),
        endTarget: new THREE.Vector3(0, 0, 0),
        progress: 0,
        duration: duration,
    };
}

function stopTracking() {
    trackingIndex = -1;
    cameraAnim = null;
    followMode = false;
    removeTrackingHalo();
    removeTrackingArrow();
    restoreAllSatColors();
}

function resetView() {
    // Clear plane selection
    if (selectedPlane >= 0) {
        const oldPlaneItem = document.querySelector('.plane-item.selected');
        if (oldPlaneItem) oldPlaneItem.classList.remove('selected');
        selectedPlane = -1;
        removePlaneGlow();
    }
    stopTracking();

    // Animate back to default UK view
    const cp = camera.position;
    const dist = cp.length();
    const startLat = Math.asin(cp.y / dist);
    const startLon = Math.atan2(cp.z, cp.x);
    const endDir = defaultCameraPos.clone().normalize();
    const endLat = Math.asin(endDir.y);
    const endLon = Math.atan2(endDir.z, endDir.x);
    let dLon = endLon - startLon;
    if (dLon > Math.PI) dLon -= 2 * Math.PI;
    if (dLon < -Math.PI) dLon += 2 * Math.PI;
    const totalAngle = Math.abs(dLon) + Math.abs(endLat - startLat);
    const ratio = totalAngle / Math.PI;
    const duration = 1.0 + ratio * ratio * 5.0;
    cameraAnim = {
        startLat, startLon, endLat, dLon,
        dist: defaultDist,
        startTarget: controls.target.clone(),
        endTarget: defaultCameraTarget.clone(),
        progress: 0,
        duration: duration,
    };
}

function dimOtherSatellites(keepIndex) {
    if (!satColorAttr) return;
    for (let i = 0; i < satellites.length; i++) {
        if (i === keepIndex) {
            satColorAttr.setXYZ(i, 1.0, 0.42, 0.21); // orange
        } else {
            satColorAttr.setXYZ(i, 0.08, 0.12, 0.18); // very dim
        }
    }
    satColorAttr.needsUpdate = true;
}

function selectPlane(planeNum) {
    // Check if any satellites are in this plane
    const hasPlane = satellites.some(s => s.plane === planeNum);
    if (!hasPlane) return;

    // Deselect old plane item in list
    const oldPlaneItem = $satList.querySelector('.plane-item.selected');
    if (oldPlaneItem) oldPlaneItem.classList.remove('selected');

    // Toggle off if already selected
    if (selectedPlane === planeNum) {
        selectedPlane = -1;
        removePlaneGlow();
        restoreAllSatColors();
        return;
    }

    // Clear any individual satellite selection/tracking
    if (selectedIndex >= 0) {
        const oldItem = document.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        selectedIndex = -1;
    }
    stopTracking();
    document.getElementById('detail-panel').classList.add('hidden');
    clearOrbitPath();

    selectedPlane = planeNum;

    // Mark plane item as selected in list
    const planeItem = $satList.querySelector(`.plane-item[data-plane="${planeNum}"]`);
    if (planeItem) planeItem.classList.add('selected');

    // Highlight all satellites in this plane bright cyan, dim the rest
    if (!satColorAttr) return;
    for (let i = 0; i < satellites.length; i++) {
        if (satellites[i].plane === planeNum) {
            satColorAttr.setXYZ(i, 0.2, 0.85, 1.0); // bright cyan
        } else {
            satColorAttr.setXYZ(i, 0.05, 0.08, 0.12); // very dim
        }
    }
    satColorAttr.needsUpdate = true;

    // Add big blue glow overlay
    showPlaneGlow(planeNum);

    // Pan camera to edge-on view of the plane
    panToPlane(planeNum);

    // Show rotate buttons
    document.getElementById('rotate-minus').classList.add('visible');
    document.getElementById('rotate-plus').classList.add('visible');
}

function restoreAllSatColors() {
    if (!satColorAttr) return;
    for (let i = 0; i < satellites.length; i++) {
        if (selectedPlane >= 0 && satellites[i].plane === selectedPlane) {
            satColorAttr.setXYZ(i, 0.2, 0.85, 1.0); // bright cyan for plane
        } else if (i === selectedIndex) {
            satColorAttr.setXYZ(i, 1.0, 0.42, 0.21);
        } else if (selectedPlane >= 0) {
            satColorAttr.setXYZ(i, 0.05, 0.08, 0.12); // dim when plane active
        } else {
            satColorAttr.setXYZ(i, 0, 0.9, 1.0);
        }
    }
    satColorAttr.needsUpdate = true;
}

function updateCameraAnimation(dt) {
    if (!cameraAnim) return;

    cameraAnim.progress = Math.min(1, cameraAnim.progress + dt / cameraAnim.duration);
    const t = easeInOutCubic(cameraAnim.progress);

    // Interpolate lat/lon separately — rotates around the globe, not over the top
    const lat = cameraAnim.startLat + (cameraAnim.endLat - cameraAnim.startLat) * t;
    const lon = cameraAnim.startLon + cameraAnim.dLon * t;
    const r = cameraAnim.dist;
    camera.position.set(
        r * Math.cos(lat) * Math.cos(lon),
        r * Math.sin(lat),
        r * Math.cos(lat) * Math.sin(lon)
    );
    controls.target.lerpVectors(cameraAnim.startTarget, cameraAnim.endTarget, t);

    if (cameraAnim.progress >= 1) {
        cameraAnim = null;
    }
}

function updateTracking() {
    if (!followMode) return;
    if (trackingIndex < 0 || trackingIndex >= satellites.length) return;
    if (cameraAnim) return;

    const sat = satellites[trackingIndex];
    const satPos = new THREE.Vector3(sat.x, sat.y, sat.z);
    const dir = satPos.clone().normalize();

    const dist = camera.position.length();
    const targetCamPos = dir.clone().multiplyScalar(dist);

    camera.position.lerp(targetCamPos, 0.025);
}

// ============================================================
// INTERACTION
// ============================================================
function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // Raycast for hover
    if (satPointCloud) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(satPointCloud);

        if (intersects.length > 0) {
            const idx = intersects[0].index;
            if (idx !== hoveredIndex) {
                if (hoveredIndex >= 0 && hoveredIndex !== selectedIndex) resetSatColor(hoveredIndex);
                hoveredIndex = idx;
                if (hoveredIndex !== selectedIndex) setSatColor(hoveredIndex, 0.3, 1.0, 0.6);
            }
            // Tooltip
            const sat = satellites[idx];
            $tooltip.innerHTML = `<strong>${sat.name}</strong><br>Alt: ${Math.round(sat.alt)} km &middot; ${sat.lat.toFixed(1)}&deg;, ${sat.lon.toFixed(1)}&deg;`;
            $tooltip.style.left = (event.clientX + 14) + 'px';
            $tooltip.style.top = (event.clientY - 10) + 'px';
            $tooltip.classList.add('visible');
            renderer.domElement.style.cursor = 'pointer';
        } else {
            if (hoveredIndex >= 0 && hoveredIndex !== selectedIndex) resetSatColor(hoveredIndex);
            hoveredIndex = -1;
            $tooltip.classList.remove('visible');
            renderer.domElement.style.cursor = 'grab';
        }
    }
}

function onMouseClick(event) {
    if (!satPointCloud) return;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(satPointCloud);
    if (intersects.length > 0) {
        selectSatellite(intersects[0].index);
    }
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ============================================================
// SPEED CONTROLS
// ============================================================
document.querySelectorAll('.speed-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        timeMultiplier = parseInt(btn.dataset.speed);
    });
});

// ============================================================
// LIVE BUTTON — reset to real time at 1x
// ============================================================
document.getElementById('live-btn').addEventListener('click', () => {
    simTime = new Date();
    timeMultiplier = 1;
    // Reset speed buttons to 1x
    document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
    const btn1x = document.querySelector('.speed-btn[data-speed="1"]');
    if (btn1x) btn1x.classList.add('active');
});

// ============================================================
// PANEL TOGGLE
// ============================================================
const $panelToggle = document.getElementById('panel-toggle');
$panelToggle.addEventListener('click', () => {
    panelOpen = !panelOpen;
    document.getElementById('side-panel').classList.toggle('collapsed', !panelOpen);
    $panelToggle.classList.toggle('panel-open', panelOpen);
    $panelToggle.innerHTML = panelOpen ? '&#x25C0;' : '&#x25B6;';
});

// ============================================================
// DETAIL CLOSE
// ============================================================
document.getElementById('detail-close').addEventListener('click', () => {
    if (selectedIndex >= 0) selectSatellite(selectedIndex); // toggle off
});

document.getElementById('detail-track').addEventListener('click', () => {
    if (trackingIndex < 0) return;
    followMode = !followMode;
    const btn = document.getElementById('detail-track');
    btn.classList.toggle('active', followMode);
    btn.textContent = followMode ? 'Following...' : 'Follow Satellite';
});

// ============================================================
// SEARCH
// ============================================================
$searchInput.addEventListener('input', (e) => filterSatList(e.target.value));

// Enter key in search: select + focus first visible result
$searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        const q = $searchInput.value.trim();
        if (!q) return;
        const planeMatch = q.match(/^plane\s*(\d+)$/i);
        if (planeMatch) {
            const planeNum = parseInt(planeMatch[1], 10);
            selectPlane(planeNum);
            return;
        }
        const ql = q.toLowerCase();
        const matchIdx = satellites.findIndex(
            s => s.name.toLowerCase().includes(ql) || String(s.noradId).includes(ql)
        );
        if (matchIdx >= 0) {
            selectSatellite(matchIdx);
        }
    }
});


// ============================================================
// RESET VIEW
// ============================================================
document.getElementById('reset-view').addEventListener('click', resetView);

// ============================================================
// ROTATE VIEW ±90°
// ============================================================
function rotateView(degrees) {
    const radians = degrees * DEG2RAD;
    const dist = camera.position.length();
    const cp = camera.position;
    const startLat = Math.asin(cp.y / dist);
    const startLon = Math.atan2(cp.z, cp.x);

    cameraAnim = {
        startLat, startLon,
        endLat: startLat, // stay at same latitude
        dLon: radians,
        dist: dist,
        startTarget: controls.target.clone(),
        endTarget: new THREE.Vector3(0, 0, 0),
        progress: 0,
        duration: 1.5,
    };
}

document.getElementById('rotate-minus').addEventListener('click', () => rotateView(-90));
document.getElementById('rotate-plus').addEventListener('click', () => rotateView(90));

// ============================================================
// ANIMATION LOOP
// ============================================================
let frameCount = 0;

function animate(now) {
    requestAnimationFrame(animate);

    const dt = (now - lastFrameTime) / 1000;
    lastFrameTime = now;

    // Advance sim time
    simTime = new Date(simTime.getTime() + dt * timeMultiplier * 1000);

    // Update sun direction — every frame at high speed, every 10th at 1x
    const sunInterval = Math.abs(timeMultiplier) > 10 ? 1 : 10;
    if (frameCount % sunInterval === 0 && sunEnabled) {
        const sunDir = computeSunDirection(simTime);
        // Move directional light to match sun
        sunLight.position.copy(sunDir).multiplyScalar(20);
        // Update earth shader
        if (earthDayNightMat) {
            earthDayNightMat.uniforms.sunDirection.value.copy(sunDir);
        }
        // Update atmosphere shader
        if (atmosphereMesh && atmosphereMesh.material.uniforms) {
            atmosphereMesh.material.uniforms.sunDirection.value.copy(sunDir);
        }
    }

    // Update satellite positions every 2nd frame for performance
    frameCount++;
    if (frameCount % 2 === 0) {
        updateSatellitePositions();
    }

    // Update orbit path — more often at higher time multipliers
    const pathInterval = Math.max(2, Math.floor(150 / Math.abs(timeMultiplier || 1)));
    if (selectedIndex >= 0 && frameCount % pathInterval === 0) {
        showOrbitPath(selectedIndex);
    }

    // Update detail panel
    const detailInterval = Math.max(2, Math.floor(30 / Math.abs(timeMultiplier || 1)));
    if (selectedIndex >= 0 && frameCount % detailInterval === 0) {
        updateDetailPanel();
    }

    // Camera animation
    updateCameraAnimation(dt);

    // Tracking: follow satellite + halo + direction arrow
    updateTracking();
    updateTrackingHalo();
    updateTrackingArrow();

    // Ground station labels
    if ((ttcVisible || gwVisible) && frameCount % 3 === 0) {
        updateGroundStationLabels();
    }

    // Stars slowly drift for subtle visual motion
    if (starField) {
        starField.rotation.y += 0.00002;
    }

    // Update clock + live indicator
    if (frameCount % 10 === 0) {
        $clockTime.textContent = simTime.toISOString().slice(11, 19);

        // Check if we're live: time multiplier is 1 and simTime is within 3s of real time
        const drift = Math.abs(Date.now() - simTime.getTime());
        const isLive = timeMultiplier === 1 && drift < 3000;
        document.getElementById('live-btn').classList.toggle('is-live', isLive);
    }

    controls.update();
    renderer.render(scene, camera);
}

// ============================================================
// CREATE GROUND STATION 3D MARKERS
// ============================================================
function createStationMarkers3D(stations, color) {
    const markerGeo = new THREE.SphereGeometry(0.04, 8, 8);
    const markerMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 });
    const ringGeo = new THREE.RingGeometry(0.08, 0.12, 24);
    const ringMat = new THREE.MeshBasicMaterial({
        color, transparent: true, opacity: 0.5,
        side: THREE.DoubleSide, depthWrite: false,
    });

    for (const gs of stations) {
        const pos = geoToVec3(gs.lat, gs.lon, 0);
        const surfacePos = pos.clone().multiplyScalar(1.005);

        const dot = new THREE.Mesh(markerGeo, markerMat);
        dot.position.copy(surfacePos);
        gs.dot3d = dot;
        scene.add(dot);

        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.copy(surfacePos);
        ring.lookAt(surfacePos.clone().multiplyScalar(2));
        gs.ring3d = ring;
        scene.add(ring);
    }
}

function createGroundStationMarkers() {
    createStationMarkers3D(TTC_STATIONS, 0xff6b9d);
    createStationMarkers3D(GW_STATIONS, 0x4ecdc4);
}

// ============================================================
// BOOT
// ============================================================
initScene();
createStars();
createEarth();
createGroundStationMarkers();
loadTLEData();
animate(performance.now());

// TT&C toggle
document.getElementById('toggle-ttc').addEventListener('click', () => {
    ttcVisible = !ttcVisible;
    document.getElementById('toggle-ttc').classList.toggle('active-ttc', ttcVisible);
    for (const gs of TTC_STATIONS) {
        const el = document.getElementById(gs.id);
        if (el) el.classList.toggle('gs-hidden', !ttcVisible);
        if (gs.dot3d) gs.dot3d.visible = ttcVisible;
        if (gs.ring3d) gs.ring3d.visible = ttcVisible;
    }
});

// Gateway toggle
document.getElementById('toggle-gw').addEventListener('click', () => {
    gwVisible = !gwVisible;
    document.getElementById('toggle-gw').classList.toggle('active-gw', gwVisible);
    for (const gs of GW_STATIONS) {
        const el = document.getElementById(gs.id);
        if (el) el.classList.toggle('gs-hidden', !gwVisible);
        if (gs.dot3d) gs.dot3d.visible = gwVisible;
        if (gs.ring3d) gs.ring3d.visible = gwVisible;
    }
});

// Sun lighting toggle
document.getElementById('toggle-sun').addEventListener('click', () => {
    sunEnabled = !sunEnabled;
    document.getElementById('toggle-sun').classList.toggle('active-sun', sunEnabled);
    if (sunEnabled) {
        sunLight.visible = true;
        ambientLight.intensity = 0.6;
        ambientLight.color.set(0x335577);
        // Immediately compute sun position
        const sunDir = computeSunDirection(simTime);
        sunLight.position.copy(sunDir).multiplyScalar(20);
        if (earthDayNightMat) {
            earthDayNightMat.uniforms.sunDirection.value.copy(sunDir);
        }
    } else {
        sunLight.visible = false;
        ambientLight.intensity = 1.8;
        ambientLight.color.set(0xffffff);
    }
    // Update shader sun toggle
    if (earthDayNightMat) {
        earthDayNightMat.uniforms.sunEnabled.value = sunEnabled;
    }
    if (atmosphereMesh && atmosphereMesh.material.uniforms) {
        atmosphereMesh.material.uniforms.sunEnabled.value = sunEnabled;
    }
});

</script>
</body>
</html>
