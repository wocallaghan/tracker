<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
<title>OneWeb Constellation Tracker</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
    --bg-primary: #050a14;
    --bg-panel: rgba(8, 16, 32, 0.88);
    --bg-panel-hover: rgba(12, 24, 48, 0.92);
    --border: rgba(0, 163, 224, 0.15);
    --border-bright: rgba(0, 163, 224, 0.35);
    --accent: #00a3e0;
    --accent-bright: #00e5ff;
    --accent-glow: rgba(0, 229, 255, 0.15);
    --orange: #ff6b35;
    --text-primary: #e0e8f0;
    --text-secondary: #6a7b90;
    --text-dim: #3a4a5a;
    --success: #00e676;
    --font-ui: 'Inter', -apple-system, sans-serif;
    --font-mono: 'JetBrains Mono', 'SF Mono', monospace;
}

html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: var(--bg-primary);
    color: var(--text-primary);
    font-family: var(--font-ui);
}

#canvas-container {
    position: fixed;
    inset: 0;
    z-index: 0;
}

canvas { display: block; }

/* === LOADING SCREEN === */
#loading-screen {
    position: fixed; inset: 0; z-index: 1000;
    background: var(--bg-primary);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    transition: opacity 0.8s ease, visibility 0.8s ease;
}
#loading-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

.loading-logo {
    font-size: 28px; font-weight: 700; letter-spacing: 2px;
    color: var(--accent-bright);
    margin-bottom: 32px;
}
.loading-logo span { color: var(--text-secondary); font-weight: 300; }

.loading-spinner {
    width: 48px; height: 48px;
    border: 2px solid var(--border);
    border-top-color: var(--accent-bright);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
}
@keyframes spin { to { transform: rotate(360deg); } }

.loading-status {
    font-size: 13px; color: var(--text-secondary);
    font-family: var(--font-mono);
}

/* === HEADER === */
#header {
    position: fixed; top: 0; left: 0; right: 0; z-index: 10;
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 24px;
    background: linear-gradient(180deg, rgba(5,10,20,0.95) 0%, rgba(5,10,20,0) 100%);
    pointer-events: none;
}
#header > * { pointer-events: auto; }

.logo-area {
    display: flex; align-items: center; gap: 14px;
}
.logo-mark {
    width: 36px; height: 36px;
    border-radius: 8px;
    background: linear-gradient(135deg, var(--accent) 0%, var(--accent-bright) 100%);
    display: flex; align-items: center; justify-content: center;
    font-weight: 700; font-size: 14px; color: #050a14;
}
.logo-text h1 {
    font-size: 16px; font-weight: 600; letter-spacing: 0.5px;
    line-height: 1.2;
}
.logo-text p {
    font-size: 11px; color: var(--text-secondary);
    font-family: var(--font-mono); letter-spacing: 1px;
    text-transform: uppercase;
}

.header-stats {
    display: flex; gap: 28px; align-items: center;
}
.stat-item {
    text-align: center;
}
.stat-value {
    font-family: var(--font-mono); font-size: 20px; font-weight: 600;
    color: var(--accent-bright); line-height: 1.2;
}
.stat-label {
    font-size: 10px; color: var(--text-secondary);
    text-transform: uppercase; letter-spacing: 1.5px;
    margin-top: 2px;
}
.source-stat-item {
    cursor: pointer; padding: 6px 12px; margin: -6px -12px;
    border-radius: 8px; transition: background 0.2s;
}
.source-stat-item:hover { background: rgba(255, 255, 255, 0.06); }
.data-source-value { font-size: 13px; }
.data-source-value.source-primary { color: var(--success); }
.data-source-value.source-secondary { color: var(--orange); }

/* Source Info Modal */
.source-modal-overlay {
    display: none; position: fixed; inset: 0; z-index: 100;
    background: rgba(0, 0, 0, 0.6); justify-content: center; align-items: center;
}
.source-modal-overlay.open { display: flex; }
.source-modal {
    background: var(--bg-panel); border: 1px solid var(--border-bright);
    border-radius: 14px; padding: 0; width: 380px; max-width: 90vw;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
}
.source-modal-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 14px 18px 0; margin-bottom: 0;
}
.source-modal-header h3 {
    margin: 0; font-size: 14px; color: var(--text-primary);
    font-family: var(--font-mono); letter-spacing: 0.5px;
}
.source-modal-close {
    background: none; border: none; color: var(--text-secondary);
    font-size: 18px; cursor: pointer; padding: 0 4px; line-height: 1;
}
.source-modal-close:hover { color: var(--text-primary); }
.source-tabs {
    display: flex; gap: 0; padding: 12px 18px 0; border-bottom: 1px solid var(--border);
}
.source-tab {
    flex: 1; padding: 8px 0; text-align: center; cursor: pointer;
    font-family: var(--font-mono); font-size: 12px; color: var(--text-secondary);
    border: none; background: none; border-bottom: 2px solid transparent;
    transition: all 0.2s;
}
.source-tab:hover { color: var(--text-primary); }
.source-tab.active-tab {
    color: var(--accent-bright); border-bottom-color: var(--accent-bright);
}
.source-tab-content {
    display: none; padding: 16px 18px 18px;
    font-family: var(--font-mono); font-size: 12px; color: var(--text-primary);
    line-height: 1.7;
}
.source-tab-content.active-content { display: block; }
.source-tab-content .source-field { color: var(--text-secondary); }
.source-tab-content .source-status {
    display: inline-block; padding: 2px 8px; border-radius: 4px;
    font-size: 11px; font-weight: 600;
}
.source-status.status-active { background: rgba(0, 230, 118, 0.15); color: var(--success); }
.source-status.status-fallback { background: rgba(255, 107, 53, 0.15); color: var(--orange); }
.source-status.status-inactive { background: rgba(255, 255, 255, 0.08); color: var(--text-dim); }

/* DateTime Picker Modal */
.datetime-modal-overlay {
    display: none; position: fixed; inset: 0; z-index: 100;
    background: rgba(0, 0, 0, 0.6); justify-content: center; align-items: center;
}
.datetime-modal-overlay.open { display: flex; }
.datetime-modal {
    background: var(--bg-panel); border: 1px solid var(--border-bright);
    border-radius: 14px; padding: 0; width: 340px; max-width: 90vw;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
}
.datetime-modal-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 14px 18px 0;
}
.datetime-modal-header h3 {
    margin: 0; font-size: 14px; color: var(--text-primary);
    font-family: var(--font-mono); letter-spacing: 0.5px;
}
.datetime-modal-close {
    background: none; border: none; color: var(--text-secondary);
    font-size: 18px; cursor: pointer; padding: 0 4px; line-height: 1;
}
.datetime-modal-close:hover { color: var(--text-primary); }
.datetime-modal-body {
    padding: 16px 18px 18px;
}
.datetime-input {
    width: 100%; padding: 10px 12px; box-sizing: border-box;
    background: rgba(255, 255, 255, 0.06); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text-primary);
    font-family: var(--font-mono); font-size: 14px;
    outline: none; transition: border-color 0.2s;
}
.datetime-input:focus { border-color: var(--accent-bright); }
.datetime-buttons {
    display: flex; gap: 8px; margin-top: 14px;
}
.datetime-btn {
    flex: 1; padding: 9px 0; border-radius: 8px; border: none;
    font-family: var(--font-mono); font-size: 12px; cursor: pointer;
    transition: all 0.2s;
}
.datetime-btn-go {
    background: var(--accent); color: #fff;
}
.datetime-btn-go:hover { background: var(--accent-bright); }
.datetime-btn-now {
    background: rgba(255, 255, 255, 0.08); color: var(--text-primary);
    border: 1px solid var(--border);
}
.datetime-btn-now:hover { background: rgba(255, 255, 255, 0.12); }
.datetime-error {
    color: var(--orange); font-size: 11px; font-family: var(--font-mono);
    margin-top: 8px; min-height: 16px;
}
.clock-time { cursor: pointer; }
.clock-time:hover { color: #fff; }

/* === CLOCK === */
#clock {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    z-index: 10;
    display: flex; align-items: center; gap: 16px;
    padding: 10px 22px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
}
.clock-time {
    font-family: var(--font-mono); font-size: 16px; font-weight: 500;
    color: var(--accent-bright);
}
.clock-label {
    font-size: 10px; color: var(--text-secondary);
    text-transform: uppercase; letter-spacing: 1.5px;
    text-align: center; margin-top: 4px;
}
.clock-divider {
    width: 1px; height: 24px;
    background: var(--border);
}
.speed-controls {
    display: flex; align-items: center; gap: 8px;
}
.pause-btn {
    background: transparent; border: 1px solid var(--border);
    border-radius: 6px; color: var(--text-secondary);
    font-size: 12px; width: 26px; height: 26px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; transition: all 0.2s; padding: 0;
}
.pause-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.pause-btn.paused { border-color: var(--orange); color: var(--orange); }
.speed-slider {
    -webkit-appearance: none; appearance: none;
    width: 100px; height: 4px;
    background: var(--border); border-radius: 2px;
    outline: none; cursor: pointer;
}
.speed-slider::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 14px; height: 14px;
    background: var(--accent-bright); border-radius: 50%;
    cursor: pointer; border: none;
}
.speed-slider::-moz-range-thumb {
    width: 14px; height: 14px;
    background: var(--accent-bright); border-radius: 50%;
    cursor: pointer; border: none;
}
.speed-label {
    font-family: var(--font-mono); font-size: 11px;
    color: var(--accent-bright); min-width: 42px;
    text-align: right;
}

/* === SIDE PANEL === */
#side-panel {
    position: fixed; top: 80px; right: 16px; bottom: 80px;
    width: 320px; z-index: 10;
    display: flex; flex-direction: column;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 14px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
    transition: transform 0.3s ease, opacity 0.3s ease;
}
#side-panel.collapsed {
    transform: translateX(340px); opacity: 0; pointer-events: none;
}

.panel-header {
    padding: 16px 18px;
    border-bottom: 1px solid var(--border);
    display: flex; flex-direction: column; gap: 10px;
}
.panel-title {
    font-size: 12px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 1.5px;
    color: var(--text-secondary);
}
.search-box {
    position: relative;
}
.search-box input {
    width: 100%; padding: 8px 12px 8px 34px;
    background: rgba(0,0,0,0.3); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text-primary);
    font-family: var(--font-ui); font-size: 13px;
    outline: none; transition: border-color 0.2s;
}
.search-box input::placeholder { color: var(--text-dim); }
.search-box input:focus { border-color: var(--accent); }
.search-icon {
    position: absolute; left: 10px; top: 50%; transform: translateY(-50%);
    color: var(--text-dim); font-size: 14px;
}

.sat-list {
    flex: 1; overflow-y: auto; padding: 6px;
}
.sat-list::-webkit-scrollbar { width: 4px; }
.sat-list::-webkit-scrollbar-track { background: transparent; }
.sat-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

/* === FOLDER STYLES === */
.folder {
    border-bottom: 1px solid rgba(255,255,255,0.04);
}
.folder:last-child { border-bottom: none; }
.folder-header {
    display: flex; align-items: center; gap: 6px;
    padding: 8px 10px; cursor: pointer; user-select: none;
    border-radius: 6px; transition: background 0.15s;
}
.folder-header:hover { background: rgba(255,255,255,0.04); }
.folder-chevron {
    font-size: 10px; color: var(--text-dim);
    transition: transform 0.2s ease;
    width: 14px; text-align: center; flex-shrink: 0;
}
.folder.collapsed .folder-chevron { transform: rotate(-90deg); }
.folder-label {
    font-size: 11px; font-weight: 700;
    text-transform: uppercase; letter-spacing: 1.2px;
    color: var(--text-secondary);
}
.folder-label.accent-blue { color: var(--accent); }
.folder-label.accent-gold { color: #ffc107; }
.folder-label.accent-green { color: var(--success); }
.folder-label.accent-purple { color: #bb86fc; }
.folder-count {
    font-family: var(--font-mono); font-size: 10px;
    color: var(--text-dim); margin-left: auto;
    background: rgba(255,255,255,0.06);
    padding: 1px 6px; border-radius: 8px;
}
.folder-body {
    overflow: hidden; transition: none;
}
.folder.collapsed .folder-body { display: none; }
.folder-sub { padding-left: 12px; }
.folder-sub .folder-header { padding: 6px 10px; }
.folder-sub .folder-label { font-size: 10px; letter-spacing: 1px; }
.folder-sub .folder-count { font-size: 9px; }
.folder-sub.collapsed .folder-body { display: none; }

/* Search active: flatten folder structure */
#sat-list.search-active .folder-header { display: none; }
#sat-list.search-active .folder { border-bottom: none; }
#sat-list.search-active .folder-body { display: block !important; }
#sat-list.search-active .folder-sub { padding-left: 0; }

.formation-badge {
    font-family: var(--font-mono); font-size: 9px; font-weight: 700;
    padding: 1px 5px; border-radius: 4px; margin-left: 6px;
    vertical-align: middle; letter-spacing: 0.5px;
}
.formation-badge.ss {
    background: rgba(0, 230, 118, 0.12); border: 1px solid rgba(0, 230, 118, 0.3);
    color: var(--success);
}
.formation-badge.mm {
    background: rgba(187, 134, 252, 0.12); border: 1px solid rgba(187, 134, 252, 0.3);
    color: #bb86fc;
}
.search-result-count {
    font-family: var(--font-mono); font-size: 11px; font-weight: 600;
    color: var(--text-secondary); padding: 6px 10px; display: none;
    letter-spacing: 0.5px;
}
.search-result-count.visible { display: block; }

.sat-item {
    padding: 10px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.15s;
    display: flex; align-items: center; gap: 10px;
    border: 1px solid transparent;
}
.sat-item:hover { background: rgba(0, 163, 224, 0.06); }
.sat-item.selected {
    background: var(--accent-glow);
    border-color: var(--border-bright);
}
.sat-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--accent-bright);
    box-shadow: 0 0 6px var(--accent-bright);
    flex-shrink: 0;
}
.sat-item.selected .sat-dot { background: var(--orange); box-shadow: 0 0 6px var(--orange); }
.sat-info { flex: 1; min-width: 0; }
.sat-name {
    font-size: 12px; font-weight: 500;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.sat-meta {
    font-family: var(--font-mono); font-size: 10px;
    color: var(--text-secondary); margin-top: 2px;
}
.geo-sat-item .sat-dot { background: #ffc107; box-shadow: 0 0 6px #ffc107; }
.geo-sat-item.selected .sat-dot { background: #ffc107; box-shadow: 0 0 8px #ffc107; }
.geo-sat-item.selected { border-color: rgba(255, 193, 7, 0.3); background: rgba(255, 193, 7, 0.06); }

.plane-item {
    padding: 10px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.15s;
    display: none;
    align-items: center; gap: 10px;
    border: 1px solid transparent;
}
.plane-item:hover { background: rgba(255, 107, 53, 0.08); }
.plane-item.selected {
    background: rgba(255, 107, 53, 0.12);
    border-color: var(--orange);
}
.plane-item .plane-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--orange);
    box-shadow: 0 0 6px var(--orange);
    flex-shrink: 0;
}
.plane-item .sat-name { color: var(--orange); font-weight: 600; }
.plane-item .sat-meta { color: var(--text-secondary); }

/* === DETAIL PANEL === */
#detail-panel {
    position: fixed; top: 80px; left: 16px;
    width: 300px; z-index: 10;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 14px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
    transition: transform 0.3s ease, opacity 0.3s ease;
}
#detail-panel.hidden {
    transform: translateX(-320px); opacity: 0; pointer-events: none;
}

/* === GEO INFO PANEL === */
#geo-panel {
    position: fixed; top: 80px; left: 16px;
    width: 300px; z-index: 10;
    background: var(--bg-panel);
    border: 1px solid rgba(255, 193, 7, 0.25);
    border-radius: 14px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
    transition: transform 0.3s ease, opacity 0.3s ease;
}
#geo-panel.hidden {
    transform: translateX(-320px); opacity: 0; pointer-events: none;
}
.geo-panel-header {
    padding: 14px 18px;
    border-bottom: 1px solid rgba(255, 193, 7, 0.12);
    display: flex; align-items: center; justify-content: space-between;
}
.geo-panel-name {
    font-size: 14px; font-weight: 600; color: #ffc107;
}
.geo-panel-slot {
    font-family: var(--font-mono); font-size: 11px; color: var(--text-secondary);
    margin-top: 2px;
}
.geo-panel-close {
    width: 28px; height: 28px; display: flex;
    align-items: center; justify-content: center;
    background: transparent; border: 1px solid var(--border);
    border-radius: 6px; color: var(--text-secondary);
    cursor: pointer; font-size: 16px; transition: all 0.2s;
}
.geo-panel-close:hover { border-color: #ffc107; color: var(--text-primary); }
.geo-panel-body { padding: 14px 18px; }
.geo-panel-section { margin-bottom: 14px; }
.geo-panel-section:last-child { margin-bottom: 0; }
.geo-panel-section-title {
    font-size: 10px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 1.5px;
    color: var(--text-secondary); margin-bottom: 8px;
}
.geo-panel-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
}
.geo-panel-field-label {
    font-size: 10px; color: var(--text-dim);
    text-transform: uppercase; letter-spacing: 0.5px;
}
.geo-panel-field-value {
    font-family: var(--font-mono); font-size: 13px; color: var(--text-primary);
}
.geo-panel-services {
    display: flex; flex-wrap: wrap; gap: 5px;
}
.geo-service-tag {
    font-family: var(--font-mono); font-size: 10px;
    padding: 3px 8px; border-radius: 4px;
    background: rgba(255, 193, 7, 0.08);
    border: 1px solid rgba(255, 193, 7, 0.15);
    color: #ffc107;
}
.geo-panel-desc {
    font-size: 11px; color: var(--text-secondary); line-height: 1.5;
}
.geo-panel-norad {
    font-family: var(--font-mono); font-size: 10px; color: var(--text-dim);
    margin-top: 10px;
}

.detail-header {
    padding: 16px 18px;
    border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: space-between;
}
.detail-name {
    font-size: 15px; font-weight: 600;
}
.detail-close {
    width: 28px; height: 28px; display: flex;
    align-items: center; justify-content: center;
    background: transparent; border: 1px solid var(--border);
    border-radius: 6px; color: var(--text-secondary);
    cursor: pointer; font-size: 16px;
    transition: all 0.2s;
}
.detail-close:hover { border-color: var(--accent); color: var(--text-primary); }

.detail-body { padding: 16px 18px 2px; }
.detail-section {
    margin-bottom: 16px;
}
.detail-section-title {
    font-size: 10px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 1.5px;
    color: var(--text-secondary);
    margin-bottom: 8px;
}
.detail-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
}
.detail-field {}
.detail-field-label {
    font-size: 10px; color: var(--text-dim);
    text-transform: uppercase; letter-spacing: 0.5px;
}
.ecc-info-icon {
    cursor: pointer; font-size: 12px; color: var(--text-secondary);
    margin-left: 3px; vertical-align: middle;
    transition: color 0.2s;
}
.ecc-info-icon:hover { color: var(--accent); }
.ecc-info-popup {
    display: none; position: fixed; z-index: 200;
    top: 50%; left: 50%; transform: translate(-50%, -50%);
    width: 340px; max-width: 90vw;
    background: var(--bg-panel); border: 1px solid var(--border);
    border-radius: 10px; padding: 16px 18px 14px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
}
.ecc-info-popup.visible { display: block; }
.ecc-info-popup-title {
    font-size: 13px; font-weight: 600; color: var(--text-primary);
    margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px;
}
.ecc-info-popup-body {
    font-size: 12px; line-height: 1.6; color: var(--text-secondary);
}
.ecc-info-popup-close {
    position: absolute; top: 8px; right: 10px;
    background: none; border: none; color: var(--text-secondary);
    font-size: 18px; cursor: pointer; padding: 2px 6px; line-height: 1;
}
.ecc-info-popup-close:hover { color: var(--text-primary); }
.ecc-info-overlay {
    display: none; position: fixed; z-index: 199;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.4);
}
.ecc-info-overlay.visible { display: block; }
#tle-graph-oldest-list::-webkit-scrollbar { width: 4px; }
#tle-graph-oldest-list::-webkit-scrollbar-track { background: transparent; }
#tle-graph-oldest-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.detail-field-value {
    font-family: var(--font-mono); font-size: 13px;
    color: var(--text-primary); margin-top: 1px;
}
.detail-header-actions { display: flex; align-items: center; gap: 6px; }
.detail-alarm-btn {
    padding: 4px 6px;
    background: transparent;
    border: 1px solid var(--border);
    border-radius: 6px;
    line-height: 0;
    cursor: pointer; transition: all 0.2s;
    color: var(--text-dim);
    display: flex; align-items: center; justify-content: center;
}
.detail-alarm-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.detail-alarm-btn.active {
    border-color: var(--orange); background: rgba(255, 107, 53, 0.08);
    color: var(--orange);
}
.detail-plot-btn {
    padding: 4px 6px; background: transparent;
    border: 1px solid var(--border); border-radius: 6px;
    line-height: 0; cursor: pointer; transition: all 0.2s;
    color: var(--text-dim);
    display: flex; align-items: center; justify-content: center;
}
.detail-plot-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.detail-beams-btn {
    padding: 4px 6px; background: transparent;
    border: 1px solid var(--border); border-radius: 6px;
    line-height: 0; cursor: pointer; transition: all 0.2s;
    color: var(--text-dim);
    display: flex; align-items: center; justify-content: center;
}
.detail-beams-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.detail-beams-btn.active {
    border-color: var(--accent); background: rgba(0,163,224,0.08);
    color: var(--accent);
}
.detail-follow-btn {
    width: 100%; padding: 4px 10px;
    background: transparent;
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-secondary);
    font-family: var(--font-mono); font-size: 11px;
    cursor: pointer; transition: all 0.2s;
    white-space: nowrap;
}
.detail-follow-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.detail-follow-btn.active {
    border-color: var(--orange); color: var(--orange);
    background: rgba(255, 107, 53, 0.08);
}

.detail-field-value.accent { color: var(--accent-bright); }
.detail-field-value.clickable { cursor: pointer; transition: color 0.2s, text-shadow 0.2s; }
.detail-field-value.clickable:hover { color: var(--accent-bright); text-shadow: 0 0 8px var(--accent-glow); }
.detail-field-value.clickable.viz-active { color: var(--orange); text-shadow: 0 0 8px rgba(255, 107, 53, 0.3); }

.ttc-panel {
    position: fixed; left: 16px; z-index: 8;
    width: 300px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    padding: 8px 14px;
    opacity: 0; pointer-events: none;
    transform: translateX(-320px);
    transition: transform 0.3s ease, opacity 0.3s ease;
}
.ttc-panel.visible { opacity: 1; pointer-events: auto; transform: translateX(0); }
.ttc-panel-row {
    display: flex; align-items: baseline; justify-content: space-between;
}
.ttc-panel-station { font-size: 13px; font-weight: 600; color: var(--text-primary); }
.ttc-panel-countdown {
    font-family: var(--font-mono); font-size: 13px; color: var(--text-primary);
}
.ttc-panel-countdown.in-pass { color: var(--success); text-shadow: 0 0 8px rgba(0, 230, 118, 0.3); }
.ttc-panel-countdown.no-pass { color: var(--text-dim); font-size: 11px; }
.ttc-panel-times { font-family: var(--font-mono); font-size: 10px; color: var(--text-dim); margin-top: 3px; }

/* === ALARM STAT ITEM (in header bar) === */
.alarm-stat-item {
    cursor: pointer; padding: 6px 12px; margin: -6px -12px;
    border-radius: 8px; transition: background 0.2s;
    position: relative;
}
.alarm-stat-item:hover { background: rgba(255, 255, 255, 0.06); }
.alarm-stat-value { color: var(--text-dim) !important; }
.alarm-stat-item.has-alarms .alarm-stat-value { color: var(--orange) !important; }

/* === ALARM MANAGEMENT PANEL === */
.alarm-panel {
    position: fixed; right: 352px; top: 80px; z-index: 20;
    width: 280px; max-height: 400px; overflow-y: auto;
    background: var(--bg-panel); border: 1px solid var(--border);
    border-radius: 10px; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    padding: 12px 14px;
    opacity: 0; pointer-events: none; transform: translateY(-10px);
    transition: transform 0.3s ease, opacity 0.3s ease;
}
.alarm-panel.visible { opacity: 1; pointer-events: auto; transform: translateY(0); }
.alarm-panel-title {
    font-size: 12px; font-weight: 600; color: var(--text-primary);
    margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;
}
.alarm-panel-close { background: none; border: none; color: var(--text-dim); cursor: pointer; font-size: 16px; padding: 2px 4px; }
.alarm-panel-close:hover { color: var(--text-primary); }
.alarm-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 6px 0; border-bottom: 1px solid rgba(0,163,224,0.06);
}
.alarm-item:last-child { border-bottom: none; }
.alarm-item-name {
    font-family: var(--font-mono); font-size: 11px; color: var(--text-primary); cursor: pointer;
}
.alarm-item-name:hover { color: var(--accent); }
.alarm-item-remove {
    background: none; border: none; color: var(--text-dim); cursor: pointer;
    font-size: 14px; padding: 2px 6px;
}
.alarm-item-remove:hover { color: var(--orange); }
.alarm-empty { font-size: 11px; color: var(--text-dim); text-align: center; padding: 12px 0; }
.alarm-add-btn {
    display: block; width: 100%; padding: 8px 0; margin-top: 8px;
    background: rgba(0,163,224,0.12); border: 1px solid rgba(0,163,224,0.3);
    border-radius: 6px; color: var(--accent); font-size: 11px; font-weight: 600;
    cursor: pointer; transition: background 0.2s;
}
.alarm-add-btn:hover { background: rgba(0,163,224,0.25); }
.alarm-modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.6); z-index: 301;
    display: none; align-items: center; justify-content: center;
}
.alarm-modal-overlay.visible { display: flex; }
.alarm-modal {
    width: 280px; background: var(--bg-panel); border: 1px solid var(--border);
    border-radius: 10px; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    padding: 14px;
}
.alarm-modal label {
    display: block; font-size: 11px; color: var(--text-dim); margin-bottom: 10px;
}
.alarm-modal input {
    display: block; width: 100%; margin-top: 4px; padding: 6px 8px;
    background: rgba(255,255,255,0.06); border: 1px solid var(--border);
    border-radius: 6px; color: var(--text-primary); font-size: 12px;
    font-family: var(--font-mono); box-sizing: border-box;
}
.alarm-modal input:focus { outline: none; border-color: var(--accent); }
.alarm-confirm-text {
    font-size: 12px; color: var(--text-primary); margin-bottom: 14px; line-height: 1.4;
}
.alarm-confirm-btns {
    display: flex; gap: 8px;
}
.alarm-confirm-btns button {
    flex: 1; padding: 8px 0; border-radius: 6px; font-size: 11px; font-weight: 600;
    cursor: pointer; transition: background 0.2s;
}
.alarm-confirm-cancel {
    background: rgba(255,255,255,0.06); border: 1px solid var(--border); color: var(--text-dim);
}
.alarm-confirm-cancel:hover { background: rgba(255,255,255,0.12); color: var(--text-primary); }
.alarm-confirm-yes {
    background: rgba(255,69,58,0.15); border: 1px solid rgba(255,69,58,0.4); color: #ff453a;
}
.alarm-confirm-yes:hover { background: rgba(255,69,58,0.3); }
.alarm-section-label {
    font-size: 10px; color: var(--text-dim); text-transform: uppercase;
    letter-spacing: 0.5px; padding: 8px 0 4px; margin-top: 4px;
    border-top: 1px solid rgba(0,163,224,0.08);
}
.alarm-section-label:first-child { border-top: none; margin-top: 0; }
.alarm-manual-item {
    padding: 6px 0; border-bottom: 1px solid rgba(0,163,224,0.06);
    display: flex; align-items: flex-start; justify-content: space-between;
}
.alarm-manual-item:last-child { border-bottom: none; }
.alarm-manual-desc {
    font-family: var(--font-mono); font-size: 11px; color: var(--text-primary);
}
.alarm-manual-time {
    font-size: 10px; color: var(--text-dim); margin-top: 2px;
}

/* === TT&C TOAST NOTIFICATION === */
.ttc-toast {
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%) translateY(-80px);
    z-index: 300; background: var(--bg-panel); border: 1px solid var(--orange);
    border-radius: 10px; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    padding: 12px 20px; max-width: 350px; text-align: center;
    opacity: 0; transition: transform 0.4s ease, opacity 0.4s ease;
    pointer-events: none;
}
.ttc-toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: auto; }
.ttc-toast-title { font-size: 12px; font-weight: 600; color: var(--orange); margin-bottom: 4px; }
.ttc-toast-message { font-family: var(--font-mono); font-size: 11px; color: var(--text-primary); margin-bottom: 8px; }
.ttc-toast-close {
    background: none; border: 1px solid var(--border); border-radius: 6px;
    color: var(--text-secondary); cursor: pointer; font-size: 10px;
    padding: 3px 12px; font-family: var(--font-mono); text-transform: uppercase;
    letter-spacing: 1px; transition: all 0.2s;
}
.ttc-toast-close:hover { border-color: var(--text-primary); color: var(--text-primary); }

.orbital-viz-label {
    position: fixed; z-index: 15;
    padding: 8px 14px;
    background: rgba(5, 10, 20, 0.85);
    backdrop-filter: blur(8px);
    border: 1px solid var(--border-bright);
    border-radius: 8px;
    font-family: var(--font-mono); font-size: 12px;
    color: var(--text-primary);
    pointer-events: none;
    transform: translate(-50%, -100%);
    white-space: nowrap;
    opacity: 0; transition: opacity 0.3s;
}
.orbital-viz-label.visible { opacity: 1; }
.orbital-viz-label .viz-title { font-weight: 600; color: var(--success); }
.orbital-viz-label .viz-subtitle { color: var(--text-secondary); margin-top: 2px; }

.viz-tag {
    position: fixed; z-index: 14;
    padding: 3px 8px;
    background: rgba(5, 10, 20, 0.75);
    backdrop-filter: blur(4px);
    border-radius: 4px;
    font-family: var(--font-mono); font-size: 10px;
    letter-spacing: 0.5px;
    pointer-events: none;
    transform: translate(-50%, -50%);
    white-space: nowrap;
    opacity: 0; transition: opacity 0.3s;
}
.viz-tag.visible { opacity: 1; }

/* === TOGGLE BUTTON === */
#panel-toggle {
    position: fixed; right: 16px; top: 50%;
    transform: translateY(-50%);
    z-index: 11;
    width: 32px; height: 80px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; color: var(--text-secondary);
    font-size: 14px;
    transition: all 0.3s;
}
#panel-toggle:hover { border-color: var(--accent); color: var(--text-primary); }
#panel-toggle.panel-open { right: 348px; }

/* === TOOLTIP === */
#tooltip {
    position: fixed; left: 0; top: 0; z-index: 20;
    padding: 8px 12px;
    background: rgba(5, 10, 20, 0.95);
    border: 1px solid var(--border-bright);
    border-radius: 8px;
    font-size: 12px; font-family: var(--font-mono);
    pointer-events: none;
    opacity: 0; transition: opacity 0.15s;
    white-space: nowrap;
    will-change: transform;
}
#tooltip.visible { opacity: 1; }

.live-indicator {
    display: flex; align-items: center; gap: 8px; flex-direction: row;
}
.live-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--text-dim);
    box-shadow: none;
    transition: background 0.3s, box-shadow 0.3s;
}
.live-indicator.is-live .live-dot {
    background: var(--success);
    box-shadow: 0 0 8px var(--success);
    animation: pulse 2s ease-in-out infinite;
}
.live-indicator:not(.is-live) .live-dot {
    animation: none;
}
.live-indicator:not(.is-live) span {
    color: var(--text-dim);
}
@keyframes pulse {
    0%, 100% { opacity: 1; box-shadow: 0 0 8px var(--success); }
    50% { opacity: 0.5; box-shadow: 0 0 4px var(--success); }
}

/* === GROUND STATIONS === */
.ground-station {
    position: fixed; left: 0; top: 0; z-index: 9;
    pointer-events: none;
    display: flex; align-items: center; gap: 6px;
    transition: opacity 0.3s;
    will-change: transform;
}
.ground-station.gs-hidden { opacity: 0; pointer-events: none; }
.ground-station.behind-globe { opacity: 0; }

/* TT&C markers — diamond */
.gs-marker-ttc {
    width: 10px; height: 10px;
    border: 2px solid #ff6b9d;
    border-radius: 2px;
    transform: rotate(45deg);
    box-shadow: 0 0 8px rgba(255, 107, 157, 0.5);
    flex-shrink: 0;
}
.gs-label-ttc {
    font-family: var(--font-mono);
    font-size: 11px; font-weight: 500;
    color: #ff6b9d;
    text-shadow: 0 1px 6px rgba(0,0,0,0.9), 0 0 12px rgba(0,0,0,0.7);
    white-space: nowrap;
}

/* Gateway markers — circle */
.gs-marker-gw {
    width: 8px; height: 8px;
    border: 2px solid #4ecdc4;
    border-radius: 50%;
    box-shadow: 0 0 6px rgba(78, 205, 196, 0.5);
    flex-shrink: 0;
}
.gs-label-gw {
    font-family: var(--font-mono);
    font-size: 10px; font-weight: 500;
    color: #4ecdc4;
    text-shadow: 0 1px 6px rgba(0,0,0,0.9), 0 0 12px rgba(0,0,0,0.7);
    white-space: nowrap;
}

.gs-sublabel {
    font-size: 9px; font-weight: 400;
    color: var(--text-secondary);
    display: block;
}

/* === STATION TOGGLES PANEL === */
#gs-controls {
    position: fixed; bottom: 20px; left: 16px; z-index: 10;
    display: flex; flex-direction: column; gap: 6px;
}
.gs-toggle-half-row {
    display: flex; gap: 6px;
}
.gs-toggle-half {
    flex: 1; min-width: 0; justify-content: center;
    padding: 7px 8px;
}
.gs-toggle-btn {
    display: flex; align-items: center; gap: 8px;
    padding: 7px 14px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    cursor: pointer; transition: all 0.2s;
    font-family: var(--font-ui); font-size: 11px;
    color: var(--text-secondary);
    user-select: none;
    white-space: nowrap;
}
.gs-toggle-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.gs-toggle-btn.active-ttc { border-color: #ff6b9d; color: #ff6b9d; }
.gs-toggle-btn.active-gw { border-color: #4ecdc4; color: #4ecdc4; }
.gs-toggle-icon {
    width: 14px; height: 14px;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
}
.gs-toggle-icon .diamond {
    width: 7px; height: 7px;
    border: 1.5px solid var(--text-dim);
    border-radius: 1px;
    transform: rotate(45deg);
    transition: border-color 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-ttc .diamond {
    border-color: #ff6b9d;
    box-shadow: 0 0 4px #ff6b9d;
}
.gs-toggle-icon .circle {
    width: 6px; height: 6px;
    border: 1.5px solid var(--text-dim);
    border-radius: 50%;
    transition: border-color 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-gw .circle {
    border-color: #4ecdc4;
    box-shadow: 0 0 4px #4ecdc4;
}
.gs-toggle-btn.active-sun { border-color: #ffb74d; color: #ffb74d; }
.gs-toggle-icon .sun-icon {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--text-dim);
    transition: background 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-sun .sun-icon {
    background: #ffb74d;
    box-shadow: 0 0 6px #ffb74d;
}
.geo-label {
    position: fixed; left: 0; top: 0; z-index: 9;
    pointer-events: auto; cursor: pointer;
    font-family: var(--font-mono);
    font-size: 9px; font-weight: 500;
    color: #ffc107;
    text-shadow: 0 1px 6px rgba(0,0,0,0.9), 0 0 12px rgba(0,0,0,0.7);
    white-space: nowrap;
    padding: 2px 4px;
    transition: opacity 0.3s, color 0.2s;
    will-change: transform;
}
.geo-label:hover { color: #ffe082; }
.geo-label.geo-selected {
    color: #ffffff; font-size: 12px; font-weight: 700;
    text-shadow: 0 0 8px rgba(255,255,255,0.6), 0 1px 6px rgba(0,0,0,0.9);
}
.geo-label.gs-hidden { opacity: 0; pointer-events: none; }
.geo-label.behind-globe { opacity: 0; pointer-events: none; }
.gs-toggle-btn.active-beams { border-color: #00e5ff; color: #00e5ff; }
.gs-toggle-icon .beam-icon {
    width: 10px; height: 5px;
    border: 1.5px solid var(--text-dim);
    border-radius: 50%;
    transition: border-color 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-beams .beam-icon {
    border-color: #00e5ff;
    box-shadow: 0 0 4px #00e5ff;
}
.gs-toggle-btn.active-saa { border-color: #ff5252; color: #ff5252; }
.gs-toggle-icon .saa-icon {
    width: 7px; height: 7px;
    border: 1.5px solid var(--text-dim);
    border-radius: 2px;
    transition: border-color 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-saa .saa-icon {
    border-color: #ff5252;
    box-shadow: 0 0 4px #ff5252;
    background: rgba(255, 82, 82, 0.3);
}
.gs-toggle-btn.active-stars { border-color: #e8eaed; color: #e8eaed; }
.gs-toggle-icon .stars-icon {
    width: 8px; height: 8px; position: relative;
}
.gs-toggle-icon .stars-icon::before,
.gs-toggle-icon .stars-icon::after {
    content: ''; position: absolute; border-radius: 50%;
    background: var(--text-dim); transition: background 0.2s, box-shadow 0.2s;
}
.gs-toggle-icon .stars-icon::before {
    width: 4px; height: 4px; top: 0; left: 0;
}
.gs-toggle-icon .stars-icon::after {
    width: 2px; height: 2px; bottom: 0; right: 0;
}
.gs-toggle-btn.active-stars .stars-icon::before {
    background: #e8eaed; box-shadow: 0 0 4px rgba(255,255,255,0.8);
}
.gs-toggle-btn.active-stars .stars-icon::after {
    background: #e8eaed; box-shadow: 0 0 3px rgba(255,255,255,0.6);
}
.gs-toggle-btn.active-catalog { border-color: #b388ff; color: #b388ff; }
.gs-toggle-icon .catalog-icon {
    width: 8px; height: 8px;
    border: 1.5px solid var(--text-dim);
    border-radius: 2px;
    transition: border-color 0.2s, box-shadow 0.2s;
    position: relative;
}
.gs-toggle-icon .catalog-icon::after {
    content: '+'; position: absolute; top: -4px; right: -4px;
    font-size: 8px; font-weight: 700; line-height: 1; color: var(--text-dim);
    transition: color 0.2s;
}
.gs-toggle-btn.active-catalog .catalog-icon {
    border-color: #b388ff;
    box-shadow: 0 0 4px #b388ff;
}
.gs-toggle-btn.active-catalog .catalog-icon::after { color: #b388ff; }

/* === CATALOG PANEL === */
#catalog-panel {
    position: fixed; bottom: 20px; left: 220px; z-index: 10;
    width: 280px; max-height: 65vh;
    background: var(--bg-panel);
    border: 1px solid rgba(179, 136, 255, 0.25);
    border-radius: 14px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
    transform: translateX(-20px); opacity: 0; pointer-events: none;
    transition: transform 0.25s ease, opacity 0.25s ease;
}
#catalog-panel.open {
    transform: translateX(0); opacity: 1; pointer-events: auto;
}
.catalog-header {
    padding: 12px 16px;
    border-bottom: 1px solid rgba(179, 136, 255, 0.12);
    display: flex; align-items: center; justify-content: space-between;
}
.catalog-header-title {
    font-size: 12px; font-weight: 600; color: #b388ff;
    text-transform: uppercase; letter-spacing: 1.5px;
}
.catalog-close {
    width: 24px; height: 24px; display: flex;
    align-items: center; justify-content: center;
    background: transparent; border: 1px solid var(--border);
    border-radius: 6px; color: var(--text-secondary);
    cursor: pointer; font-size: 14px; transition: all 0.2s;
}
.catalog-close:hover { border-color: #b388ff; color: var(--text-primary); }
.catalog-body {
    overflow-y: auto; max-height: calc(65vh - 48px);
    padding: 6px 0;
}
.catalog-body::-webkit-scrollbar { width: 4px; }
.catalog-body::-webkit-scrollbar-track { background: transparent; }
.catalog-body::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.catalog-category {
    padding: 0 8px;
}
.catalog-category-header {
    display: flex; align-items: center; gap: 6px;
    padding: 6px 8px; cursor: pointer; user-select: none;
    border-radius: 6px; transition: background 0.15s;
}
.catalog-category-header:hover { background: rgba(255,255,255,0.04); }
.catalog-category-chevron {
    font-size: 8px; color: var(--text-dim);
    transition: transform 0.2s; width: 12px; text-align: center;
}
.catalog-category.collapsed .catalog-category-chevron { transform: rotate(-90deg); }
.catalog-category-label {
    font-size: 10px; font-weight: 700; text-transform: uppercase;
    letter-spacing: 1.2px; color: var(--text-secondary);
}
.catalog-category-body { padding: 0 4px; }
.catalog-category.collapsed .catalog-category-body { display: none; }
.catalog-group-row {
    display: flex; align-items: center; gap: 8px;
    padding: 5px 8px; border-radius: 6px;
    cursor: pointer; transition: background 0.15s;
}
.catalog-group-row:hover { background: rgba(255,255,255,0.04); }
.catalog-group-dot {
    width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
    opacity: 0.4; transition: opacity 0.2s;
}
.catalog-group-row.active .catalog-group-dot { opacity: 1; }
.catalog-group-label {
    font-size: 11px; color: var(--text-secondary);
    flex: 1; transition: color 0.2s;
}
.catalog-group-row.active .catalog-group-label { color: var(--text-primary); }
.catalog-group-count {
    font-family: var(--font-mono); font-size: 9px;
    color: var(--text-dim); background: rgba(255,255,255,0.06);
    padding: 1px 6px; border-radius: 8px; min-width: 20px; text-align: center;
}
.catalog-group-spinner {
    width: 12px; height: 12px;
    border: 1.5px solid var(--border);
    border-top-color: #b388ff;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}
.catalog-select-all {
    font-family: var(--font-mono); font-size: 9px; font-weight: 600;
    padding: 3px 8px; border-radius: 5px;
    background: rgba(179, 136, 255, 0.1);
    border: 1px solid rgba(179, 136, 255, 0.25);
    color: #b388ff; cursor: pointer;
    transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.5px;
}
.catalog-select-all:hover {
    background: rgba(179, 136, 255, 0.2);
    border-color: rgba(179, 136, 255, 0.4);
}
.catalog-trail-btn {
    width: 22px; height: 22px; flex-shrink: 0;
    display: flex; align-items: center; justify-content: center;
    border-radius: 4px; cursor: pointer;
    opacity: 0.15; pointer-events: none;
    transition: opacity 0.2s, background 0.2s;
}
.catalog-trail-btn.enabled {
    opacity: 1; pointer-events: auto;
}
.catalog-trail-btn.enabled:hover {
    background: rgba(255,255,255,0.08);
}
.catalog-trail-btn.active {
    opacity: 1;
}
.catalog-trail-btn.active svg { filter: drop-shadow(0 0 3px currentColor); }
.catalog-trail-btn svg {
    width: 14px; height: 14px;
}
#frame-toggle {
    display: flex; align-items: center;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    padding: 2px;
    cursor: pointer; user-select: none;
    position: relative;
}
#frame-toggle .frame-opt {
    flex: 1;
    padding: 5px 10px;
    font-family: var(--font-mono); font-size: 10px; font-weight: 500;
    color: var(--text-dim);
    border-radius: 8px;
    transition: color 0.25s;
    position: relative; z-index: 1;
    letter-spacing: 0.5px;
}
#frame-ecef { text-align: left; }
#frame-eci { text-align: left; }
#frame-toggle .frame-opt.active {
    color: #e0e8f0;
}
#frame-toggle .frame-opt:hover {
    color: var(--text-secondary);
}
#frame-toggle .frame-opt.active:hover {
    color: #e0e8f0;
}
#frame-toggle .frame-slider {
    position: absolute;
    top: 2px; left: 2px;
    width: calc(50% - 2px);
    height: calc(100% - 4px);
    background: rgba(179, 136, 255, 0.2);
    border: 1px solid #b388ff;
    border-radius: 8px;
    transition: transform 0.25s ease;
    box-shadow: 0 0 8px rgba(179, 136, 255, 0.15);
}
#frame-toggle.eci .frame-slider {
    transform: translateX(100%);
}
#frame-toggle.eci {
    border-color: rgba(179, 136, 255, 0.35);
}
#frame-toggle:hover {
    border-color: rgba(179, 136, 255, 0.4);
}
.frame-tooltip {
    position: absolute;
    left: calc(100% + 10px);
    top: 50%; transform: translateY(-50%);
    background: var(--bg-panel);
    border: 1px solid var(--border-bright);
    border-radius: 6px;
    padding: 4px 8px;
    font-family: var(--font-ui); font-size: 10px;
    color: var(--text-secondary);
    white-space: nowrap;
    pointer-events: none;
    opacity: 0; transition: opacity 0.15s;
    backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    z-index: 20;
}
#frame-toggle:hover .frame-tooltip { opacity: 1; }

/* === BOTTOM ACTIONS (Reset View + Live) === */
#bottom-actions {
    position: fixed; bottom: 84px; left: 50%; transform: translateX(-50%);
    z-index: 10;
    display: flex; gap: 8px; align-items: center;
}
.bottom-action-btn {
    padding: 8px 20px;
    background: var(--bg-panel);
    border-radius: 10px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    cursor: pointer;
    font-family: var(--font-mono); font-size: 12px;
    transition: all 0.3s;
    user-select: none;
}
#reset-view {
    border: 1px solid var(--orange);
    color: var(--orange);
}
#reset-view:hover { background: rgba(255, 107, 53, 0.15); }
#live-btn {
    border: 1px solid var(--border);
    color: var(--text-secondary);
}
#live-btn:hover { border-color: var(--border-bright); }
#live-btn.is-live { border-color: var(--success); color: var(--success); }

/* === ROTATE BUTTONS === */
.rotate-btn {
    border: 1px solid var(--accent);
    color: var(--accent-bright);
}
.rotate-btn:hover {
    background: var(--accent-glow);
    border-color: var(--accent-bright);
}

/* === RESPONSIVE === */
@media (max-width: 768px) {
    #side-panel { width: 260px; right: 8px; top: 70px; bottom: 70px; }
    #detail-panel { width: 260px; left: 8px; }
    #geo-panel { width: 260px; left: 8px; }
    #catalog-panel { left: 180px; width: 240px; }
    .header-stats { gap: 16px; }
    .stat-value { font-size: 16px; }
    #panel-toggle.panel-open { right: 278px; }
    .ttc-panel { width: 260px; left: 8px; }
    .alarm-panel { right: 284px; width: 260px; top: 70px; }
}

/* === MOBILE (iPhone) === */
@media (max-width: 480px) {
    /* Header: compact single row */
    #header { padding: 10px 12px; }
    .logo-mark { width: 28px; height: 28px; font-size: 11px; }
    .logo-area { gap: 8px; }
    .logo-text h1 { font-size: 12px; }
    .logo-text p { display: none; }
    .header-stats { gap: 6px; }
    .stat-value { font-size: 12px; }
    .stat-label { font-size: 7px; letter-spacing: 0.8px; }
    .data-source-value { font-size: 10px; }
    .source-stat-item { padding: 4px 6px; margin: -4px -6px; }

    /* Side panel: bottom sheet */
    #side-panel {
        width: 100vw; right: 0; left: 0;
        top: auto; bottom: 0; max-height: 50vh;
        border-radius: 14px 14px 0 0;
        padding-bottom: env(safe-area-inset-bottom);
    }
    #side-panel.collapsed { transform: translateY(100%); }
    .panel-header { padding: 12px 14px; }
    .search-box input {
        padding: 12px 12px 12px 34px;
        font-size: 16px; /* prevents iOS zoom on focus */
    }

    /* Panel toggle: bottom right, 44px touch target */
    #panel-toggle {
        right: 12px; top: auto;
        transform: none;
        width: 44px; height: 44px;
        border-radius: 50%;
        font-size: 12px;
        bottom: calc(56px + env(safe-area-inset-bottom));
    }
    #panel-toggle.panel-open {
        right: 12px;
        bottom: calc(50vh + 8px + env(safe-area-inset-bottom));
    }

    /* Detail panel: bottom sheet, collapses side panel */
    #detail-panel {
        width: 100vw; left: 0; right: 0;
        top: auto; bottom: 0; max-height: 55vh;
        border-radius: 14px 14px 0 0;
        overflow-y: auto;
        z-index: 12;
        padding-bottom: env(safe-area-inset-bottom);
    }
    #detail-panel.hidden { transform: translateY(100%); }
    #geo-panel {
        width: 100vw; left: 0; right: 0;
        top: auto; bottom: 0; max-height: 55vh;
        border-radius: 14px 14px 0 0;
        overflow-y: auto; z-index: 12;
        padding-bottom: env(safe-area-inset-bottom);
    }
    #geo-panel.hidden { transform: translateY(100%); }
    #catalog-panel {
        left: 8px; bottom: auto; top: 70px;
        width: calc(100vw - 16px); max-height: 50vh;
    }
    .detail-body { padding: 12px 14px; }
    .detail-header { padding: 12px 14px; }
    .detail-close { width: 44px; height: 44px; font-size: 20px; }

    /* Clock: bottom center, above safe area */
    #clock {
        bottom: 0;
        padding: 8px 14px;
        padding-bottom: calc(8px + env(safe-area-inset-bottom));
        gap: 10px;
        border-radius: 12px 12px 0 0;
        width: 100vw; left: 0; transform: none;
    }
    .clock-time { font-size: 13px; }
    .clock-label { font-size: 8px; margin-top: 2px; }
    .speed-slider {
        width: 70px; height: 20px;
        /* bigger touch area, same visual track */
    }
    .speed-slider::-webkit-slider-thumb {
        width: 24px; height: 24px;
    }
    .speed-slider::-moz-range-thumb {
        width: 24px; height: 24px;
    }
    .speed-label { font-size: 10px; min-width: 32px; }
    .pause-btn { width: 32px; height: 32px; font-size: 14px; }

    /* Bottom actions: row above clock */
    #bottom-actions {
        bottom: calc(48px + env(safe-area-inset-bottom));
        gap: 6px;
    }
    .bottom-action-btn {
        padding: 10px 14px; font-size: 10px;
        border-radius: 8px;
        min-height: 38px;
    }

    /* Toggle controls: top left below header (not bottom) */
    #gs-controls {
        bottom: auto; top: 56px; left: 8px;
        gap: 4px;
    }
    .gs-toggle-btn {
        padding: 8px 10px; font-size: 10px; gap: 6px;
        border-radius: 8px;
        min-height: 34px;
    }
    .gs-toggle-icon { width: 12px; height: 12px; }
    #frame-toggle .frame-opt {
        padding: 6px 10px; font-size: 9px;
    }

    /* Ground station labels: smaller, avoid clutter */
    .gs-label-ttc, .gs-label-gw {
        font-size: 8px; padding: 2px 5px;
        max-width: 90px; overflow: hidden; text-overflow: ellipsis;
    }
    .gs-sublabel { font-size: 7px; }

    /* TT&C panels: full width cards on mobile */
    .ttc-panel { width: calc(100vw - 8px); left: 4px; border-radius: 8px; padding: 8px 10px; }
    .ttc-panel-station { font-size: 10px; }
    .ttc-panel-countdown { font-size: 12px; }
    .ttc-panel-times { font-size: 9px; }

    /* Alarm panel/toast on mobile */
    .alarm-panel { right: 4px; width: calc(100vw - 8px); max-height: 300px; }
    .ttc-toast { max-width: calc(100vw - 32px); padding: 10px 14px; }
    .ttc-toast-title { font-size: 11px; }
    .ttc-toast-message { font-size: 10px; }

    /* Tooltip */
    #tooltip { font-size: 11px; padding: 6px 10px; }

    /* Modals: full width with max-height */
    .source-modal, .datetime-modal {
        width: calc(100vw - 24px);
        max-height: 80vh; overflow-y: auto;
    }

    /* Rotate buttons: hide when not needed to save space */
    .rotate-btn { padding: 10px 12px; min-height: 38px; }
}

/* === PORTRAIT WARNING (mobile only) === */
#portrait-warning {
    display: none;
    position: fixed; inset: 0; z-index: 2000;
    background: var(--bg-primary);
    flex-direction: column;
    align-items: center; justify-content: center;
    gap: 20px;
    text-align: center;
    padding: 32px;
}
.portrait-icon {
    width: 56px; height: 56px;
    border: 2px solid var(--accent);
    border-radius: 10px;
    position: relative;
    animation: rotate-hint 2s ease-in-out infinite;
}
.portrait-icon::after {
    content: '';
    position: absolute; bottom: 6px; left: 50%; transform: translateX(-50%);
    width: 12px; height: 2px;
    background: var(--accent); border-radius: 1px;
}
@keyframes rotate-hint {
    0%, 30% { transform: rotate(0deg); }
    50%, 80% { transform: rotate(90deg); }
    100% { transform: rotate(0deg); }
}
.portrait-title {
    font-size: 18px; font-weight: 600;
    color: var(--text-primary);
}
.portrait-subtitle {
    font-size: 13px; color: var(--text-secondary);
    font-family: var(--font-mono);
    line-height: 1.6;
}

@media (max-width: 480px) and (orientation: portrait) {
    #portrait-warning { display: flex; }
}

/* === MOBILE LANDSCAPE === */
@media (max-height: 440px) and (orientation: landscape) {
    /* Header: compact single row, hide subtitle */
    #header { padding: 6px 12px; }
    .logo-mark { width: 24px; height: 24px; font-size: 10px; }
    .logo-area { gap: 6px; }
    .logo-text h1 { font-size: 11px; }
    .logo-text p { display: none; }
    .header-stats { gap: 6px; }
    .stat-value { font-size: 11px; }
    .stat-label { font-size: 7px; letter-spacing: 0.6px; }
    .data-source-value { font-size: 9px; }
    .source-stat-item { padding: 3px 5px; margin: -3px -5px; }

    /* Side panel: right-side vertical panel */
    #side-panel {
        width: 220px; right: 0; left: auto;
        top: 38px; bottom: 0; max-height: none;
        border-radius: 0;
        padding-bottom: 0;
    }
    #side-panel.collapsed { transform: translateX(100%); }
    .panel-header { padding: 8px 10px; }
    .search-box input { padding: 8px 8px 8px 30px; font-size: 13px; }
    #sat-list { max-height: calc(100vh - 140px); }

    /* Panel toggle: right edge, small circular */
    #panel-toggle {
        right: 4px; top: 50%;
        transform: translateY(-50%);
        width: 32px; height: 32px;
        border-radius: 50%;
        font-size: 10px;
        bottom: auto;
    }
    #panel-toggle.panel-open {
        right: 224px;
        bottom: auto;
    }

    /* Detail panel: left-side vertical panel */
    #detail-panel {
        width: 220px; left: 0; right: auto;
        top: 38px; bottom: 0; max-height: none;
        border-radius: 0;
        overflow-y: auto;
        z-index: 12;
        padding-bottom: 0;
    }
    #detail-panel.hidden { transform: translateX(-100%); }
    #geo-panel {
        width: 220px; left: 0; right: auto;
        top: 38px; bottom: 0; max-height: none;
        border-radius: 0; overflow-y: auto;
        z-index: 12; padding-bottom: 0;
    }
    #geo-panel.hidden { transform: translateX(-100%); }
    .detail-body { padding: 8px 10px; }
    .detail-header { padding: 8px 10px; }
    .detail-close { width: 36px; height: 36px; font-size: 16px; }
    .detail-title { font-size: 13px; }
    .detail-subtitle { font-size: 10px; }
    .detail-grid { gap: 4px; }
    .detail-grid dt { font-size: 9px; }
    .detail-grid dd { font-size: 11px; }
    .detail-follow-btn { padding: 3px 8px; font-size: 9px; }

    /* Clock: slim bar at bottom */
    #clock {
        bottom: 0;
        padding: 4px 12px;
        gap: 8px;
        border-radius: 8px 8px 0 0;
        left: 50%; transform: translateX(-50%);
        width: auto;
    }
    .clock-time { font-size: 11px; }
    .clock-label { font-size: 7px; margin-top: 1px; }
    .speed-slider { width: 60px; height: 16px; }
    .speed-label { font-size: 9px; min-width: 28px; }
    .pause-btn { width: 22px; height: 22px; font-size: 10px; }

    /* Bottom actions: compact, above clock */
    #bottom-actions {
        bottom: 32px;
        gap: 4px;
    }
    .bottom-action-btn {
        padding: 6px 10px; font-size: 9px;
        border-radius: 6px;
        min-height: 28px;
    }

    /* Toggle controls: top-left, very compact */
    #gs-controls {
        bottom: auto; top: 42px; left: 4px;
        gap: 2px;
    }
    .gs-toggle-btn {
        padding: 4px 6px; font-size: 9px; gap: 4px;
        border-radius: 6px;
        min-height: 26px;
    }
    .gs-toggle-icon { width: 10px; height: 10px; }
    #frame-toggle .frame-opt {
        padding: 4px 6px; font-size: 8px;
    }

    /* Rotate buttons: compact */
    .rotate-btn { padding: 6px 8px; min-height: 28px; font-size: 10px; }

    /* Ground station labels */
    .gs-label-ttc, .gs-label-gw {
        font-size: 7px; padding: 1px 4px;
    }

    /* TT&C panels: match detail panel width in landscape */
    .ttc-panel { width: 220px; left: 0; padding: 6px 8px; border-radius: 0; }
    .ttc-panel-station { font-size: 9px; }
    .ttc-panel-countdown { font-size: 10px; }
    .ttc-panel-times { font-size: 8px; margin-top: 2px; }

    /* Alarm panel in landscape */
    .alarm-panel { right: 228px; width: 220px; top: 38px; max-height: 280px; }
    .ttc-toast { max-width: 280px; top: 10px; padding: 8px 14px; }
    .ttc-toast-title { font-size: 10px; }
    .ttc-toast-message { font-size: 9px; }

    /* Tooltip */
    #tooltip { font-size: 10px; padding: 4px 8px; }

    /* Modals */
    .source-modal, .datetime-modal {
        max-height: 90vh; overflow-y: auto;
    }
}
</style>
</head>
<body>

<!-- Portrait Warning -->
<div id="portrait-warning">
    <div class="portrait-icon"></div>
    <div class="portrait-title">Rotate Your Device</div>
    <div class="portrait-subtitle">This tracker is best experienced<br>in landscape orientation</div>
</div>

<!-- Loading Screen -->
<div id="loading-screen">
    <div class="loading-logo">OW<span>TRACK</span></div>
    <div class="loading-spinner"></div>
    <div class="loading-status" id="loading-status">Initializing...</div>
</div>

<!-- 3D Canvas -->
<div id="canvas-container"></div>

<!-- Header -->
<div id="header">
    <div class="logo-area">
        <div class="logo-mark">OW</div>
        <div class="logo-text">
            <h1>OneWeb Constellation Tracker</h1>
            <p>Real-time LEO Satellite Monitoring</p>
        </div>
    </div>
    <div class="header-stats">
        <div class="stat-item alarm-stat-item" id="alarm-stat" title="TT&C Alarms">
            <div class="stat-value alarm-stat-value" id="stat-alarms">0</div>
            <div class="stat-label">Alarms</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="stat-total">--</div>
            <div class="stat-label">Satellites</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="stat-altitude">--</div>
            <div class="stat-label">Avg Alt (km)</div>
        </div>
        <div class="stat-item source-stat-item" id="source-click-area">
            <div class="stat-value data-source-value" id="stat-source">--</div>
            <div class="stat-label">Source</div>
        </div>
    </div>
</div>

<!-- Clock / Time Controls -->

<div id="clock">
    <div>
        <div class="clock-time" id="clock-time">---------- --:--:--</div>
        <div class="clock-label">UTC</div>
    </div>
    <div class="clock-divider"></div>
    <div class="speed-controls">
        <button class="pause-btn" id="pause-btn" title="Pause/Resume">&#x23F8;</button>
        <input type="range" class="speed-slider" id="speed-slider" min="-100" max="100" value="0">
        <span class="speed-label" id="speed-label">1x</span>
    </div>
</div>

<!-- Side Panel: Satellite List -->
<div id="side-panel">
    <div class="panel-header">
        <div class="panel-title">Constellation</div>
        <div class="search-box">
            <span class="search-icon">&gt;</span>
            <input type="text" id="search-input" placeholder="Search satellites...">
        </div>
    </div>
    <div class="sat-list" id="sat-list"></div>
</div>

<!-- Panel Toggle -->
<div id="panel-toggle" class="panel-open" title="Toggle satellite list">&#x25C0;</div>

<!-- Detail Panel (selected satellite) -->
<div id="detail-panel" class="hidden">
    <div class="detail-header">
        <div class="detail-name" id="detail-name">--</div>
        <div class="detail-header-actions">
            <button class="detail-beams-btn" id="detail-beams" title="Toggle beams"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><circle cx="8" cy="8" r="2"/><path d="M4.5 4.5a5 5 0 0 0 0 7"/><path d="M11.5 4.5a5 5 0 0 1 0 7"/><path d="M2 2a8.5 8.5 0 0 0 0 12"/><path d="M14 2a8.5 8.5 0 0 1 0 12"/></svg></button>
            <button class="detail-plot-btn" id="detail-plot" title="Plot orbital elements"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><polyline points="2 12 5 7 8 9 11 4 14 6"/><line x1="2" y1="14" x2="2" y2="2"/><line x1="2" y1="14" x2="14" y2="14"/></svg></button>
            <button class="detail-alarm-btn" id="detail-alarm" title="Alert 1 min before TT&C pass"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><circle cx="8" cy="8.5" r="5"/><line x1="8" y1="5.5" x2="8" y2="8.5"/><line x1="8" y1="8.5" x2="10" y2="10"/><line x1="3.5" y1="3" x2="5.5" y2="1.5"/><line x1="12.5" y1="3" x2="10.5" y2="1.5"/><line x1="4" y1="14" x2="6" y2="12.5"/><line x1="12" y1="14" x2="10" y2="12.5"/></svg></button>
            <button class="detail-close" id="detail-close">&times;</button>
        </div>
    </div>
    <div class="detail-body">
        <div class="detail-section">
            <div class="detail-section-title">Position</div>
            <div class="detail-grid">
                <div class="detail-field">
                    <div class="detail-field-label">Latitude</div>
                    <div class="detail-field-value" id="detail-lat">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Longitude</div>
                    <div class="detail-field-value" id="detail-lon">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Altitude</div>
                    <div class="detail-field-value" id="detail-alt">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Velocity</div>
                    <div class="detail-field-value" id="detail-vel">--</div>
                </div>
            </div>
        </div>
        <div class="detail-section">
            <div class="detail-section-title">Orbital Elements</div>
            <div class="detail-grid">
                <div class="detail-field">
                    <div class="detail-field-label">Inclination</div>
                    <div class="detail-field-value clickable" id="detail-inc">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Eccentricity <span class="ecc-info-icon" id="ecc-info-btn" title="Info">&#9432;</span></div>
                    <div class="detail-field-value clickable" id="detail-ecc">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">RAAN</div>
                    <div class="detail-field-value clickable" id="detail-raan">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Arg of Latitude</div>
                    <div class="detail-field-value clickable" id="detail-aol">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Period</div>
                    <div class="detail-field-value" id="detail-period">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">NORAD ID</div>
                    <div class="detail-field-value" id="detail-norad">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">TLE Age <span class="ecc-info-icon" id="tle-info-btn" title="Info">&#9432;</span></div>
                    <div class="detail-field-value clickable" id="detail-tle-age">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Plane</div>
                    <div class="detail-field-value clickable" id="detail-plane">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Formation</div>
                    <div class="detail-field-value" id="detail-formation">--</div>
                </div>
                <div class="detail-field" style="grid-column: 1 / -1; margin-top: 4px;">
                    <button class="detail-follow-btn" id="detail-track">Follow</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- GEO Info Panel -->
<div id="geo-panel" class="hidden">
    <div class="geo-panel-header">
        <div>
            <div class="geo-panel-name" id="geo-panel-name">--</div>
            <div class="geo-panel-slot" id="geo-panel-slot"></div>
        </div>
        <button class="geo-panel-close" id="geo-panel-close">&times;</button>
    </div>
    <div class="geo-panel-body">
        <div class="geo-panel-section">
            <div class="geo-panel-section-title">Services</div>
            <div class="geo-panel-services" id="geo-panel-services"></div>
        </div>
        <div class="geo-panel-section">
            <div class="geo-panel-section-title">Details</div>
            <div class="geo-panel-desc" id="geo-panel-desc"></div>
        </div>
        <div class="geo-panel-section">
            <div class="geo-panel-section-title">Position</div>
            <div class="geo-panel-grid">
                <div>
                    <div class="geo-panel-field-label">Longitude</div>
                    <div class="geo-panel-field-value" id="geo-panel-lon">--</div>
                </div>
                <div>
                    <div class="geo-panel-field-label">Altitude</div>
                    <div class="geo-panel-field-value" id="geo-panel-alt">--</div>
                </div>
            </div>
        </div>
        <div class="geo-panel-norad" id="geo-panel-norad"></div>
    </div>
</div>

<!-- Catalog Panel -->
<div id="catalog-panel">
    <div class="catalog-header">
        <div class="catalog-header-title">Satellite Catalog</div>
        <div style="display:flex;align-items:center;gap:6px">
            <button class="catalog-select-all" id="catalog-select-all">All On</button>
            <button class="catalog-close" id="catalog-close">&times;</button>
        </div>
    </div>
    <div class="catalog-body" id="catalog-body"></div>
</div>

<!-- TT&C Pass Panels -->
<div class="ttc-panel" id="ttc-panel-svalbard">
    <div class="ttc-panel-row">
        <div class="ttc-panel-station">Svalbard</div>
        <div class="ttc-panel-countdown" id="ttc-svalbard-countdown">--</div>
    </div>
    <div class="ttc-panel-times" id="ttc-svalbard-times"></div>
</div>
<div class="ttc-panel" id="ttc-panel-inuvik">
    <div class="ttc-panel-row">
        <div class="ttc-panel-station">Inuvik</div>
        <div class="ttc-panel-countdown" id="ttc-inuvik-countdown">--</div>
    </div>
    <div class="ttc-panel-times" id="ttc-inuvik-times"></div>
</div>

<!-- Alarm management panel -->
<div class="alarm-panel" id="alarm-panel">
    <div class="alarm-panel-title">
        Alarms
        <button class="alarm-panel-close" id="alarm-panel-close">&times;</button>
    </div>
    <div id="alarm-list"></div>
    <button class="alarm-add-btn" id="alarm-add-manual">+ Add Manual Alarm</button>
</div>

<!-- Manual alarm modal -->
<div class="alarm-modal-overlay" id="alarm-modal-overlay">
    <div class="alarm-modal">
        <div class="alarm-panel-title">Add Manual Alarm
            <button class="alarm-panel-close" id="alarm-modal-close">&times;</button>
        </div>
        <label>SCID<input type="text" id="alarm-scid" placeholder="e.g. 0145"></label>
        <label>Description<input type="text" id="alarm-desc" placeholder="e.g. Manoeuvre window"></label>
        <label>Time (UTC)<input type="datetime-local" id="alarm-time"></label>
        <button class="alarm-add-btn" id="alarm-modal-save">Add Alarm</button>
    </div>
</div>

<!-- Alarm confirm modal -->
<div class="alarm-modal-overlay" id="alarm-confirm-overlay">
    <div class="alarm-modal">
        <div class="alarm-panel-title">Remove Alarm
            <button class="alarm-panel-close" id="alarm-confirm-close">&times;</button>
        </div>
        <div class="alarm-confirm-text" id="alarm-confirm-text">Are you sure you want to clear this alarm?</div>
        <div class="alarm-confirm-btns">
            <button class="alarm-confirm-cancel" id="alarm-confirm-cancel">Cancel</button>
            <button class="alarm-confirm-yes" id="alarm-confirm-yes">Remove</button>
        </div>
    </div>
</div>

<!-- Toast notification -->
<div class="ttc-toast" id="ttc-toast">
    <div class="ttc-toast-title" id="ttc-toast-title"></div>
    <div class="ttc-toast-message" id="ttc-toast-message"></div>
    <button class="ttc-toast-close" id="ttc-toast-close">Dismiss</button>
</div>

<!-- TT&C Station Labels -->
<div class="ground-station gs-ttc" id="gs-svalbard">
    <div class="gs-marker-ttc"></div>
    <div class="gs-label-ttc">Svalbard<span class="gs-sublabel">TT&C Station</span></div>
</div>
<div class="ground-station gs-ttc" id="gs-inuvik">
    <div class="gs-marker-ttc"></div>
    <div class="gs-label-ttc">Inuvik<span class="gs-sublabel">TT&C Station</span></div>
</div>

<!-- Gateway / SNP Station Labels -->
<div class="ground-station gs-gw" id="gs-talkeetna">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Talkeetna<span class="gs-sublabel">SNP &middot; Alaska</span></div>
</div>
<div class="ground-station gs-gw" id="gs-connecticut">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Connecticut<span class="gs-sublabel">SNP</span></div>
</div>
<div class="ground-station gs-gw" id="gs-florida">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Florida<span class="gs-sublabel">SNP</span></div>
</div>
<div class="ground-station gs-gw" id="gs-hawaii">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Hawaii<span class="gs-sublabel">SNP</span></div>
</div>
<div class="ground-station gs-gw" id="gs-yellowknife">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Yellowknife<span class="gs-sublabel">SNP &middot; Canada</span></div>
</div>
<div class="ground-station gs-gw" id="gs-toluca">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Toluca<span class="gs-sublabel">SNP &middot; Mexico</span></div>
</div>
<div class="ground-station gs-gw" id="gs-santiago">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Santiago<span class="gs-sublabel">SNP &middot; Chile</span></div>
</div>
<div class="ground-station gs-gw" id="gs-arica">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Arica<span class="gs-sublabel">SNP &middot; Chile</span></div>
</div>
<div class="ground-station gs-gw" id="gs-cali">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Cali<span class="gs-sublabel">SNP &middot; Colombia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-marica">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Maric&aacute;<span class="gs-sublabel">SNP &middot; Brazil</span></div>
</div>
<div class="ground-station gs-gw" id="gs-tahiti">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Tahiti<span class="gs-sublabel">SNP &middot; French Polynesia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-rambouillet">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Rambouillet<span class="gs-sublabel">SNP &middot; France</span></div>
</div>
<div class="ground-station gs-gw" id="gs-sintra">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Sintra<span class="gs-sublabel">SNP &middot; Portugal</span></div>
</div>
<div class="ground-station gs-gw" id="gs-bulgaria">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Sofia<span class="gs-sublabel">SNP &middot; Bulgaria</span></div>
</div>
<div class="ground-station gs-gw" id="gs-pitea">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Pite&aring;<span class="gs-sublabel">SNP &middot; Sweden</span></div>
</div>
<div class="ground-station gs-gw" id="gs-tabuk">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Tabuk<span class="gs-sublabel">SNP &middot; Saudi Arabia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-luanda">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Luanda<span class="gs-sublabel">SNP &middot; Angola</span></div>
</div>
<div class="ground-station gs-gw" id="gs-darwin">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Darwin<span class="gs-sublabel">SNP &middot; Australia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-toowoomba">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Toowoomba<span class="gs-sublabel">SNP &middot; Australia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-wangara">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Perth<span class="gs-sublabel">SNP &middot; Australia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-sirindhorn">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Sirindhorn<span class="gs-sublabel">SNP &middot; Thailand</span></div>
</div>
<div class="ground-station gs-gw" id="gs-gujarat">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Gujarat<span class="gs-sublabel">SNP &middot; India</span></div>
</div>

<!-- Toggle Controls -->
<div id="gs-controls">
    <div class="gs-toggle-half-row">
        <div class="gs-toggle-btn gs-toggle-half active-stars" id="toggle-stars">
            <div class="gs-toggle-icon"><div class="stars-icon"></div></div>
            Stars
        </div>
        <div class="gs-toggle-btn gs-toggle-half" id="toggle-saa">
            <div class="gs-toggle-icon"><div class="saa-icon"></div></div>
            SAA
        </div>
    </div>
    <div class="gs-toggle-btn active-ttc" id="toggle-ttc">
        <div class="gs-toggle-icon"><div class="diamond"></div></div>
        TT&C Stations
    </div>
    <div class="gs-toggle-btn active-gw" id="toggle-gw">
        <div class="gs-toggle-icon"><div class="circle"></div></div>
        Gateway Stations
    </div>
    <div class="gs-toggle-btn active-sun" id="toggle-sun">
        <div class="gs-toggle-icon"><div class="sun-icon"></div></div>
        Sun Lighting
    </div>
    <div class="gs-toggle-btn" id="toggle-catalog">
        <div class="gs-toggle-icon"><div class="catalog-icon"></div></div>
        Catalog
    </div>
    <div id="frame-toggle">
        <div class="frame-slider"></div>
        <div class="frame-opt active" id="frame-ecef">ECEF</div>
        <div class="frame-opt" id="frame-eci">ECI</div>
        <div class="frame-tooltip" id="frame-tooltip">Earth-Centered Earth-Fixed</div>
    </div>
</div>

<!-- Bottom Actions -->
<div id="bottom-actions">
    <button class="bottom-action-btn rotate-btn" id="rotate-plus">+90&deg;</button>
    <div id="reset-view" class="bottom-action-btn">Reset View</div>
    <button class="bottom-action-btn rotate-btn" id="rotate-minus">&minus;90&deg;</button>
    <div id="live-btn" class="bottom-action-btn live-indicator is-live" title="Click to sync to real time">
        <div class="live-dot"></div>
        <span>LIVE</span>
    </div>
</div>

<!-- Source Info Modal -->
<div class="source-modal-overlay" id="source-modal">
    <div class="source-modal">
        <div class="source-modal-header">
            <h3>Data Sources</h3>
            <button class="source-modal-close" id="source-modal-close">&times;</button>
        </div>
        <div class="source-tabs">
            <button class="source-tab active-tab" data-tab="primary">Primary</button>
            <button class="source-tab" data-tab="secondary">Secondary</button>
        </div>
        <div class="source-tab-content active-content" id="tab-primary">
            <div><span class="source-field">Name:</span> CelesTrak (Direct)</div>
            <div><span class="source-field">URL:</span> celestrak.org</div>
            <div><span class="source-field">Type:</span> Direct HTTPS fetch</div>
            <div><span class="source-field">Data:</span> GP TLE format (OneWeb group)</div>
            <div><span class="source-field">Status:</span> <span class="source-status" id="primary-status">--</span></div>
        </div>
        <div class="source-tab-content" id="tab-secondary">
            <div><span class="source-field">Name:</span> CORS Proxy Fallback</div>
            <div><span class="source-field">URL:</span> corsproxy.io / codetabs.com</div>
            <div><span class="source-field">Type:</span> Proxied HTTPS fetch</div>
            <div><span class="source-field">Data:</span> GP TLE format (via CelesTrak)</div>
            <div><span class="source-field">Status:</span> <span class="source-status" id="secondary-status">--</span></div>
        </div>
    </div>
</div>

<!-- DateTime Picker Modal -->
<div class="datetime-modal-overlay" id="datetime-modal">
    <div class="datetime-modal">
        <div class="datetime-modal-header">
            <h3>Jump to Date &amp; Time</h3>
            <button class="datetime-modal-close" id="datetime-modal-close">&times;</button>
        </div>
        <div class="datetime-modal-body">
            <input type="datetime-local" class="datetime-input" id="datetime-input" step="1">
            <div class="datetime-error" id="datetime-error"></div>
            <div class="datetime-buttons">
                <button class="datetime-btn datetime-btn-now" id="datetime-now">Now</button>
                <button class="datetime-btn datetime-btn-go" id="datetime-go">Go</button>
            </div>
        </div>
    </div>
</div>

<!-- Tooltip -->
<div id="tooltip"></div>

<script src="https://cdn.jsdelivr.net/npm/satellite.js@5.0.0/dist/satellite.min.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ============================================================
// CONSTANTS
// ============================================================
const EARTH_RADIUS = 5;
const EARTH_RADIUS_KM = 6371;
const SAT_SCALE = EARTH_RADIUS / EARTH_RADIUS_KM;
const TLE_URL = 'https://celestrak.org/NORAD/elements/gp.php?GROUP=oneweb&FORMAT=tle';
const GEO_TLE_URL = 'https://celestrak.org/NORAD/elements/gp.php?NAME=EUTELSAT&FORMAT=tle';
const CATALOG_GROUPS = [
    // Eutelsat (built-in, already loaded)
    { key: 'oneweb', label: 'OneWeb', builtin: 'oneweb', color: '#00e5ff', size: 0.22, category: 'Eutelsat' },
    { key: 'eutelsat-geo', label: 'Eutelsat GEO', builtin: 'geo', color: '#ffc107', size: 0.40, category: 'Eutelsat' },
    // Mega-Constellations
    { key: 'starlink', label: 'Starlink', groupId: 'starlink', color: '#c0c0c0', size: 0.12, category: 'Mega-Constellations' },
    { key: 'planet', label: 'Planet', groupId: 'planet', color: '#76ff03', size: 0.18, category: 'Mega-Constellations' },
    { key: 'spire', label: 'Spire', groupId: 'spire', color: '#69f0ae', size: 0.18, category: 'Mega-Constellations' },
    // Navigation
    { key: 'gps', label: 'GPS', groupId: 'gps-ops', color: '#448aff', size: 0.35, category: 'Navigation' },
    { key: 'glonass', label: 'GLONASS', groupId: 'glo-ops', color: '#ff5252', size: 0.35, category: 'Navigation' },
    { key: 'galileo', label: 'Galileo', groupId: 'galileo', color: '#ffd740', size: 0.35, category: 'Navigation' },
    { key: 'beidou', label: 'BeiDou', groupId: 'beidou', color: '#ff6e40', size: 0.35, category: 'Navigation' },
    { key: 'sbas', label: 'SBAS', groupId: 'sbas', color: '#ea80fc', size: 0.30, category: 'Navigation' },
    // Communications
    { key: 'iridium', label: 'Iridium NEXT', groupId: 'iridium-NEXT', color: '#80d8ff', size: 0.22, category: 'Communications' },
    { key: 'globalstar', label: 'Globalstar', groupId: 'globalstar', color: '#b9f6ca', size: 0.22, category: 'Communications' },
    { key: 'orbcomm', label: 'ORBCOMM', groupId: 'orbcomm', color: '#f4ff81', size: 0.22, category: 'Communications' },
    { key: 'ses', label: 'SES', groupId: 'ses', color: '#ffe57f', size: 0.22, category: 'Communications' },
    { key: 'intelsat', label: 'Intelsat', groupId: 'intelsat', color: '#ffcc80', size: 0.22, category: 'Communications' },
    { key: 'swarm', label: 'Swarm', groupId: 'swarm', color: '#a7ffeb', size: 0.15, category: 'Communications' },
    { key: 'amateur', label: 'Amateur Radio', groupId: 'amateur', color: '#e040fb', size: 0.20, category: 'Communications' },
    // Weather & Earth Obs
    { key: 'weather', label: 'Weather', groupId: 'weather', color: '#18ffff', size: 0.28, category: 'Weather & Earth Obs' },
    { key: 'noaa', label: 'NOAA', groupId: 'noaa', color: '#64ffda', size: 0.28, category: 'Weather & Earth Obs' },
    { key: 'goes', label: 'GOES', groupId: 'goes', color: '#84ffff', size: 0.30, category: 'Weather & Earth Obs' },
    { key: 'resource', label: 'Earth Resources', groupId: 'resource', color: '#ccff90', size: 0.22, category: 'Weather & Earth Obs' },
    { key: 'sarsat', label: 'SARSAT', groupId: 'sarsat', color: '#ff8a80', size: 0.25, category: 'Weather & Earth Obs' },
    { key: 'argos', label: 'ARGOS', groupId: 'argos', color: '#b388ff', size: 0.22, category: 'Weather & Earth Obs' },
    // Science & Special
    { key: 'stations', label: 'Space Stations', groupId: 'stations', color: '#ffffff', size: 0.50, category: 'Science & Special' },
    { key: 'science', label: 'Science', groupId: 'science', color: '#82b1ff', size: 0.22, category: 'Science & Special' },
    { key: 'geodetic', label: 'Geodetic', groupId: 'geodetic', color: '#f48fb1', size: 0.22, category: 'Science & Special' },
    { key: 'engineering', label: 'Engineering', groupId: 'engineering', color: '#ce93d8', size: 0.20, category: 'Science & Special' },
    { key: 'education', label: 'Education', groupId: 'education', color: '#81d4fa', size: 0.20, category: 'Science & Special' },
    // Other
    { key: 'military', label: 'Military', groupId: 'military', color: '#90a4ae', size: 0.18, category: 'Other' },
    { key: 'radar', label: 'Radar Calibration', groupId: 'radar', color: '#bcaaa4', size: 0.22, category: 'Other' },
    { key: 'cubesat', label: 'CubeSats', groupId: 'cubesat', color: '#80cbc4', size: 0.15, category: 'Other' },
    { key: 'last-30-days', label: 'Last 30 Days', groupId: 'last-30-days', color: '#ffab91', size: 0.20, category: 'Other' },
    { key: 'visual', label: 'Brightest', groupId: 'visual', color: '#fff59d', size: 0.25, category: 'Other' },
];
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// ============================================================
// STATE
// ============================================================
let scene, camera, renderer, controls;
let ambientLight, sunLight, sunMesh, moonMesh;
let sunEnabled = true;
let activeDataSource = null; // 'primary' or 'secondary'
let earthGroup, earthMesh, atmosphereMesh, starField;
let earthDayNightMat = null;
let satPointCloud, satGeometry, satColorAttr;
let planeGlowCloud = null, planeGlowGeo = null, planeGlowIndices = [];
let planeDiscMesh = null;
let satellites = [];
let selectedIndex = -1;
let orbitLine = null;
let groundTrack = null;
let pastOrbitLine = null;
let pastGroundTrack = null;
let trackingHalo = null;
let trackingArrow = null;
let haloTexture = null; // shared texture for tracking halo
let raycaster, mouse, hoveredIndex = -1;
let hoverSprite = null;
let simTime = new Date();
let timeMultiplier = 1;
let lastFrameTime = performance.now();
let _liveMode = true;
let _paused = false;
let panelOpen = true;

// Tracking / focus state
let trackingIndex = -1;
let followMode = false;
let cameraAnim = null; // { startDir, endDir, dist, startTarget, endTarget, progress, duration }
// Default camera facing the UK (lat ~54, lon ~-2)
const ukLat = 54 * Math.PI / 180;
const ukLon = -(-2) * Math.PI / 180; // negate for Three.js convention
const defaultDist = 14;
let defaultCameraPos = new THREE.Vector3(
    defaultDist * Math.cos(ukLat) * Math.cos(ukLon),
    defaultDist * Math.sin(ukLat),
    defaultDist * Math.cos(ukLat) * Math.sin(ukLon)
);
let defaultCameraTarget = new THREE.Vector3(0, 0, 0);
let ttcVisible = true;
let gwVisible = true;
let saaVisible = false;
let saaMesh = null;
let saaOutline = null;

// GEO satellite state
let geoSatsVisible = false;
let geoSatellites = [];
let geoPointCloud = null, geoGeometry = null;
let geoOrbitRing = null;
let _geoFrameCount = 0;
let _geoPreViewPos = null; // saved camera position before GEO zoom
let _geoPreViewTarget = null;

// Catalog state (per-group lazy-loaded constellations)
const catalogState = {}; // key -> { satellites, visible, loaded, loading, tleText, frameCount, baseColor }
let catalogPanelOpen = false;
let selectedCatalogGroup = null;
let selectedCatalogIndex = -1;
let _catalogHighlightSprite = null;
let _sharedPointTexture = null; // shared across all point clouds

// Merged catalog point cloud — single draw call for all catalog groups
const _catalogMerged = {
    geometry: null,
    pointCloud: null,
    material: null,
    totalUsed: 0,
    capacity: 20000,
    ranges: {},     // key -> { start, count }
};

// Constellation trail lines — per-group orbital trail visualization
// key -> { lineSegments, geometry, material, enabled, dirty, computing, lastComputeMs, sampledIndices, stepsPerSat, satCount }
const _constellationTrails = {};

// SAA contour at LEO altitude (~500-1200km), approx 10^2 protons/cm²/s flux boundary
// Center ~27°S 49°W, extends ~5°S-45°S lat, ~80°W-5°E lon (tilted NW-SE oval)
const SAA_BOUNDARY = [
    [-3, -42],    // north
    [-6, -30],    // NE
    [-10, -18],   // NE
    [-15, -8],    // east
    [-21, -2],    // east
    [-28, 0],     // east (widest east, near center lat)
    [-34, -5],    // SE
    [-38, -15],   // SE
    [-42, -28],   // south
    [-44, -40],   // south
    [-45, -52],   // SW
    [-43, -62],   // west
    [-38, -70],   // west
    [-32, -76],   // NW
    [-25, -78],   // NW (widest west)
    [-19, -74],   // NW
    [-14, -66],   // NW
    [-9, -56],    // north
    [-3, -42],    // close
];
let selectedPlane = -1;
let _mouseDirty = false;
let _lastMouseX = 0, _lastMouseY = 0;
let _tooltipContent = '';
let _tooltipX = 0, _tooltipY = 0;
let orbitalVizMode = null; // null | 'inclination' | 'raan' | 'aol' | 'eccentricity'
let orbitalVizObjects = [];
let orbitalVizLabel = null;
let vizLabelAnchor = null;
let vizTags = []; // { el, anchor: Vector3 }
let vizGmst = 0;
let referenceFrame = 'ecef'; // 'ecef' | 'eci'
let _frameBeforeViz = null; // saved frame when auto-switching to ECI for viz

// Beam footprint state
let beamMesh = null;
let beamOutline = null;
const NUM_BEAMS = 16;
const BEAM_SEGMENTS = 48;
const BEAM_RINGS = 3;
const BEAM_SEMI_MINOR_RAD = 32.5 / 6371;  // N-S half-width in radians (~0.29°)
const BEAM_SEMI_MAJOR_RAD = 800 / 6371;   // E-W half-width in radians (~7.2°)
const BEAM_SPACING_RAD = 65 / 6371;       // N-S center-to-center spacing
const BEAM_COLORS = [];
for (let _b = 0; _b < 16; _b++) {
    BEAM_COLORS.push(new THREE.Color().setHSL(_b / 16, 0.85, 0.55));
}

// Beam visualization mode: 'off' | 'individual' | 'all'
let beamMode = 'off';
let allBeamsOutline = null;
const ALL_BEAMS_SEGS = 12;
let _allBeamsFrameCount = 0;
// Pre-computed ellipse sampling (no trig in hot loop)
const _ABE = [];
for (let _i = 0; _i < ALL_BEAMS_SEGS; _i++) {
    const _th = (_i / ALL_BEAMS_SEGS) * Math.PI * 2;
    const _ac = BEAM_SEMI_MAJOR_RAD * Math.cos(_th);
    const _al = BEAM_SEMI_MINOR_RAD * Math.sin(_th);
    const _at = Math.sqrt(_ac * _ac + _al * _al);
    _ABE.push({ cosT: Math.cos(_at), sinT: Math.sin(_at), wC: _ac / _at, wA: _al / _at });
}
// Pre-computed beam center offsets along-track
const _beamOffsets = [];
for (let _b = 0; _b < NUM_BEAMS; _b++) {
    const _ao = (_b - 7.5) * BEAM_SPACING_RAD;
    _beamOffsets.push({ cosA: Math.cos(_ao), sinA: Math.sin(_ao) });
}

// TT&C pass prediction state
const TTC_MIN_ELEV_DEG = 8;
const TTC_MIN_ELEV_RAD = 8 * DEG2RAD;
const TTC_SEARCH_WINDOW_MS = 120 * 60 * 1000; // 120 min forward
const TTC_STEP_MS = 30 * 1000;    // 30s coarse steps
const TTC_REFINE_MS = 1000;        // 1s refinement

const TTC_OBSERVERS = [
    { name: 'Svalbard', gd: { longitude: 15.3894 * DEG2RAD, latitude: 78.2306 * DEG2RAD, height: 0.5 } },
    { name: 'Inuvik',   gd: { longitude: -133.723 * DEG2RAD, latitude: 68.3607 * DEG2RAD, height: 0.1 } },
];

let _ttcPasses = [null, null];
let _ttcLastPredictTime = 0;
let _ttcLastSatIndex = -1;
let _ttcDirty = true;
// Map<satIndex, { firedForAos: Set<stationIdx:aosMs>, passes: [pass|null, pass|null], lastPredictTime: number }>
const _ttcAlarms = new Map();
let _manualAlarms = []; // [{ id, scid, description, time (Date), fired }]
let _manualAlarmId = 0;
let _formations = { supersmash: [], monstermash: [] }; // [{indices: [i,...], plane, aols: [deg,...]}]
let _activeFormationSearch = null; // null | 'supersmash' | 'monstermash'
const _folderRefs = { oneweb: null, geo: null, planes: {} };
let _lastFormationKey = '';
let _formationMap = {}; // satIndex -> 'supersmash' | 'monstermash'
const SUPERSMASH_AOL_THRESHOLD = 1.4; // degrees
const MONSTERMASH_AOL_THRESHOLD = 2.0; // degrees
let _alarmAudioCtx = null;
let _alarmInterval = null;

// Reusable objects for per-frame functions (avoid GC pressure)
const _earthSphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), EARTH_RADIUS);
const _camToStation = new THREE.Vector3();
const _projectedVec = new THREE.Vector3();
const _intersectPt = new THREE.Vector3();
const _satPos = new THREE.Vector3();
const _toCamera = new THREE.Vector3();
const _velDir = new THREE.Vector3();
const _arrowOrigin = new THREE.Vector3();
const _trackDir = new THREE.Vector3();
const _trackTarget = new THREE.Vector3();
const _upVec = new THREE.Vector3(0, 1, 0);
const _quatTemp = new THREE.Quaternion();
const _beamNadir = new THREE.Vector3();
const _beamAlongTrack = new THREE.Vector3();
const _beamCrossTrack = new THREE.Vector3();
const _beamCenter = new THREE.Vector3();
const _beamVel = new THREE.Vector3();

// TT&C stations (Svalbard + Inuvik)
const TTC_STATIONS = [
    { id: 'gs-svalbard', lat: 78.2306, lon: 15.3894 },
    { id: 'gs-inuvik', lat: 68.3607, lon: -133.723 },
];

// Gateway / SNP stations (verified OneWeb Satellite Network Portals)
const GW_STATIONS = [
    // Americas (SSC-installed)
    { id: 'gs-talkeetna',    lat: 62.3209, lon: -150.1066 },  // Alaska
    { id: 'gs-connecticut',  lat: 41.3400, lon: -72.9200 },   // Connecticut, USA
    { id: 'gs-florida',      lat: 28.4885, lon: -80.5780 },   // Florida, USA
    { id: 'gs-hawaii',       lat: 21.5728, lon: -158.1134 },  // Hawaii, USA
    { id: 'gs-yellowknife',  lat: 62.4540, lon: -114.3718 },  // Yellowknife, Canada
    { id: 'gs-toluca',       lat: 19.2826, lon: -99.6557 },   // Toluca, Mexico
    { id: 'gs-santiago',     lat: -33.4489, lon: -70.6693 },  // Santiago, Chile
    { id: 'gs-arica',        lat: -18.4783, lon: -70.3126 },  // Arica, Chile
    { id: 'gs-cali',         lat: 3.4516,  lon: -76.5320 },   // Cali, Colombia
    { id: 'gs-marica',       lat: -22.9195, lon: -42.8190 },  // Maricá, Brazil
    { id: 'gs-tahiti',       lat: -17.5516, lon: -149.5585 }, // Tahiti, French Polynesia
    // Europe
    { id: 'gs-rambouillet',  lat: 48.6443, lon: 1.8352 },     // Rambouillet, France (Eutelsat teleport)
    { id: 'gs-sintra',       lat: 38.7998, lon: -9.3817 },    // Sintra, Portugal
    { id: 'gs-bulgaria',     lat: 42.6977, lon: 23.3219 },    // Bulgaria (Vivacom)
    { id: 'gs-pitea',        lat: 65.3173, lon: 21.4798 },    // Piteå, Sweden (Arctic Space)
    // Middle East & Africa
    { id: 'gs-tabuk',        lat: 28.3838, lon: 36.5550 },    // Tabuk, Saudi Arabia (stc)
    { id: 'gs-luanda',       lat: -8.8390, lon: 13.2894 },    // Luanda, Angola
    // Asia-Pacific
    { id: 'gs-darwin',       lat: -12.4634, lon: 130.8456 },  // Darwin, Australia (Telstra)
    { id: 'gs-toowoomba',    lat: -27.5598, lon: 151.9507 },  // Toowoomba, Australia (Telstra)
    { id: 'gs-wangara',      lat: -31.7881, lon: 115.8283 },  // Perth/Wangara, Australia (Telstra)
    { id: 'gs-sirindhorn',   lat: 15.1400, lon: 105.4300 },   // Sirindhorn, Thailand
    { id: 'gs-gujarat',      lat: 22.3072, lon: 70.8022 },    // Gujarat, India
];

// Combined for label projection
const ALL_STATIONS = [...TTC_STATIONS, ...GW_STATIONS];

// ============================================================
// DOM REFS
// ============================================================
const $loading = document.getElementById('loading-screen');
const $loadingStatus = document.getElementById('loading-status');
const $statTotal = document.getElementById('stat-total');
const $alarmStat = document.getElementById('alarm-stat');
const $statAlarms = document.getElementById('stat-alarms');
const $statAlt = document.getElementById('stat-altitude');
const $clockTime = document.getElementById('clock-time');
const $satList = document.getElementById('sat-list');
const $searchInput = document.getElementById('search-input');
const $detailPanel = document.getElementById('detail-panel');
const $tooltip = document.getElementById('tooltip');
const $detailName = document.getElementById('detail-name');
const $detailLat = document.getElementById('detail-lat');
const $detailLon = document.getElementById('detail-lon');
const $detailAlt = document.getElementById('detail-alt');
const $detailVel = document.getElementById('detail-vel');
const $detailInc = document.getElementById('detail-inc');
const $detailEcc = document.getElementById('detail-ecc');
const $detailPeriod = document.getElementById('detail-period');
const $detailNorad = document.getElementById('detail-norad');
const $detailTleAge = document.getElementById('detail-tle-age');
const $detailPlane = document.getElementById('detail-plane');
const $detailFormation = document.getElementById('detail-formation');
const $detailRaan = document.getElementById('detail-raan');
const $detailAol = document.getElementById('detail-aol');
const $ttcPanelSvalbard = document.getElementById('ttc-panel-svalbard');
const $ttcPanelInuvik = document.getElementById('ttc-panel-inuvik');
const $ttcSvalbardCountdown = document.getElementById('ttc-svalbard-countdown');
const $ttcSvalbardTimes = document.getElementById('ttc-svalbard-times');
const $ttcInuvikCountdown = document.getElementById('ttc-inuvik-countdown');
const $ttcInuvikTimes = document.getElementById('ttc-inuvik-times');
const $alarmPanel = document.getElementById('alarm-panel');
const $alarmList = document.getElementById('alarm-list');
const $ttcToast = document.getElementById('ttc-toast');
const $ttcToastTitle = document.getElementById('ttc-toast-title');
const $ttcToastMessage = document.getElementById('ttc-toast-message');

// ============================================================
// INIT THREE.JS
// ============================================================
function initScene() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.copy(defaultCameraPos);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = EARTH_RADIUS + 0.5;
    controls.maxDistance = 200;
    controls.enablePan = true;
    controls.rotateSpeed = 0.5;

    raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 0.15;
    mouse = new THREE.Vector2(-999, -999);

    // Ambient light
    ambientLight = new THREE.AmbientLight(0x335577, 0.6);
    scene.add(ambientLight);

    // Directional light (sun)
    sunLight = new THREE.DirectionalLight(0xffeedd, 2.0);
    sunLight.position.set(10, 5, 8);
    scene.add(sunLight);

    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('click', onMouseClick);
}

// ============================================================
// SUN DIRECTION (simplified solar ephemeris)
// ============================================================
function computeSunDirection(date) {
    // Julian date from JS Date
    const JD = date.getTime() / 86400000 + 2440587.5;
    const n = JD - 2451545.0; // days since J2000.0

    // Mean longitude & mean anomaly (degrees)
    const L = (280.460 + 0.9856474 * n) % 360;
    const g = ((357.528 + 0.9856003 * n) % 360) * DEG2RAD;

    // Ecliptic longitude (degrees)
    const lambda = (L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2 * g)) * DEG2RAD;

    // Obliquity of ecliptic
    const epsilon = 23.439 * DEG2RAD;

    // Right ascension & declination
    const ra = Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
    const dec = Math.asin(Math.sin(epsilon) * Math.sin(lambda));

    // Greenwich sidereal time (using satellite.js)
    const gmst = satellite.gstime(date);

    // Sun geographic longitude (hour angle from Greenwich)
    const sunLon = ra - gmst;

    // Convert to Three.js world coords (same convention as sat positions: lon negated, Y up)
    const x = Math.cos(dec) * Math.cos(-sunLon);
    const y = Math.sin(dec);
    const z = Math.cos(dec) * Math.sin(-sunLon);

    return _sunDirOut.set(x, y, z).normalize();
}
const _sunDirOut = new THREE.Vector3();

function computeSunDirectionECI(date) {
    const JD = date.getTime() / 86400000 + 2440587.5;
    const n = JD - 2451545.0;
    const L = (280.460 + 0.9856474 * n) % 360;
    const g = ((357.528 + 0.9856003 * n) % 360) * DEG2RAD;
    const lambda = (L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2 * g)) * DEG2RAD;
    const epsilon = 23.439 * DEG2RAD;
    const ra = Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
    const dec = Math.asin(Math.sin(epsilon) * Math.sin(lambda));
    return _sunDirEciOut.set(
        Math.cos(dec) * Math.cos(ra),
        Math.sin(dec),
        -Math.cos(dec) * Math.sin(ra)
    ).normalize();
}
const _sunDirEciOut = new THREE.Vector3();

// ============================================================
// EARTH DAY/NIGHT SHADER MATERIAL
// ============================================================
function buildEarthShaderMaterial(dayTex, nightTex) {
    return new THREE.ShaderMaterial({
        uniforms: {
            dayMap: { value: dayTex },
            nightMap: { value: nightTex },
            sunDirection: { value: new THREE.Vector3(1, 0, 0) },
            sunEnabled: { value: true },
        },
        vertexShader: `
            varying vec2 vUv;
            varying vec3 vWorldNormal;
            void main() {
                vUv = uv;
                vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D dayMap;
            uniform sampler2D nightMap;
            uniform vec3 sunDirection;
            uniform bool sunEnabled;
            varying vec2 vUv;
            varying vec3 vWorldNormal;

            void main() {
                vec4 dayColor = texture2D(dayMap, vUv);
                vec4 nightColor = texture2D(nightMap, vUv);

                if (!sunEnabled) {
                    // Flat-lit day texture, no night lights
                    gl_FragColor = vec4(dayColor.rgb * 0.85, 1.0);
                    return;
                }

                // NdotL > 0 = facing sun = daytime
                float NdotL = dot(vWorldNormal, sunDirection);
                // dayBlend: 0 on night side, 1 on day side
                float dayBlend = smoothstep(-0.02, 0.08, NdotL);

                // Day: well-lit blue-marble (high ambient so always brighter than night)
                vec3 day = dayColor.rgb * (0.8 + 0.6 * max(NdotL, 0.0));

                // Night: very dim base + city lights only
                vec3 night = dayColor.rgb * 0.06 + nightColor.rgb * 1.5;

                gl_FragColor = vec4(mix(night, day, dayBlend), 1.0);
            }
        `,
    });
}

// ============================================================
// CREATE EARTH
// ============================================================
function createEarth() {
    earthGroup = new THREE.Group();
    scene.add(earthGroup);

    const textureLoader = new THREE.TextureLoader();

    // Earth sphere
    const earthGeo = new THREE.SphereGeometry(EARTH_RADIUS, 96, 64);

    // Create procedural fallback texture
    const fallbackMat = new THREE.MeshPhongMaterial({
        color: 0x0a1628,
        emissive: 0x040810,
        shininess: 15,
    });

    earthMesh = new THREE.Mesh(earthGeo, fallbackMat);
    earthGroup.add(earthMesh);

    // Load day + night textures in parallel
    const dayUrl = 'https://unpkg.com/three-globe@2.31.1/example/img/earth-blue-marble.jpg';
    const nightUrl = 'https://unpkg.com/three-globe@2.31.1/example/img/earth-night.jpg';
    let dayTex = null, nightTex = null;

    function tryBuildMaterial() {
        if (!dayTex || !nightTex) return;
        earthDayNightMat = buildEarthShaderMaterial(dayTex, nightTex);
        // Set initial sun direction
        const sunDir = computeSunDirection(simTime);
        earthDayNightMat.uniforms.sunDirection.value.copy(sunDir);
        earthDayNightMat.uniforms.sunEnabled.value = sunEnabled;
        earthMesh.material = earthDayNightMat;
    }

    textureLoader.load(dayUrl, (tex) => { dayTex = tex; tryBuildMaterial(); },
        undefined, () => console.warn('Failed to load day earth texture'));
    textureLoader.load(nightUrl, (tex) => { nightTex = tex; tryBuildMaterial(); },
        undefined, () => console.warn('Failed to load night earth texture'));

    // Atmosphere glow (back-side shader)
    const atmosGeo = new THREE.SphereGeometry(EARTH_RADIUS * 1.025, 64, 64);
    const atmosMat = new THREE.ShaderMaterial({
        uniforms: {
            sunDirection: { value: new THREE.Vector3(1, 0, 0) },
            sunEnabled: { value: true },
        },
        vertexShader: `
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 sunDirection;
            uniform bool sunEnabled;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            void main() {
                float intensity = pow(0.72 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.5);
                vec3 color = mix(vec3(0.1, 0.4, 0.8), vec3(0.2, 0.7, 1.0), intensity);
                float alpha = intensity * 0.65;
                if (sunEnabled) {
                    float atmosBoost = smoothstep(-0.3, 0.5, dot(normalize(vWorldPos), sunDirection));
                    alpha *= mix(0.25, 1.0, atmosBoost);
                }
                gl_FragColor = vec4(color, alpha);
            }
        `,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide,
        transparent: true,
        depthWrite: false,
    });
    atmosphereMesh = new THREE.Mesh(atmosGeo, atmosMat);
    earthGroup.add(atmosphereMesh);

    // Subtle lat/lon grid
    const gridMat = new THREE.LineBasicMaterial({ color: 0x1a3050, transparent: true, opacity: 0.2 });
    for (let lat = -60; lat <= 60; lat += 30) {
        const pts = [];
        const r = EARTH_RADIUS * 1.001;
        const phi = (90 - lat) * DEG2RAD;
        for (let lon = 0; lon <= 360; lon += 2) {
            const theta = lon * DEG2RAD;
            pts.push(new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            ));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        earthGroup.add(new THREE.Line(geo, gridMat));
    }
    for (let lon = 0; lon < 360; lon += 30) {
        const pts = [];
        const r = EARTH_RADIUS * 1.001;
        const theta = lon * DEG2RAD;
        for (let lat = -90; lat <= 90; lat += 2) {
            const phi = (90 - lat) * DEG2RAD;
            pts.push(new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            ));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        earthGroup.add(new THREE.Line(geo, gridMat));
    }
}

// ============================================================
// CREATE STARS
// ============================================================
function createStars() {
    const starsGeo = new THREE.BufferGeometry();
    const count = 6000;
    const positions = new Float32Array(count * 3);
    const sizes = new Float32Array(count);
    for (let i = 0; i < count; i++) {
        const r = 80 + Math.random() * 120;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);
        sizes[i] = 0.5 + Math.random() * 1.5;
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    starsGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const starsMat = new THREE.PointsMaterial({
        color: 0xccddff,
        size: 0.12,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true,
    });
    starField = new THREE.Points(starsGeo, starsMat);
    scene.add(starField);
}

// ============================================================
// SUN VISUAL (glowing sphere visible when zoomed out)
// ============================================================
function createSunVisual() {
    const sunGroup = new THREE.Group();

    // Core sphere
    const coreGeo = new THREE.SphereGeometry(2.5, 32, 32);
    const coreMat = new THREE.MeshBasicMaterial({ color: 0xffee88 });
    const core = new THREE.Mesh(coreGeo, coreMat);
    sunGroup.add(core);

    // Glow sprite
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(64, 64, 8, 64, 64, 64);
    gradient.addColorStop(0, 'rgba(255, 238, 136, 0.9)');
    gradient.addColorStop(0.3, 'rgba(255, 200, 80, 0.4)');
    gradient.addColorStop(0.7, 'rgba(255, 160, 40, 0.1)');
    gradient.addColorStop(1, 'rgba(255, 120, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);
    const glowTex = new THREE.CanvasTexture(canvas);
    const glowMat = new THREE.SpriteMaterial({
        map: glowTex,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
    });
    const glow = new THREE.Sprite(glowMat);
    glow.scale.set(18, 18, 1);
    sunGroup.add(glow);

    // Position far along sun direction
    const sunDir = computeSunDirection(simTime);
    sunGroup.position.copy(sunDir.multiplyScalar(150));

    scene.add(sunGroup);
    sunMesh = sunGroup;
}

// ============================================================
// MOON DIRECTION (simplified lunar ephemeris)
// ============================================================
function computeMoonDirection(date) {
    const JD = date.getTime() / 86400000 + 2440587.5;
    const T = (JD - 2451545.0) / 36525.0; // Julian centuries since J2000

    // Mean elements (degrees)
    const Lm = (218.316 + 481267.8813 * T) % 360;  // mean longitude
    const Mm = (134.963 + 477198.8676 * T) % 360;   // mean anomaly
    const F  = (93.272 + 483202.0175 * T) % 360;    // mean distance from ascending node

    const LmR = Lm * DEG2RAD, MmR = Mm * DEG2RAD, FR = F * DEG2RAD;

    // Ecliptic longitude and latitude (degrees, simplified)
    const lon = Lm + 6.289 * Math.sin(MmR);
    const lat = 5.128 * Math.sin(FR);
    const lonR = lon * DEG2RAD, latR = lat * DEG2RAD;

    // Obliquity
    const epsilon = 23.439 * DEG2RAD;

    // Ecliptic to equatorial
    const sinLon = Math.sin(lonR), cosLon = Math.cos(lonR);
    const sinLat = Math.sin(latR), cosLat = Math.cos(latR);
    const ra = Math.atan2(
        sinLon * Math.cos(epsilon) * cosLat - sinLat * Math.sin(epsilon),
        cosLon * cosLat
    );
    const dec = Math.asin(sinLat * Math.cos(epsilon) + cosLat * Math.sin(epsilon) * sinLon);

    const gmst = satellite.gstime(date);
    const moonLon = ra - gmst;

    const x = Math.cos(dec) * Math.cos(-moonLon);
    const y = Math.sin(dec);
    const z = Math.cos(dec) * Math.sin(-moonLon);

    return _moonDirOut.set(x, y, z).normalize();
}
const _moonDirOut = new THREE.Vector3();

function computeMoonDirectionECI(date) {
    const JD = date.getTime() / 86400000 + 2440587.5;
    const T = (JD - 2451545.0) / 36525.0;
    const Lm = (218.316 + 481267.8813 * T) % 360;
    const Mm = (134.963 + 477198.8676 * T) % 360;
    const F  = (93.272 + 483202.0175 * T) % 360;
    const LmR = Lm * DEG2RAD, MmR = Mm * DEG2RAD, FR = F * DEG2RAD;
    const lon = Lm + 6.289 * Math.sin(MmR);
    const lat = 5.128 * Math.sin(FR);
    const lonR = lon * DEG2RAD, latR = lat * DEG2RAD;
    const epsilon = 23.439 * DEG2RAD;
    const sinLon = Math.sin(lonR), cosLon = Math.cos(lonR);
    const sinLat = Math.sin(latR), cosLat = Math.cos(latR);
    const ra = Math.atan2(
        sinLon * Math.cos(epsilon) * cosLat - sinLat * Math.sin(epsilon),
        cosLon * cosLat
    );
    const dec = Math.asin(sinLat * Math.cos(epsilon) + cosLat * Math.sin(epsilon) * sinLon);
    return _moonDirEciOut.set(
        Math.cos(dec) * Math.cos(ra),
        Math.sin(dec),
        -Math.cos(dec) * Math.sin(ra)
    ).normalize();
}
const _moonDirEciOut = new THREE.Vector3();

// ============================================================
// MOON VISUAL
// ============================================================
function createMoonVisual() {
    const moonGroup = new THREE.Group();

    // Moon sphere (grey)
    const moonGeo = new THREE.SphereGeometry(1.35, 32, 32);
    const moonMat = new THREE.MeshBasicMaterial({ color: 0xcccccc });
    const moonCore = new THREE.Mesh(moonGeo, moonMat);
    moonGroup.add(moonCore);

    // Subtle glow
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(32, 32, 6, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(200, 210, 220, 0.5)');
    gradient.addColorStop(0.5, 'rgba(180, 190, 200, 0.15)');
    gradient.addColorStop(1, 'rgba(160, 170, 180, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    const glowTex = new THREE.CanvasTexture(canvas);
    const glowMat = new THREE.SpriteMaterial({
        map: glowTex,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
    });
    const glow = new THREE.Sprite(glowMat);
    glow.scale.set(6, 6, 1);
    moonGroup.add(glow);

    const moonDir = computeMoonDirection(simTime);
    moonGroup.position.copy(moonDir.multiplyScalar(60));

    scene.add(moonGroup);
    moonMesh = moonGroup;
}

// ============================================================
// SATELLITE DATA
// ============================================================
async function loadTLEData() {
    $loadingStatus.textContent = 'Fetching TLE data from CelesTrak...';

    let tleText;
    const $source = document.getElementById('stat-source');
    try {
        const resp = await fetch(TLE_URL);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        tleText = await resp.text();
        $source.textContent = 'Primary';
        $source.className = 'stat-value data-source-value source-primary';
        activeDataSource = 'primary';
    } catch (e) {
        console.warn('Direct fetch failed, trying CORS proxies...', e);
        $loadingStatus.textContent = 'Trying alternate data source...';
        const proxies = [
            'https://corsproxy.io/?' + encodeURIComponent(TLE_URL),
            'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(TLE_URL),
        ];
        let proxyOk = false;
        for (const proxyUrl of proxies) {
            try {
                const resp = await fetch(proxyUrl);
                if (!resp.ok) throw new Error(`Proxy HTTP ${resp.status}`);
                tleText = await resp.text();
                proxyOk = true;
                $source.textContent = 'Secondary';
                $source.className = 'stat-value data-source-value source-secondary';
                activeDataSource = 'secondary';
                break;
            } catch (pe) {
                console.warn('Proxy failed:', proxyUrl, pe);
            }
        }
        if (!proxyOk) {
            console.error('All fetches failed');
            $loadingStatus.textContent = 'Failed to load satellite data. Please try again later.';
            return;
        }
    }

    $loadingStatus.textContent = 'Parsing orbital elements...';
    parseTLEData(tleText);
}

function parseTLEData(text) {
    const lines = text.trim().split('\n').map(l => l.trim()).filter(l => l.length > 0);
    satellites = [];

    for (let i = 0; i < lines.length - 2; i++) {
        // TLE format: name line, then line1 (starts with 1), then line2 (starts with 2)
        if (lines[i + 1]?.[0] === '1' && lines[i + 2]?.[0] === '2') {
            const name = lines[i];
            const line1 = lines[i + 1];
            const line2 = lines[i + 2];
            try {
                const satrec = satellite.twoline2satrec(line1, line2);
                if (satrec.error === 0) {
                    const inclination = satrec.inclo * RAD2DEG;
                    const eccentricity = satrec.ecco;
                    const meanMotion = satrec.no * (1440 / (2 * Math.PI)); // rev/day
                    const period = 1440 / meanMotion; // minutes

                    satellites.push({
                        name,
                        satrec,
                        noradId: satrec.satnum,
                        inclination,
                        eccentricity,
                        period,
                        // Updated each frame:
                        lat: 0, lon: 0, alt: 0,
                        vx: 0, vy: 0, vz: 0,
                        x: 0, y: 0, z: 0,
                    });
                }
            } catch (e) { /* skip bad TLEs */ }
            i += 2;
        }
    }

    console.log(`Parsed ${satellites.length} satellites`);
    $loadingStatus.textContent = `Loaded ${satellites.length} satellites. Building visualization...`;

    // Sort by OneWeb number (e.g. ONEWEB-0123 → 123)
    satellites.sort((a, b) => {
        const na = parseInt((a.name.match(/(\d+)/) || ['0','0'])[1], 10);
        const nb = parseInt((b.name.match(/(\d+)/) || ['0','0'])[1], 10);
        return na - nb;
    });

    window.satellites = satellites;
    classifyPlanes();
    createSatellitePoints();
    buildSatList();
    updateStats();
    restoreAlarmsFromStorage();
    updateBuiltinCatalogCounts();
}

// Satellites excluded from plane assignment (e.g. deorbiting, drifting)
const PLANE_EXCLUDE = ['0013', '0050', '0618'];

function classifyPlanes() {
    // Only nominal sats: inclination ~87.5-88.5 deg, mean motion ~13.1-13.3 rev/day
    const nominal = [];
    for (const sat of satellites) {
        sat.excluded = PLANE_EXCLUDE.some(id => sat.name.includes(id));
        const mm = sat.satrec.no * (1440 / (2 * Math.PI));
        if (!sat.excluded && sat.inclination >= 87.5 && sat.inclination <= 88.5 && mm >= 13.1 && mm <= 13.3) {
            const raan = (sat.satrec.nodeo * RAD2DEG % 360 + 360) % 360;
            nominal.push({ sat, raan });
        } else {
            sat.plane = 0;
        }
    }

    if (nominal.length === 0) return;

    // Brute-force best offset for 12 bins at 15 deg spacing (Walker-Star, 180 deg span)
    const SPACING = 15;
    let bestOffset = 0, bestError = Infinity;
    for (let off = 0; off < SPACING; off += 0.5) {
        let err = 0;
        for (const { raan } of nominal) {
            const binCenter = Math.round((raan - off) / SPACING) * SPACING + off;
            let d = raan - binCenter;
            if (d > 180) d -= 360;
            if (d < -180) d += 360;
            err += d * d;
        }
        if (err < bestError) { bestError = err; bestOffset = off; }
    }

    // Assign to bins, compute mean RAAN per bin
    const bins = new Map(); // binKey -> { sats: [], raanSum, count }
    for (const entry of nominal) {
        const binKey = Math.round((entry.raan - bestOffset) / SPACING);
        if (!bins.has(binKey)) bins.set(binKey, { sats: [], raanSum: 0, count: 0 });
        const b = bins.get(binKey);
        b.sats.push(entry.sat);
        b.raanSum += entry.raan;
        b.count++;
    }

    // Sort bins by mean RAAN
    const sorted = [...bins.values()].sort((a, b) => (a.raanSum / a.count) - (b.raanSum / b.count));

    // Reference satellites for known plane assignments
    const PLANE_REFS = { '0102': 9, '0027': 10, '0015': 11, '0017': 12 };

    // Find which RAAN-sorted bin each reference satellite is in
    const knownBins = new Map(); // binIndex -> planeNum
    for (let i = 0; i < sorted.length; i++) {
        for (const sat of sorted[i].sats) {
            for (const [scid, planeNum] of Object.entries(PLANE_REFS)) {
                if (sat.name.includes(scid)) {
                    knownBins.set(i, planeNum);
                }
            }
        }
    }

    // Assign remaining plane numbers (1-8) in RAAN order to unmatched bins
    const usedPlaneNums = new Set(knownBins.values());
    const availableNums = [];
    for (let n = 1; n <= 12; n++) {
        if (!usedPlaneNums.has(n)) availableNums.push(n);
    }
    let availIdx = 0;
    const planeMap = new Map(); // binIndex -> planeNum
    for (let i = 0; i < sorted.length; i++) {
        if (knownBins.has(i)) {
            planeMap.set(i, knownBins.get(i));
        } else {
            planeMap.set(i, availableNums[availIdx++]);
        }
    }

    // Apply plane numbers
    sorted.forEach((bin, i) => {
        const planeNum = planeMap.get(i) || (i + 1);
        for (const sat of bin.sats) sat.plane = planeNum;
    });

    // Any nominal sat not in a bin (shouldn't happen) gets plane 0
    for (const { sat } of nominal) {
        if (sat.plane === undefined) sat.plane = 0;
    }

    console.log(`Classified ${nominal.length} nominal sats into ${sorted.length} planes`);
}

// ============================================================
// GEO SATELLITE DATA + RENDERING
// ============================================================
async function loadGeoTLEData() {
    const url = GEO_TLE_URL;
    let tleText;
    try {
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        tleText = await resp.text();
    } catch (e) {
        console.warn('GEO direct fetch failed, trying CORS proxies...', e);
        const proxies = [
            'https://corsproxy.io/?' + encodeURIComponent(url),
            'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(url),
        ];
        let proxyOk = false;
        for (const proxyUrl of proxies) {
            try {
                const resp = await fetch(proxyUrl);
                if (!resp.ok) throw new Error(`Proxy HTTP ${resp.status}`);
                tleText = await resp.text();
                proxyOk = true;
                break;
            } catch (pe) {
                console.warn('GEO proxy failed:', proxyUrl, pe);
            }
        }
        if (!proxyOk) {
            console.warn('All GEO TLE fetches failed');
            return;
        }
    }

    parseGeoTLEData(tleText);
}

function parseGeoTLEData(text) {
    const lines = text.trim().split('\n').map(l => l.trim()).filter(l => l.length > 0);
    geoSatellites = [];

    for (let i = 0; i < lines.length - 2; i++) {
        if (lines[i + 1]?.[0] === '1' && lines[i + 2]?.[0] === '2') {
            const name = lines[i];
            const line1 = lines[i + 1];
            const line2 = lines[i + 2];
            try {
                const satrec = satellite.twoline2satrec(line1, line2);
                if (satrec.error === 0) {
                    const inclination = satrec.inclo * RAD2DEG;
                    const meanMotion = satrec.no * (1440 / (2 * Math.PI)); // rev/day
                    // Filter: station-kept GEO sats only
                    if (inclination < 0.5 && meanMotion >= 0.99 && meanMotion <= 1.01) {
                        geoSatellites.push({
                            name,
                            noradId: satrec.satnum,
                            satrec,
                            lat: 0, lon: 0, alt: 0,
                            x: 0, y: 0, z: 0,
                            _el: null, _screenX: 0, _screenY: 0,
                        });
                    }
                }
            } catch (e) { /* skip bad TLEs */ }
            i += 2;
        }
    }

    // Sort GEO satellites by name
    geoSatellites.sort((a, b) => a.name.localeCompare(b.name));

    console.log(`Parsed ${geoSatellites.length} GEO satellites (Eutelsat)`);
    createGeoPoints();
    createGeoOrbitRing();
    createGeoLabels();
    appendGeoListItems();
    updateBuiltinCatalogCounts();
}

function createGeoPoints() {
    const count = geoSatellites.length;
    if (count === 0) return;

    geoGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    geoGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geoGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Reuse point texture pattern (HD 128x128)
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.15, 'rgba(255,255,255,0.95)');
    gradient.addColorStop(0.35, 'rgba(255,255,255,0.5)');
    gradient.addColorStop(0.6, 'rgba(255,255,255,0.12)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);
    const pointTexture = new THREE.CanvasTexture(canvas);

    const mat = new THREE.PointsMaterial({
        size: 0.4,
        map: pointTexture,
        vertexColors: true,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
    });

    geoPointCloud = new THREE.Points(geoGeometry, mat);
    geoPointCloud.renderOrder = 1;
    geoPointCloud.visible = false; // off by default
    scene.add(geoPointCloud);

    // Gold/amber colour
    const geoColor = new THREE.Color(0xffc107);
    for (let i = 0; i < count; i++) {
        colors[i * 3] = geoColor.r;
        colors[i * 3 + 1] = geoColor.g;
        colors[i * 3 + 2] = geoColor.b;
    }
    geoGeometry.getAttribute('color').needsUpdate = true;

    // Initial position update
    updateGeoPositions(true);
}

function createGeoOrbitRing() {
    // Dashed ring at GEO altitude in equatorial plane
    const geoRadius = EARTH_RADIUS + 35786 * SAT_SCALE;
    const segments = 128;
    const pts = [];
    for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        pts.push(new THREE.Vector3(
            geoRadius * Math.cos(theta),
            0,
            geoRadius * Math.sin(theta)
        ));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineDashedMaterial({
        color: 0xffc107,
        transparent: true,
        opacity: 0.2,
        dashSize: 1.5,
        gapSize: 0.8,
        depthWrite: false,
    });
    geoOrbitRing = new THREE.Line(geo, mat);
    geoOrbitRing.computeLineDistances();
    geoOrbitRing.visible = false;
    scene.add(geoOrbitRing);
}

function createGeoLabels() {
    for (let gi = 0; gi < geoSatellites.length; gi++) {
        const gs = geoSatellites[gi];
        const el = document.createElement('div');
        el.className = 'geo-label gs-hidden';
        // Format: "EUTELSAT HOTBIRD 13F" → "HOTBIRD 13F · 13°E"
        let displayName = gs.name.replace(/^EUTELSAT\s*/i, '').trim();
        if (!displayName) displayName = gs.name;
        // Add orbital slot from longitude
        const lon = gs.lon;
        if (lon !== 0 || gs.alt > 30000) {
            const absLon = Math.abs(lon);
            const dir = lon >= 0 ? 'E' : 'W';
            displayName += ` · ${absLon.toFixed(1)}°${dir}`;
        }
        el.textContent = displayName;
        // Click label to select this GEO satellite
        const idx = gi;
        el.addEventListener('click', () => selectGeoSatellite(idx));
        document.body.appendChild(el);
        gs._el = el;
    }
}

// GEO satellite info lookup: pattern → { services[], desc }
const GEO_SAT_INFO = {
    'HOTBIRD 13F':      { services: ['Broadcast', 'Video'], desc: 'High-power DTH broadcasting satellite at 13°E, delivering ~900 TV channels to 160M+ homes across Europe, North Africa and the Middle East.' },
    'HOTBIRD 13G':      { services: ['Broadcast', 'Video'], desc: 'Co-located with HOTBIRD 13F at 13°E, together forming the premium European video neighbourhood.' },
    'KONNECT VHTS':     { services: ['Broadband', 'Mobility', 'Government'], desc: 'High-throughput Ka-band satellite (500 Gbps) at 2.7°E with the most powerful on-board digital processor in orbit. Serves European fixed broadband and in-flight connectivity.' },
    'KONNECT':          { services: ['Broadband', 'Connectivity'], desc: 'Ka-band broadband satellite at 7°E providing high-speed internet access across Europe and Africa.' },
    '10B':              { services: ['Mobility', 'Broadband', 'Connectivity', 'Government'], desc: 'Multi-beam satellite at 10°E providing in-flight and maritime connectivity across Europe, the Middle East, and Atlantic corridors.' },
    '3B':               { services: ['Mobility', 'Connectivity', 'Government', 'Broadcast'], desc: 'Ku/Ka/C-band satellite at 3°E serving mobility, government and broadcast customers across Europe, Africa and the Middle East.' },
    '5 WEST B':         { services: ['Connectivity', 'Broadcast'], desc: 'Satellite at 5°W providing broadcast and data services for the French market and North Africa.' },
    '7 WEST A':         { services: ['Broadcast', 'Video'], desc: 'Broadcasting satellite at 7°W serving the Nilesat/Eutelsat video neighbourhood for the Middle East and North Africa.' },
    '8 WEST B':         { services: ['Broadcast', 'Connectivity', 'Government'], desc: 'Satellite at 8°W providing broadcast services for the MENA region and government connectivity.' },
    '7B':               { services: ['Broadcast', 'Connectivity'], desc: 'Ku-band satellite at 7°E serving broadcast and telecom markets across Europe, Africa and the Middle East.' },
    '7C':               { services: ['Broadcast', 'Video'], desc: 'Broadcasting satellite at 7°E expanding capacity at this orbital position for Africa, Europe and Turkey.' },
    '21B':              { services: ['Broadband', 'Connectivity', 'Government', 'Broadcast'], desc: 'Multi-purpose satellite at 21°E offering broadband, broadcast and government services across Europe and sub-Saharan Africa.' },
    '28E':              { services: ['Broadcast', 'Video'], desc: 'Part of the 28°E cluster, serving Sky UK and Irish broadcasting neighbourhoods.' },
    '28F':              { services: ['Broadcast', 'Video'], desc: 'Part of the 28°E cluster, providing additional broadcast capacity for UK and Ireland.' },
    '28G':              { services: ['Broadcast', 'Video'], desc: 'Part of the 28°E cluster, serving direct-to-home broadcasting for the UK market.' },
    '33E':              { services: ['Broadcast', 'Connectivity', 'Broadband'], desc: 'Satellite at 33°E providing broadcast and connectivity services across sub-Saharan Africa.' },
    '36C':              { services: ['Connectivity', 'Broadcast', 'Broadband'], desc: 'Satellite at 36°E serving broadcast and broadband connectivity for sub-Saharan Africa and Indian Ocean region.' },
    '36D':              { services: ['Connectivity', 'Broadcast'], desc: 'Co-located at 36°E, expanding capacity for Russian and African broadcast and connectivity markets.' },
    '70B':              { services: ['Mobility', 'Broadband', 'Connectivity', 'Government'], desc: 'Satellite at 70°E providing broadband, mobility and government services across Central Asia, the Indian subcontinent and Middle East.' },
    '172B':             { services: ['Mobility', 'Connectivity', 'Government'], desc: 'Satellite at 172°E serving transpacific mobility and government connectivity across Asia-Pacific.' },
    '174A':             { services: ['Mobility', 'Connectivity', 'Government'], desc: 'Satellite at 174°E providing government and mobility services in the Asia-Pacific region.' },
    '65 WEST A':        { services: ['Broadband', 'Connectivity', 'Government', 'Broadcast'], desc: 'Multi-band satellite at 65°W providing broadband and broadcast services across Brazil and Latin America.' },
    '115 WEST B':       { services: ['Mobility', 'Broadband', 'Connectivity', 'Government'], desc: 'Satellite at 115°W serving broadband, mobility and government connectivity across the Americas.' },
    '117 WEST A':       { services: ['Connectivity', 'Government', 'Broadcast', 'Broadband'], desc: 'Satellite at 117°W providing broadcast and connectivity services for the Americas.' },
    '117 WEST B':       { services: ['Connectivity', 'Government', 'Broadcast'], desc: 'Co-located at 117°W, expanding capacity for Americas broadcast and government services.' },
    '139 WEST A':       { services: ['Mobility'], desc: 'Satellite at 139°W primarily serving maritime and aeronautical mobility across the Pacific.' },
};

const _defaultGeoInfo = { services: ['Communications'], desc: 'Eutelsat geostationary communications satellite.' };

let selectedGeoIndex = -1;
const $geoPanel = document.getElementById('geo-panel');
const $geoPanelName = document.getElementById('geo-panel-name');
const $geoPanelSlot = document.getElementById('geo-panel-slot');
const $geoPanelServices = document.getElementById('geo-panel-services');
const $geoPanelDesc = document.getElementById('geo-panel-desc');
const $geoPanelLon = document.getElementById('geo-panel-lon');
const $geoPanelAlt = document.getElementById('geo-panel-alt');
const $geoPanelNorad = document.getElementById('geo-panel-norad');

function getGeoSatInfo(name) {
    const upper = name.toUpperCase();
    for (const [key, info] of Object.entries(GEO_SAT_INFO)) {
        if (upper.includes(key.toUpperCase())) return info;
    }
    return _defaultGeoInfo;
}

const _geoGoldColor = new THREE.Color(0xffc107);
let _geoHighlightSprite = null;

function _setGeoDotColor(idx, r, g, b) {
    if (!geoGeometry) return;
    const colAttr = geoGeometry.getAttribute('color');
    colAttr.setXYZ(idx, r, g, b);
    colAttr.needsUpdate = true;
}

function _showGeoHighlightSprite(gs) {
    if (!_geoHighlightSprite) {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.15, 'rgba(255,255,255,0.9)');
        grad.addColorStop(0.4, 'rgba(255,255,255,0.3)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 64, 64);
        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
        _geoHighlightSprite = new THREE.Sprite(mat);
        _geoHighlightSprite.renderOrder = 2;
        scene.add(_geoHighlightSprite);
    }
    _geoHighlightSprite.position.set(gs.x, gs.y, gs.z);
    _geoHighlightSprite.scale.set(1.2, 1.2, 1);
    _geoHighlightSprite.visible = true;
}

function _clearGeoSelection() {
    // Reset previous dot colour
    if (selectedGeoIndex >= 0) {
        _setGeoDotColor(selectedGeoIndex, _geoGoldColor.r, _geoGoldColor.g, _geoGoldColor.b);
        const gs = geoSatellites[selectedGeoIndex];
        if (gs && gs._el) gs._el.classList.remove('geo-selected');
    }
    // Hide sprite
    if (_geoHighlightSprite) _geoHighlightSprite.visible = false;
    // Deselect list item
    const oldGeoItem = $satList.querySelector('.geo-sat-item.selected');
    if (oldGeoItem) oldGeoItem.classList.remove('selected');
}

function selectGeoSatellite(geoIdx) {
    // If clicking the same GEO sat, toggle off
    if (geoIdx === selectedGeoIndex && !$geoPanel.classList.contains('hidden')) {
        closeGeoPanel();
        return;
    }

    // Clear catalog selection
    clearCatalogSelection();
    $detailPanel.classList.add('hidden');

    // Close LEO detail panel and stop tracking if active
    if (trackingIndex >= 0) stopTracking();
    if (selectedIndex >= 0) {
        $detailPanel.classList.add('hidden');
        clearTtcPasses();
        const oldItem = $satList.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        resetSatColor(selectedIndex);
        selectedIndex = -1;
        clearOrbitPath();
        clearCoverageFootprint();
    }

    // Deselect previous GEO selection visuals
    _clearGeoSelection();

    selectedGeoIndex = geoIdx;
    const gs = geoSatellites[geoIdx];
    if (!gs) return;

    // Highlight label
    if (gs._el) gs._el.classList.add('geo-selected');

    // Highlight dot: set colour to white + show enlarged sprite
    _setGeoDotColor(geoIdx, 1, 1, 1);
    _showGeoHighlightSprite(gs);

    // Highlight in list
    const newGeoItem = $satList.querySelector(`.geo-sat-item[data-geo-index="${geoIdx}"]`);
    if (newGeoItem) {
        let parentFolder = newGeoItem.closest('.folder.collapsed');
        while (parentFolder) {
            parentFolder.classList.remove('collapsed');
            parentFolder = parentFolder.parentElement && parentFolder.parentElement.closest('.folder.collapsed');
        }
        newGeoItem.classList.add('selected');
    }

    const displayName = gs.name.replace(/^EUTELSAT\s*/i, '').trim() || gs.name;
    const info = getGeoSatInfo(gs.name);
    const lon = gs.lon;
    const absLon = Math.abs(lon).toFixed(1);
    const dir = lon >= 0 ? 'E' : 'W';

    $geoPanelName.textContent = displayName;
    $geoPanelSlot.textContent = absLon + '\u00B0' + dir + ' \u2022 Geostationary';
    $geoPanelServices.innerHTML = info.services.map(s =>
        '<span class="geo-service-tag">' + s + '</span>'
    ).join('');
    $geoPanelDesc.textContent = info.desc;
    $geoPanelLon.textContent = absLon + '\u00B0' + dir;
    $geoPanelAlt.textContent = Math.round(gs.alt).toLocaleString() + ' km';
    $geoPanelNorad.textContent = 'NORAD ' + gs.noradId;

    $geoPanel.classList.remove('hidden');
}

function closeGeoPanel() {
    $geoPanel.classList.add('hidden');
    _clearGeoSelection();
    selectedGeoIndex = -1;
}

document.getElementById('geo-panel-close').addEventListener('click', closeGeoPanel);

function isGeoSatVisible(idx) {
    const gs = geoSatellites[idx];
    _satPos.set(gs.x, gs.y, gs.z);
    _camToStation.copy(_satPos).sub(camera.position).normalize();
    raycaster.set(camera.position, _camToStation);
    const hit = raycaster.ray.intersectSphere(_earthSphere, _intersectPt);
    if (!hit) return true;
    const distToSat = camera.position.distanceTo(_satPos);
    return camera.position.distanceTo(_intersectPt) >= distToSat * 0.98;
}

function ensureGeoVisible() {
    if (geoSatsVisible) return;
    geoSatsVisible = true;
    if (geoPointCloud) geoPointCloud.visible = true;
    if (geoOrbitRing) geoOrbitRing.visible = true;
    for (const gs of geoSatellites) {
        if (gs._el) gs._el.classList.remove('gs-hidden');
    }
    updateGeoPositions(true);
}

function focusGeoSatellite(geoIdx) {
    if (geoIdx < 0 || geoIdx >= geoSatellites.length) return;
    ensureGeoVisible();
    // Make sure positions are up to date
    updateGeoPositions(true);
    const gs = geoSatellites[geoIdx];
    // Open the info panel
    selectGeoSatellite(geoIdx);
    // Animate camera to face this GEO satellite with elevated view
    const dir = new THREE.Vector3(gs.x, gs.y, gs.z).normalize();
    const endLon = Math.atan2(dir.z, dir.x);
    const endLat = Math.max(Math.asin(dir.y), 0.35);
    const endDist = Math.max(camera.position.length(), 70);
    animateCameraToVizView(endLat, endLon, endDist);
}

function updateGeoPositions(force) {
    if (!geoSatellites.length || !geoGeometry) return;
    if (!force && !geoSatsVisible) return;

    const posAttr = geoGeometry.getAttribute('position');
    const gmst = satellite.gstime(simTime);

    for (let i = 0; i < geoSatellites.length; i++) {
        const gs = geoSatellites[i];
        const posVel = satellite.propagate(gs.satrec, simTime);

        if (posVel.position && typeof posVel.position !== 'boolean') {
            const eci = posVel.position;
            const geo = satellite.eciToGeodetic(eci, gmst);
            gs.lat = satellite.degreesLat(geo.latitude);
            gs.lon = satellite.degreesLong(geo.longitude);
            gs.alt = geo.height;

            if (referenceFrame === 'eci') {
                const s = SAT_SCALE;
                gs.x = eci.x * s;
                gs.y = eci.z * s;
                gs.z = -eci.y * s;
            } else {
                geoToVec3Into(gs.lat, gs.lon, gs.alt, _geoOut);
                gs.x = _geoOut.x;
                gs.y = _geoOut.y;
                gs.z = _geoOut.z;
            }

            posAttr.setXYZ(i, gs.x, gs.y, gs.z);
        }
    }

    posAttr.needsUpdate = true;

    // Keep highlight sprite in sync with selected GEO sat
    if (_geoHighlightSprite && _geoHighlightSprite.visible && selectedGeoIndex >= 0) {
        const sel = geoSatellites[selectedGeoIndex];
        if (sel) _geoHighlightSprite.position.set(sel.x, sel.y, sel.z);
    }
}

const _geoLabelPos = new THREE.Vector3();
function updateGeoLabels() {
    if (!camera || !renderer || !geoSatsVisible) return;
    const widthHalf = window.innerWidth / 2;
    const heightHalf = window.innerHeight / 2;

    for (const gs of geoSatellites) {
        const el = gs._el;
        if (!el) continue;

        _geoLabelPos.set(gs.x, gs.y, gs.z);

        // Behind-globe check
        _camToStation.copy(_geoLabelPos).sub(camera.position).normalize();
        raycaster.set(camera.position, _camToStation);
        const hits = raycaster.ray.intersectSphere(_earthSphere, _intersectPt);
        const distToSat = camera.position.distanceTo(_geoLabelPos);
        const isBehind = hits && camera.position.distanceTo(_intersectPt) < distToSat * 0.98;
        const wasBehind = el.classList.contains('behind-globe');
        if (isBehind !== wasBehind) el.classList.toggle('behind-globe', isBehind);

        // Project to screen
        _projectedVec.copy(_geoLabelPos).project(camera);
        const x = (_projectedVec.x * widthHalf) + widthHalf;
        const y = -(_projectedVec.y * heightHalf) + heightHalf;
        const dx = x - (gs._screenX || 0), dy = y - (gs._screenY || 0);
        if (dx * dx + dy * dy > 0.25) {
            el.style.transform = `translate(${x}px, ${y}px)`;
            gs._screenX = x; gs._screenY = y;
        }
    }
}

// ============================================================
// CATALOG SATELLITE SYSTEM
// ============================================================
function _getSharedPointTexture() {
    if (_sharedPointTexture) return _sharedPointTexture;
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.15, 'rgba(255,255,255,0.95)');
    gradient.addColorStop(0.35, 'rgba(255,255,255,0.5)');
    gradient.addColorStop(0.6, 'rgba(255,255,255,0.12)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);
    _sharedPointTexture = new THREE.CanvasTexture(canvas);
    return _sharedPointTexture;
}

function buildCatalogPanel() {
    const $body = document.getElementById('catalog-body');
    $body.innerHTML = '';
    const categories = {};
    for (const g of CATALOG_GROUPS) {
        if (!categories[g.category]) categories[g.category] = [];
        categories[g.category].push(g);
    }
    for (const [cat, groups] of Object.entries(categories)) {
        const catDiv = document.createElement('div');
        catDiv.className = 'catalog-category';
        const catHeader = document.createElement('div');
        catHeader.className = 'catalog-category-header';
        catHeader.innerHTML = `<span class="catalog-category-chevron">&#9660;</span><span class="catalog-category-label">${cat}</span>`;
        catHeader.addEventListener('click', () => catDiv.classList.toggle('collapsed'));
        catDiv.appendChild(catHeader);
        const catBody = document.createElement('div');
        catBody.className = 'catalog-category-body';
        for (const g of groups) {
            const row = document.createElement('div');
            row.className = 'catalog-group-row';
            row.dataset.groupKey = g.key;
            // Mark builtin OneWeb as active (visible by default)
            if (g.builtin === 'oneweb') row.classList.add('active');
            row.innerHTML = `<div class="catalog-group-dot" style="background:${g.color}"></div><div class="catalog-group-label">${g.label}</div><div class="catalog-trail-btn${g.builtin === 'oneweb' ? ' enabled' : ''}" data-trail-key="${g.key}" title="Show orbital trails"><svg viewBox="0 0 24 24" fill="none" stroke="${g.color}" stroke-width="2"><ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(-25 12 12)"/><circle cx="18" cy="9" r="1.5" fill="${g.color}" stroke="none"/></svg></div><div class="catalog-group-count" id="cat-count-${g.key}">--</div>`;
            // Trail button click handler
            const trailBtn = row.querySelector('.catalog-trail-btn');
            trailBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!trailBtn.classList.contains('enabled')) return;
                toggleConstellationTrail(g.key);
            });
            row.addEventListener('click', () => onCatalogGroupClick(g.key));
            catBody.appendChild(row);
        }
        catDiv.appendChild(catBody);
        $body.appendChild(catDiv);
    }
}

// Update builtin catalog counts after data loads
function updateBuiltinCatalogCounts() {
    const owCount = document.getElementById('cat-count-oneweb');
    if (owCount && satellites.length) owCount.textContent = satellites.length;
    const geoCount = document.getElementById('cat-count-eutelsat-geo');
    if (geoCount && geoSatellites.length) geoCount.textContent = geoSatellites.length;
    // Sync GEO row active state with geoSatsVisible
    const geoRow = document.querySelector('.catalog-group-row[data-group-key="eutelsat-geo"]');
    if (geoRow) geoRow.classList.toggle('active', geoSatsVisible);
    // Enable trail button for GEO when loaded
    if (geoSatellites.length) {
        const geoTrailBtn = document.querySelector('.catalog-trail-btn[data-trail-key="eutelsat-geo"]');
        if (geoTrailBtn) geoTrailBtn.classList.toggle('enabled', geoSatsVisible);
    }
}

function _toggleBuiltinOneweb() {
    const isVisible = satPointCloud && satPointCloud.visible;
    const newVisible = !isVisible;
    if (satPointCloud) satPointCloud.visible = newVisible;
    // Update catalog row
    const row = document.querySelector('.catalog-group-row[data-group-key="oneweb"]');
    if (row) row.classList.toggle('active', newVisible);
    // Show/hide OneWeb sidebar folder
    if (_folderRefs.oneweb) _folderRefs.oneweb.style.display = newVisible ? '' : 'none';
    // Deselect if hiding and a OneWeb sat was selected
    if (!newVisible && selectedIndex >= 0) {
        stopTracking();
        const oldItem = $satList.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        resetSatColor(selectedIndex);
        selectedIndex = -1;
        $detailPanel.classList.add('hidden');
        clearOrbitPath();
        clearCoverageFootprint();
        clearTtcPasses();
    }
    // Also hide/show plane glow if active
    if (!newVisible && selectedPlane >= 0) {
        selectedPlane = -1;
        removePlaneGlow();
    }
    // Sync constellation trail
    const owTrail = _constellationTrails['oneweb'];
    if (owTrail && owTrail.enabled) {
        if (!newVisible) {
            if (owTrail.lineSegments) owTrail.lineSegments.visible = false;
        } else {
            if (owTrail.lineSegments) owTrail.lineSegments.visible = true;
            owTrail.dirty = true;
        }
    }
    const owTrailBtn = document.querySelector('.catalog-trail-btn[data-trail-key="oneweb"]');
    if (owTrailBtn) owTrailBtn.classList.toggle('enabled', newVisible);
}

function _toggleBuiltinGeo() {
    // Toggle GEO visibility (catalog panel only — button removed)
    geoSatsVisible = !geoSatsVisible;
    if (geoPointCloud) geoPointCloud.visible = geoSatsVisible;
    if (geoOrbitRing) geoOrbitRing.visible = geoSatsVisible;
    for (const gs of geoSatellites) {
        if (gs._el) gs._el.classList.toggle('gs-hidden', !geoSatsVisible);
    }
    if (geoSatsVisible) updateGeoPositions(true);
    // Sync catalog row
    const row = document.querySelector('.catalog-group-row[data-group-key="eutelsat-geo"]');
    if (row) row.classList.toggle('active', geoSatsVisible);
    // Show/hide GEO sidebar folder
    if (_folderRefs.geo) _folderRefs.geo.style.display = geoSatsVisible ? '' : 'none';
    // Deselect if hiding and a GEO sat was selected
    if (!geoSatsVisible && selectedGeoIndex >= 0) {
        closeGeoPanel();
    }
    // Sync constellation trail
    const geoTrail = _constellationTrails['eutelsat-geo'];
    if (geoTrail && geoTrail.enabled) {
        if (!geoSatsVisible) {
            if (geoTrail.lineSegments) geoTrail.lineSegments.visible = false;
        } else {
            if (geoTrail.lineSegments) geoTrail.lineSegments.visible = true;
            geoTrail.dirty = true;
        }
    }
    const geoTrailBtn = document.querySelector('.catalog-trail-btn[data-trail-key="eutelsat-geo"]');
    if (geoTrailBtn) geoTrailBtn.classList.toggle('enabled', geoSatsVisible);
}

function onCatalogGroupClick(key) {
    // Handle builtin groups
    const group = CATALOG_GROUPS.find(g => g.key === key);
    if (group && group.builtin === 'oneweb') {
        _toggleBuiltinOneweb();
        return;
    }
    if (group && group.builtin === 'geo') {
        _toggleBuiltinGeo();
        return;
    }

    const cs = catalogState[key];
    if (cs && cs.loaded) {
        toggleCatalogGroup(key);
    } else if (cs && cs.loading) {
        return; // already loading
    } else {
        loadCatalogGroup(key);
    }
}

async function loadCatalogGroup(key, { showOnLoad = true } = {}) {
    const group = CATALOG_GROUPS.find(g => g.key === key);
    if (!group) return;

    // Initialize state
    if (!catalogState[key]) {
        catalogState[key] = { satellites: [], visible: false, loaded: false, loading: false, tleText: null, frameCount: 0, baseColor: null };
    }
    const cs = catalogState[key];
    if (cs.loaded) { if (showOnLoad) toggleCatalogGroup(key); return; }
    if (cs.loading) return;
    cs.loading = true;

    // Show spinner in panel
    const countEl = document.getElementById('cat-count-' + key);
    if (countEl) countEl.innerHTML = '<div class="catalog-group-spinner"></div>';

    const url = 'https://celestrak.org/NORAD/elements/gp.php?GROUP=' + group.groupId + '&FORMAT=tle';
    let tleText = null;
    try {
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        tleText = await resp.text();
    } catch (e) {
        console.warn(`Catalog ${key} direct fetch failed, trying proxies...`, e);
        const proxies = [
            'https://corsproxy.io/?' + encodeURIComponent(url),
            'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(url),
        ];
        for (const proxyUrl of proxies) {
            try {
                const resp = await fetch(proxyUrl);
                if (!resp.ok) throw new Error(`Proxy HTTP ${resp.status}`);
                tleText = await resp.text();
                break;
            } catch (pe) {
                console.warn(`Catalog ${key} proxy failed:`, proxyUrl, pe);
            }
        }
    }

    if (!tleText) {
        console.error(`All fetches failed for catalog group: ${key}`);
        cs.loading = false;
        if (countEl) countEl.textContent = 'ERR';
        return;
    }

    cs.tleText = tleText;
    await parseCatalogTLE(key, tleText);
    createCatalogPoints(key);
    cs.loaded = true;
    cs.loading = false;
    cs.visible = showOnLoad;

    // Update UI
    const row = document.querySelector(`.catalog-group-row[data-group-key="${key}"]`);
    if (row) row.classList.toggle('active', showOnLoad);
    if (countEl) countEl.textContent = cs.satellites.length;

    // Add sidebar folder (hidden if preloaded)
    appendCatalogFolder(key);
    if (!showOnLoad) {
        const folder = document.querySelector(`.folder[data-folder-id="catalog-${key}"]`);
        if (folder) folder.style.display = 'none';
    }

    // Set visibility in merged buffer
    if (!showOnLoad) {
        const range = _catalogMerged.ranges[key];
        if (range && _catalogMerged.geometry) {
            const visAttr = _catalogMerged.geometry.getAttribute('aVisible');
            for (let i = 0; i < range.count; i++) visAttr.setX(range.start + i, 0.0);
            visAttr.needsUpdate = true;
        }
    }

    // Initial position update
    if (showOnLoad) updateCatalogPositions(key, true);

    // Enable trail button now that group is loaded
    const trailBtn = document.querySelector(`.catalog-trail-btn[data-trail-key="${key}"]`);
    if (trailBtn) trailBtn.classList.add('enabled');

    console.log(`Catalog ${key}: loaded ${cs.satellites.length} satellites`);
}

// Batched TLE parsing — yields to main thread every 200 sats to keep UI responsive
async function parseCatalogTLE(key, text) {
    const lines = text.trim().split('\n').map(l => l.trim()).filter(l => l.length > 0);
    const sats = [];
    const BATCH_SIZE = 200;
    const countEl = document.getElementById('cat-count-' + key);

    // First pass: identify TLE triplets (cheap, no blocking)
    const triplets = [];
    for (let i = 0; i < lines.length - 2; i++) {
        if (lines[i + 1]?.[0] === '1' && lines[i + 2]?.[0] === '2') {
            triplets.push(i);
            i += 2;
        }
    }

    // Process in batches, yielding to main thread between batches
    for (let b = 0; b < triplets.length; b += BATCH_SIZE) {
        const end = Math.min(b + BATCH_SIZE, triplets.length);
        for (let j = b; j < end; j++) {
            const i = triplets[j];
            const name = lines[i];
            const line1 = lines[i + 1];
            const line2 = lines[i + 2];
            try {
                const satrec = satellite.twoline2satrec(line1, line2);
                if (satrec.error === 0) {
                    const inclination = satrec.inclo * RAD2DEG;
                    const eccentricity = satrec.ecco;
                    const meanMotion = satrec.no * (1440 / (2 * Math.PI));
                    const period = 1440 / meanMotion;
                    sats.push({
                        name, satrec, noradId: satrec.satnum,
                        inclination, eccentricity, period,
                        groupKey: key,
                        lat: 0, lon: 0, alt: 0,
                        x: 0, y: 0, z: 0,
                        speed: 0,
                    });
                }
            } catch (e) { /* skip bad TLEs */ }
        }
        // Yield to main thread if more batches remain
        if (end < triplets.length) {
            if (countEl) countEl.textContent = `${sats.length}...`;
            await new Promise(r => setTimeout(r, 0));
        }
    }

    sats.sort((a, b) => a.name.localeCompare(b.name));
    catalogState[key].satellites = sats;
}

// Initialize the single merged catalog point cloud (called once on first group load)
function _initCatalogMergedCloud() {
    if (_catalogMerged.geometry) return;

    const cap = _catalogMerged.capacity;
    const positions = new Float32Array(cap * 3);
    const colors = new Float32Array(cap * 3);
    const sizes = new Float32Array(cap);
    const visibility = new Float32Array(cap);

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geo.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
    geo.setAttribute('aVisible', new THREE.BufferAttribute(visibility, 1));
    geo.setDrawRange(0, 0);

    const mat = new THREE.ShaderMaterial({
        uniforms: {
            map: { value: _getSharedPointTexture() },
            uScale: { value: window.innerHeight * (window.devicePixelRatio || 1) / 2.0 },
        },
        vertexShader: `
            attribute float aSize;
            attribute float aVisible;
            uniform float uScale;
            varying vec3 vColor;
            varying float vVis;
            void main() {
                vColor = color;
                vVis = aVisible;
                vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = aSize * (uScale / -mvPos.z) * aVisible;
                gl_Position = projectionMatrix * mvPos;
            }
        `,
        fragmentShader: `
            uniform sampler2D map;
            varying vec3 vColor;
            varying float vVis;
            void main() {
                if (vVis < 0.5) discard;
                vec4 texColor = texture2D(map, gl_PointCoord);
                if (texColor.a < 0.01) discard;
                gl_FragColor = vec4(vColor * texColor.rgb, texColor.a);
            }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
    });

    const cloud = new THREE.Points(geo, mat);
    cloud.renderOrder = 1;
    scene.add(cloud);

    _catalogMerged.geometry = geo;
    _catalogMerged.pointCloud = cloud;
    _catalogMerged.material = mat;
}

// Grow merged buffer when capacity is exceeded
function _growCatalogMergedBuffer(needed) {
    const newCap = Math.max(needed * 2, _catalogMerged.capacity * 2);
    const oldGeo = _catalogMerged.geometry;
    const oldPos = oldGeo.getAttribute('position').array;
    const oldCol = oldGeo.getAttribute('color').array;
    const oldSiz = oldGeo.getAttribute('aSize').array;
    const oldVis = oldGeo.getAttribute('aVisible').array;
    const used = _catalogMerged.totalUsed;

    const positions = new Float32Array(newCap * 3);
    const colors = new Float32Array(newCap * 3);
    const sizes = new Float32Array(newCap);
    const visibility = new Float32Array(newCap);

    positions.set(oldPos.subarray(0, used * 3));
    colors.set(oldCol.subarray(0, used * 3));
    sizes.set(oldSiz.subarray(0, used));
    visibility.set(oldVis.subarray(0, used));

    oldGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    oldGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    oldGeo.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
    oldGeo.setAttribute('aVisible', new THREE.BufferAttribute(visibility, 1));

    _catalogMerged.capacity = newCap;
}

// Map a merged buffer index back to { groupKey, localIndex }
function _catalogMergedIndexToGroup(mergedIdx) {
    for (const key of Object.keys(_catalogMerged.ranges)) {
        const r = _catalogMerged.ranges[key];
        if (mergedIdx >= r.start && mergedIdx < r.start + r.count) {
            return { groupKey: key, localIndex: mergedIdx - r.start };
        }
    }
    return null;
}

function createCatalogPoints(key) {
    const cs = catalogState[key];
    const group = CATALOG_GROUPS.find(g => g.key === key);
    const count = cs.satellites.length;
    if (count === 0) return;

    _initCatalogMergedCloud();

    // Grow buffer if needed
    const needed = _catalogMerged.totalUsed + count;
    if (needed > _catalogMerged.capacity) {
        _growCatalogMergedBuffer(needed);
    }

    const start = _catalogMerged.totalUsed;
    _catalogMerged.ranges[key] = { start, count };
    _catalogMerged.totalUsed += count;

    // Set colors, sizes, visibility for this range
    const colAttr = _catalogMerged.geometry.getAttribute('color');
    const sizeAttr = _catalogMerged.geometry.getAttribute('aSize');
    const visAttr = _catalogMerged.geometry.getAttribute('aVisible');

    cs.baseColor = new THREE.Color(group.color);
    for (let i = 0; i < count; i++) {
        const gi = start + i;
        colAttr.setXYZ(gi, cs.baseColor.r, cs.baseColor.g, cs.baseColor.b);
        sizeAttr.setX(gi, group.size);
        visAttr.setX(gi, 1.0);
    }

    colAttr.needsUpdate = true;
    sizeAttr.needsUpdate = true;
    visAttr.needsUpdate = true;

    // Extend draw range to cover all loaded sats
    _catalogMerged.geometry.setDrawRange(0, _catalogMerged.totalUsed);
}

function updateCatalogPositions(key, force) {
    const cs = catalogState[key];
    const range = _catalogMerged.ranges[key];
    if (!cs || !cs.satellites.length || !range || !_catalogMerged.geometry) return;
    if (!force && !cs.visible) return;

    const posAttr = _catalogMerged.geometry.getAttribute('position');
    const gmst = satellite.gstime(simTime);

    for (let i = 0; i < cs.satellites.length; i++) {
        const sat = cs.satellites[i];
        const posVel = satellite.propagate(sat.satrec, simTime);

        if (posVel.position && typeof posVel.position !== 'boolean') {
            const eci = posVel.position;
            const geo = satellite.eciToGeodetic(eci, gmst);
            sat.lat = satellite.degreesLat(geo.latitude);
            sat.lon = satellite.degreesLong(geo.longitude);
            sat.alt = geo.height;

            sat.eciX = eci.x; sat.eciY = eci.y; sat.eciZ = eci.z;

            if (posVel.velocity) {
                const v = posVel.velocity;
                sat.speed = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                sat.eciVx = v.x; sat.eciVy = v.y; sat.eciVz = v.z;
            }

            if (referenceFrame === 'eci') {
                const s = SAT_SCALE;
                sat.x = eci.x * s; sat.y = eci.z * s; sat.z = -eci.y * s;
            } else {
                geoToVec3Into(sat.lat, sat.lon, sat.alt, _geoOut);
                sat.x = _geoOut.x; sat.y = _geoOut.y; sat.z = _geoOut.z;
            }

            posAttr.setXYZ(range.start + i, sat.x, sat.y, sat.z);
        }
    }

    posAttr.needsUpdate = true;

    // Keep highlight sprite in sync
    if (_catalogHighlightSprite && _catalogHighlightSprite.visible && selectedCatalogGroup === key && selectedCatalogIndex >= 0) {
        const sel = cs.satellites[selectedCatalogIndex];
        if (sel) _catalogHighlightSprite.position.set(sel.x, sel.y, sel.z);
    }
}

function toggleCatalogGroup(key) {
    const cs = catalogState[key];
    if (!cs || !cs.loaded) return;

    cs.visible = !cs.visible;

    // Set visibility attribute in merged buffer
    const range = _catalogMerged.ranges[key];
    if (range && _catalogMerged.geometry) {
        const visAttr = _catalogMerged.geometry.getAttribute('aVisible');
        const val = cs.visible ? 1.0 : 0.0;
        for (let i = 0; i < range.count; i++) {
            visAttr.setX(range.start + i, val);
        }
        visAttr.needsUpdate = true;
    }

    // Update panel row
    const row = document.querySelector(`.catalog-group-row[data-group-key="${key}"]`);
    if (row) row.classList.toggle('active', cs.visible);

    // Force position update when toggling on
    if (cs.visible) {
        updateCatalogPositions(key, true);
    }

    // Deselect if toggled-off group had selected sat
    if (!cs.visible && selectedCatalogGroup === key) {
        clearCatalogSelection();
    }

    // Show/hide sidebar folder
    const folder = document.querySelector(`.folder[data-folder-id="catalog-${key}"]`);
    if (folder) folder.style.display = cs.visible ? '' : 'none';

    // Sync constellation trail visibility
    const trail = _constellationTrails[key];
    if (trail && trail.enabled) {
        if (!cs.visible) {
            if (trail.lineSegments) trail.lineSegments.visible = false;
        } else {
            if (trail.lineSegments) trail.lineSegments.visible = true;
            trail.dirty = true;
        }
    }
    // Update trail button enabled state
    const trailBtn = document.querySelector(`.catalog-trail-btn[data-trail-key="${key}"]`);
    if (trailBtn) trailBtn.classList.toggle('enabled', cs.visible);
}

function isCatalogSatVisible(key, idx) {
    const cs = catalogState[key];
    if (!cs) return false;
    const sat = cs.satellites[idx];
    _satPos.set(sat.x, sat.y, sat.z);
    _camToStation.copy(_satPos).sub(camera.position).normalize();
    raycaster.set(camera.position, _camToStation);
    const hit = raycaster.ray.intersectSphere(_earthSphere, _intersectPt);
    if (!hit) return true;
    const distToSat = camera.position.distanceTo(_satPos);
    return camera.position.distanceTo(_intersectPt) >= distToSat * 0.98;
}

function _showCatalogHighlightSprite(sat) {
    if (!_catalogHighlightSprite) {
        const mat = new THREE.SpriteMaterial({ map: _getSharedPointTexture(), transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
        _catalogHighlightSprite = new THREE.Sprite(mat);
        _catalogHighlightSprite.renderOrder = 2;
        scene.add(_catalogHighlightSprite);
    }
    _catalogHighlightSprite.position.set(sat.x, sat.y, sat.z);
    _catalogHighlightSprite.scale.set(1.0, 1.0, 1);
    _catalogHighlightSprite.visible = true;
}

function clearCatalogSelection() {
    if (selectedCatalogGroup && selectedCatalogIndex >= 0) {
        const cs = catalogState[selectedCatalogGroup];
        const range = _catalogMerged.ranges[selectedCatalogGroup];
        if (cs && range && _catalogMerged.geometry) {
            const colAttr = _catalogMerged.geometry.getAttribute('color');
            colAttr.setXYZ(range.start + selectedCatalogIndex, cs.baseColor.r, cs.baseColor.g, cs.baseColor.b);
            colAttr.needsUpdate = true;
        }
        // Remove selection in sidebar
        const oldItem = $satList.querySelector(`.catalog-sat-item.selected`);
        if (oldItem) oldItem.classList.remove('selected');
    }
    if (_catalogHighlightSprite) _catalogHighlightSprite.visible = false;
    selectedCatalogGroup = null;
    selectedCatalogIndex = -1;
}

function selectCatalogSatellite(groupKey, idx) {
    // Deselect any existing OneWeb selection
    if (selectedIndex >= 0) {
        if (trackingIndex >= 0) stopTracking();
        $detailPanel.classList.add('hidden');
        clearTtcPasses();
        const oldItem = $satList.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        resetSatColor(selectedIndex);
        selectedIndex = -1;
        clearOrbitPath();
        clearCoverageFootprint();
    }
    // Deselect GEO
    closeGeoPanel();
    // Deselect plane
    if (selectedPlane >= 0) {
        selectedPlane = -1;
        removePlaneGlow();
        restoreAllSatColors();
    }

    // Toggle off if re-clicking
    if (selectedCatalogGroup === groupKey && selectedCatalogIndex === idx) {
        clearCatalogSelection();
        $detailPanel.classList.add('hidden');
        clearOrbitPath();
        return;
    }

    // Clear previous catalog selection
    clearCatalogSelection();

    selectedCatalogGroup = groupKey;
    selectedCatalogIndex = idx;
    const cs = catalogState[groupKey];
    const sat = cs.satellites[idx];

    // Highlight dot → white in merged buffer
    const range = _catalogMerged.ranges[groupKey];
    if (range && _catalogMerged.geometry) {
        const colAttr = _catalogMerged.geometry.getAttribute('color');
        colAttr.setXYZ(range.start + idx, 1, 1, 1);
        colAttr.needsUpdate = true;
    }
    _showCatalogHighlightSprite(sat);

    // Highlight in sidebar
    const newItem = $satList.querySelector(`.catalog-sat-item[data-group="${groupKey}"][data-cat-index="${idx}"]`);
    if (newItem) {
        let parentFolder = newItem.closest('.folder.collapsed');
        while (parentFolder) {
            parentFolder.classList.remove('collapsed');
            parentFolder = parentFolder.parentElement && parentFolder.parentElement.closest('.folder.collapsed');
        }
        newItem.classList.add('selected');
    }

    // Populate detail panel with catalog sat info
    const group = CATALOG_GROUPS.find(g => g.key === groupKey);
    $detailName.textContent = sat.name;
    $detailPanel.classList.remove('hidden');

    // Hide OneWeb-specific buttons
    document.getElementById('detail-alarm').style.display = 'none';
    document.getElementById('detail-beams').style.display = 'none';

    // Update detail panel fields
    updateCatalogDetailPanel(groupKey, idx);

    // Show orbit path
    showCatalogOrbitPath(groupKey, idx);
}

function updateCatalogDetailPanel(groupKey, idx) {
    const cs = catalogState[groupKey];
    if (!cs) return;
    const sat = cs.satellites[idx];
    const group = CATALOG_GROUPS.find(g => g.key === groupKey);

    $detailName.textContent = sat.name;
    $detailLat.textContent = sat.lat.toFixed(3) + '\u00B0';
    $detailLon.textContent = sat.lon.toFixed(3) + '\u00B0';
    $detailAlt.textContent = Math.round(sat.alt).toLocaleString() + ' km';
    $detailVel.textContent = (sat.speed || 0).toFixed(1) + ' km/s';

    if (sat.eciX !== undefined && sat.eciVx !== undefined) {
        const _mu = 398600.4418;
        const _rx = sat.eciX, _ry = sat.eciY, _rz = sat.eciZ;
        const _vx = sat.eciVx, _vy = sat.eciVy, _vz = sat.eciVz;
        const _rM = Math.sqrt(_rx*_rx + _ry*_ry + _rz*_rz);
        const _vM = Math.sqrt(_vx*_vx + _vy*_vy + _vz*_vz);
        const _hx = _ry*_vz - _rz*_vy, _hy = _rz*_vx - _rx*_vz, _hz = _rx*_vy - _ry*_vx;
        const _hM = Math.sqrt(_hx*_hx + _hy*_hy + _hz*_hz);
        const _vxh_x = _vy*_hz - _vz*_hy, _vxh_y = _vz*_hx - _vx*_hz, _vxh_z = _vx*_hy - _vy*_hx;
        const _ex = _vxh_x/_mu - _rx/_rM, _ey = _vxh_y/_mu - _ry/_rM, _ez = _vxh_z/_mu - _rz/_rM;
        const oscEcc = Math.sqrt(_ex*_ex + _ey*_ey + _ez*_ez);
        const oscInc = Math.acos(Math.max(-1, Math.min(1, _hz / _hM))) * RAD2DEG;
        const oscA = 1 / (2/_rM - _vM*_vM/_mu);
        const oscPeriod = 2 * Math.PI * Math.sqrt(oscA*oscA*oscA / _mu) / 60;
        const _nnx = -_hy, _nny = _hx;
        const _nM = Math.sqrt(_nnx*_nnx + _nny*_nny);
        let oscRaan = 0;
        if (_nM > 1e-10) {
            oscRaan = Math.acos(Math.max(-1, Math.min(1, _nnx / _nM)));
            if (_nny < 0) oscRaan = 2*Math.PI - oscRaan;
        }
        const nx = Math.cos(oscRaan), ny = Math.sin(oscRaan);
        const px = _rx * nx + _ry * ny;
        const py = (-_rx * ny + _ry * nx) * Math.cos(oscInc * DEG2RAD) + _rz * Math.sin(oscInc * DEG2RAD);
        const aol = ((Math.atan2(py, px) * RAD2DEG) % 360 + 360) % 360;

        $detailInc.textContent = oscInc.toFixed(2) + '\u00B0';
        $detailEcc.textContent = oscEcc.toFixed(6);
        $detailRaan.textContent = (oscRaan * RAD2DEG).toFixed(2) + '\u00B0';
        $detailAol.textContent = aol.toFixed(2) + '\u00B0';
        $detailPeriod.textContent = oscPeriod.toFixed(1) + ' min';
    } else {
        $detailInc.textContent = sat.inclination.toFixed(2) + '\u00B0';
        $detailEcc.textContent = sat.eccentricity.toFixed(6);
        const raan = (sat.satrec.nodeo * RAD2DEG % 360 + 360) % 360;
        $detailRaan.textContent = raan.toFixed(2) + '\u00B0';
        $detailAol.textContent = '--';
        $detailPeriod.textContent = sat.period.toFixed(1) + ' min';
    }

    $detailNorad.textContent = sat.noradId;

    // TLE age
    var tleEpochMs = (sat.satrec.jdsatepoch - 2440587.5) * 86400000;
    var tleAgeDays = (Date.now() - tleEpochMs) / 86400000;
    if (tleAgeDays < 1) {
        $detailTleAge.textContent = Math.floor(tleAgeDays * 24) + 'h';
        $detailTleAge.style.color = 'var(--success)';
    } else if (tleAgeDays < 3) {
        $detailTleAge.textContent = tleAgeDays.toFixed(1) + ' days';
        $detailTleAge.style.color = 'var(--success)';
    } else if (tleAgeDays < 7) {
        $detailTleAge.textContent = tleAgeDays.toFixed(1) + ' days';
        $detailTleAge.style.color = '#ffeb3b';
    } else {
        $detailTleAge.textContent = tleAgeDays.toFixed(1) + ' days';
        $detailTleAge.style.color = '#ff5252';
    }

    $detailPlane.textContent = group ? group.label : groupKey;
    $detailFormation.textContent = '\u2014';
    $detailFormation.style.color = '';
}

function showCatalogOrbitPath(groupKey, idx) {
    const cs = catalogState[groupKey];
    if (!cs) { clearOrbitPath(); return; }
    const sat = cs.satellites[idx];
    if (!sat || !sat.satrec) { clearOrbitPath(); return; }

    const group = CATALOG_GROUPS.find(g => g.key === groupKey);
    const period = sat.period * 60 * 1000;
    const hiSpeed = Math.abs(timeMultiplier) > 50;
    const steps = hiSpeed ? 80 : 200;
    const stepMs = period / steps;

    const pts = [];
    for (let s = 0; s <= steps; s++) {
        const t = new Date(simTime.getTime() + s * stepMs);
        const posVel = satellite.propagate(sat.satrec, t);
        if (!posVel.position || typeof posVel.position === 'boolean') continue;
        const eci = posVel.position;
        if (referenceFrame === 'eci') {
            pts.push(new THREE.Vector3(eci.x * SAT_SCALE, eci.z * SAT_SCALE, -eci.y * SAT_SCALE));
        } else {
            const gmst = satellite.gstime(t);
            const geo = satellite.eciToGeodetic(eci, gmst);
            pts.push(geoToVec3(satellite.degreesLat(geo.latitude), satellite.degreesLong(geo.longitude), geo.height));
        }
    }

    const pastSteps = hiSpeed ? 40 : 100;
    const pastStepMs = (period * 0.5) / pastSteps;
    const pastPts = [];
    for (let s = pastSteps; s >= 0; s--) {
        const t = new Date(simTime.getTime() - s * pastStepMs);
        const posVel = satellite.propagate(sat.satrec, t);
        if (!posVel.position || typeof posVel.position === 'boolean') continue;
        const eci = posVel.position;
        if (referenceFrame === 'eci') {
            pastPts.push(new THREE.Vector3(eci.x * SAT_SCALE, eci.z * SAT_SCALE, -eci.y * SAT_SCALE));
        } else {
            const gmst = satellite.gstime(t);
            const geo = satellite.eciToGeodetic(eci, gmst);
            pastPts.push(geoToVec3(satellite.degreesLat(geo.latitude), satellite.degreesLong(geo.longitude), geo.height));
        }
    }

    const lineColor = group ? new THREE.Color(group.color) : new THREE.Color(0xb388ff);

    // Reuse existing line buffers instead of dispose+recreate
    if (groundTrack) groundTrack.visible = false;
    if (pastGroundTrack) pastGroundTrack.visible = false;
    orbitLine = _updateLine(orbitLine, pts, lineColor, 0.5, false, 2);
    pastOrbitLine = _updateLine(pastOrbitLine, pastPts, lineColor, 0.2, false, 2);
}

function appendCatalogFolder(key) {
    const cs = catalogState[key];
    const group = CATALOG_GROUPS.find(g => g.key === key);
    if (!cs || !group) return;

    // Remove existing folder if any
    const existing = $satList.querySelector(`.folder[data-folder-id="catalog-${key}"]`);
    if (existing) existing.remove();

    const colorClass = 'accent-purple';
    const folder = _createFolder('catalog-' + key, group.label.toUpperCase(), cs.satellites.length, false, colorClass);
    folder.classList.add('collapsed');
    folder.querySelector('.folder-label').style.color = group.color;
    const body = folder.querySelector('.folder-body');

    if (cs.satellites.length <= 200) {
        // Individual items
        cs.satellites.forEach((sat, i) => {
            const div = document.createElement('div');
            div.className = 'sat-item catalog-sat-item';
            div.dataset.group = key;
            div.dataset.catIndex = i;
            div.innerHTML = `<div class="sat-dot" style="background:${group.color}"></div><div class="sat-info"><div class="sat-name">${sat.name}</div><div class="sat-meta">${group.label} &middot; ID ${sat.noradId}</div></div>`;
            div.addEventListener('click', () => selectCatalogSatellite(key, i));
            body.appendChild(div);
        });
    } else {
        // Summary for large groups
        const info = document.createElement('div');
        info.className = 'sat-item';
        info.style.opacity = '0.6';
        info.style.cursor = 'default';
        info.innerHTML = `<div class="sat-info"><div class="sat-name">${cs.satellites.length} satellites</div><div class="sat-meta">Use search to find individual sats</div></div>`;
        body.appendChild(info);
    }

    $satList.appendChild(folder);
}

// ============================================================
// SATELLITE RENDERING
// ============================================================
function createSatellitePoints() {
    const count = satellites.length;
    satGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);

    satGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    satGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    satColorAttr = satGeometry.getAttribute('color');

    // Point texture (HD 128x128)
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.15, 'rgba(255,255,255,0.95)');
    gradient.addColorStop(0.35, 'rgba(255,255,255,0.5)');
    gradient.addColorStop(0.6, 'rgba(255,255,255,0.12)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);
    const pointTexture = new THREE.CanvasTexture(canvas);

    const mat = new THREE.PointsMaterial({
        size: 0.22,
        map: pointTexture,
        vertexColors: true,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
    });

    satPointCloud = new THREE.Points(satGeometry, mat);
    satPointCloud.renderOrder = 1;
    scene.add(satPointCloud);

    // Set initial colors
    const baseColor = new THREE.Color(0x00e5ff);
    const excludedColor = new THREE.Color(0xff3333);
    for (let i = 0; i < count; i++) {
        const c = satellites[i].excluded ? excludedColor : baseColor;
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
    }
    satColorAttr.needsUpdate = true;

    // First position update
    updateSatellitePositions();

    // Hide loading
    setTimeout(() => $loading.classList.add('hidden'), 400);
}

function showPlaneGlow(planeNum) {
    removePlaneGlow();

    // Collect indices of satellites in this plane
    planeGlowIndices = [];
    for (let i = 0; i < satellites.length; i++) {
        if (satellites[i].plane === planeNum) planeGlowIndices.push(i);
    }
    if (planeGlowIndices.length === 0) return;

    const count = planeGlowIndices.length;
    planeGlowGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);

    // Copy current positions from main geometry
    const mainPos = satGeometry.getAttribute('position');
    for (let j = 0; j < count; j++) {
        const i = planeGlowIndices[j];
        positions[j * 3] = mainPos.getX(i);
        positions[j * 3 + 1] = mainPos.getY(i);
        positions[j * 3 + 2] = mainPos.getZ(i);
    }
    planeGlowGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // Big soft blue glow texture
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.1, 'rgba(100,200,255,0.9)');
    gradient.addColorStop(0.3, 'rgba(0,180,255,0.5)');
    gradient.addColorStop(0.6, 'rgba(0,120,255,0.15)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);
    const glowTexture = new THREE.CanvasTexture(canvas);

    const mat = new THREE.PointsMaterial({
        size: 0.65,
        map: glowTexture,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
        color: 0x44bbff,
    });

    planeGlowCloud = new THREE.Points(planeGlowGeo, mat);
    scene.add(planeGlowCloud);

    // Semi-transparent orbital plane disc (skip for unassigned plane 0 — not a coherent plane)
    if (planeNum !== 0) {
        const normal = new THREE.Vector3(0, 0, 0);
        const quarter = Math.max(1, Math.floor(count / 4));
        for (let j = 0; j < count; j++) {
            const k = (j + quarter) % count;
            const a = new THREE.Vector3(positions[j*3], positions[j*3+1], positions[j*3+2]);
            const b = new THREE.Vector3(positions[k*3], positions[k*3+1], positions[k*3+2]);
            normal.add(new THREE.Vector3().crossVectors(a, b));
        }
        normal.normalize();
        const avgDist = positions.length > 0
            ? Math.sqrt(positions[0]**2 + positions[1]**2 + positions[2]**2)
            : EARTH_RADIUS + 1;
        const discGeo = new THREE.CircleGeometry(avgDist * 1.15, 64);
        const discMat = new THREE.MeshBasicMaterial({
            color: 0x44bbff, transparent: true, opacity: 0.06,
            side: THREE.DoubleSide, depthWrite: false,
        });
        planeDiscMesh = new THREE.Mesh(discGeo, discMat);
        const up = new THREE.Vector3(0, 0, 1);
        planeDiscMesh.quaternion.setFromUnitVectors(up, normal);
        scene.add(planeDiscMesh);
    }
}

function removePlaneGlow() {
    if (planeGlowCloud) {
        scene.remove(planeGlowCloud);
        planeGlowGeo.dispose();
        planeGlowCloud.material.map.dispose();
        planeGlowCloud.material.dispose();
        planeGlowCloud = null;
        planeGlowGeo = null;
        planeGlowIndices = [];
    }
    if (planeDiscMesh) {
        scene.remove(planeDiscMesh);
        planeDiscMesh.geometry.dispose();
        planeDiscMesh.material.dispose();
        planeDiscMesh = null;
    }
    // Hide rotate buttons
}

function updatePlaneGlow() {
    if (!planeGlowCloud || !planeGlowGeo || planeGlowIndices.length === 0) return;
    const mainPos = satGeometry.getAttribute('position');
    const glowPos = planeGlowGeo.getAttribute('position');
    for (let j = 0; j < planeGlowIndices.length; j++) {
        const i = planeGlowIndices[j];
        glowPos.setXYZ(j, mainPos.getX(i), mainPos.getY(i), mainPos.getZ(i));
    }
    glowPos.needsUpdate = true;
}

function geoToVec3(latDeg, lonDeg, altKm) {
    const r = EARTH_RADIUS + altKm * SAT_SCALE;
    const latRad = latDeg * DEG2RAD;
    const lonRad = -lonDeg * DEG2RAD; // negate for Three.js convention
    return new THREE.Vector3(
        r * Math.cos(latRad) * Math.cos(lonRad),
        r * Math.sin(latRad),
        r * Math.cos(latRad) * Math.sin(lonRad)
    );
}

// Allocation-free version that writes into an existing Vector3
const _geoOut = new THREE.Vector3();
function geoToVec3Into(latDeg, lonDeg, altKm, out) {
    const r = EARTH_RADIUS + altKm * SAT_SCALE;
    const latRad = latDeg * DEG2RAD;
    const lonRad = -lonDeg * DEG2RAD;
    return out.set(
        r * Math.cos(latRad) * Math.cos(lonRad),
        r * Math.sin(latRad),
        r * Math.cos(latRad) * Math.sin(lonRad)
    );
}

function updateSatellitePositions() {
    if (!satellites.length || !satGeometry) return;

    const posAttr = satGeometry.getAttribute('position');
    const gmst = satellite.gstime(simTime);
    let totalAlt = 0;
    let validCount = 0;

    for (let i = 0; i < satellites.length; i++) {
        const sat = satellites[i];
        const posVel = satellite.propagate(sat.satrec, simTime);

        if (posVel.position && typeof posVel.position !== 'boolean') {
            const eci = posVel.position;
            const geo = satellite.eciToGeodetic(eci, gmst);

            sat.lat = satellite.degreesLat(geo.latitude);
            sat.lon = satellite.degreesLong(geo.longitude);
            sat.alt = geo.height;

            // Cache ECI position for reuse by detail panel
            sat.eciX = eci.x; sat.eciY = eci.y; sat.eciZ = eci.z;

            if (posVel.velocity) {
                const v = posVel.velocity;
                sat.speed = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                sat.eciVx = v.x; sat.eciVy = v.y; sat.eciVz = v.z;
            }

            // Store previous world position for velocity direction (tracking arrow)
            sat._prevX = sat.x; sat._prevY = sat.y; sat._prevZ = sat.z;

            if (referenceFrame === 'eci') {
                // ECI → scene directly: (eciX, eciZ, -eciY) * SAT_SCALE
                const s = SAT_SCALE;
                sat.x = eci.x * s;
                sat.y = eci.z * s;
                sat.z = -eci.y * s;
            } else {
                geoToVec3Into(sat.lat, sat.lon, sat.alt, _geoOut);
                sat.x = _geoOut.x;
                sat.y = _geoOut.y;
                sat.z = _geoOut.z;
            }

            posAttr.setXYZ(i, sat.x, sat.y, sat.z);
            totalAlt += sat.alt;
            validCount++;
        }
    }

    posAttr.needsUpdate = true;

    // Sync plane glow overlay positions
    updatePlaneGlow();

    // Update average altitude stat
    if (validCount > 0) {
        $statAlt.textContent = Math.round(totalAlt / validCount).toLocaleString();
    }
}

// ============================================================
// ORBIT PATH FOR SELECTED SAT
// ============================================================
function computePathPoints(sat, startMs, endMs, steps) {
    const dt = (endMs - startMs) / steps;
    const orbitPts = [];
    const trackPts = [];
    const isEci = referenceFrame === 'eci';
    for (let s = 0; s <= steps; s++) {
        const t = new Date(startMs + s * dt);
        const pv = satellite.propagate(sat.satrec, t);
        if (pv.position && typeof pv.position !== 'boolean') {
            if (isEci) {
                const e = pv.position;
                const sc = SAT_SCALE;
                orbitPts.push(new THREE.Vector3(e.x * sc, e.z * sc, -e.y * sc));
            } else {
                const gmst = satellite.gstime(t);
                const geo = satellite.eciToGeodetic(pv.position, gmst);
                const lat = satellite.degreesLat(geo.latitude);
                const lon = satellite.degreesLong(geo.longitude);
                const alt = geo.height;
                orbitPts.push(geoToVec3(lat, lon, alt));
                trackPts.push(geoToVec3(lat, lon, 0));
            }
        }
    }
    return { orbitPts, trackPts };
}

function makeLine(pts, color, opacity, additive) {
    if (pts.length < 2) return null;
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({
        color, transparent: true, opacity, depthWrite: false,
        blending: additive ? THREE.AdditiveBlending : THREE.NormalBlending,
    });
    const line = new THREE.Line(geo, mat);
    scene.add(line);
    return line;
}

// Reuse existing line geometry buffer instead of dispose+recreate
function _updateLine(existingLine, pts, color, opacity, additive, renderOrder) {
    if (pts.length < 2) {
        if (existingLine) return disposeLine(existingLine);
        return null;
    }
    if (existingLine) {
        const posAttr = existingLine.geometry.getAttribute('position');
        const needed = pts.length * 3;
        if (posAttr && posAttr.array.length >= needed) {
            for (let i = 0; i < pts.length; i++) {
                posAttr.array[i * 3] = pts[i].x;
                posAttr.array[i * 3 + 1] = pts[i].y;
                posAttr.array[i * 3 + 2] = pts[i].z;
            }
            posAttr.needsUpdate = true;
            existingLine.geometry.setDrawRange(0, pts.length);
        } else {
            existingLine.geometry.dispose();
            const maxPts = Math.max(pts.length, 500);
            const positions = new Float32Array(maxPts * 3);
            for (let i = 0; i < pts.length; i++) {
                positions[i * 3] = pts[i].x;
                positions[i * 3 + 1] = pts[i].y;
                positions[i * 3 + 2] = pts[i].z;
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setDrawRange(0, pts.length);
            existingLine.geometry = geo;
        }
        existingLine.material.color.set(color);
        existingLine.material.opacity = opacity;
        existingLine.visible = true;
        return existingLine;
    }
    // Create new with pre-allocated buffer
    const maxPts = Math.max(pts.length, 500);
    const positions = new Float32Array(maxPts * 3);
    for (let i = 0; i < pts.length; i++) {
        positions[i * 3] = pts[i].x;
        positions[i * 3 + 1] = pts[i].y;
        positions[i * 3 + 2] = pts[i].z;
    }
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geo.setDrawRange(0, pts.length);
    const mat = new THREE.LineBasicMaterial({
        color, transparent: true, opacity, depthWrite: false,
        blending: additive ? THREE.AdditiveBlending : THREE.NormalBlending,
    });
    const line = new THREE.Line(geo, mat);
    line.renderOrder = renderOrder || 0;
    scene.add(line);
    return line;
}

function disposeLine(line) {
    if (!line) return null;
    scene.remove(line);
    line.geometry.dispose();
    line.material.dispose();
    return null;
}

function showOrbitPath(satIndex) {
    if (satIndex < 0 || satIndex >= satellites.length) { clearOrbitPath(); return; }

    const sat = satellites[satIndex];
    const periodMs = sat.period * 60 * 1000;
    const nowMs = simTime.getTime();
    const isTracking = trackingIndex === satIndex;

    // Reduce path resolution at high speed (less noticeable + much cheaper)
    const hiSpeed = Math.abs(timeMultiplier) > 50;

    if (isTracking) {
        // Hide forward lines
        if (orbitLine) orbitLine.visible = false;
        if (groundTrack) groundTrack.visible = false;
        // Past: vivid green, 2 revolutions back — reuse buffers
        const past = computePathPoints(sat, nowMs - periodMs * 2, nowMs, hiSpeed ? 150 : 400);
        pastOrbitLine = _updateLine(pastOrbitLine, past.orbitPts, 0x00ff88, 0.85, true, 0);
        pastGroundTrack = past.trackPts.length > 1
            ? _updateLine(pastGroundTrack, past.trackPts, 0x00ff88, 0.2, false, 0)
            : (pastGroundTrack ? disposeLine(pastGroundTrack) : null);
    } else {
        // Hide past lines
        if (pastOrbitLine) pastOrbitLine.visible = false;
        if (pastGroundTrack) pastGroundTrack.visible = false;
        // Default select: orange, 1 revolution forward — reuse buffers
        const fwd = computePathPoints(sat, nowMs, nowMs + periodMs, hiSpeed ? 80 : 200);
        orbitLine = _updateLine(orbitLine, fwd.orbitPts, 0xff6b35, 0.6, false, 0);
        groundTrack = fwd.trackPts.length > 1
            ? _updateLine(groundTrack, fwd.trackPts, 0xff6b35, 0.15, false, 0)
            : (groundTrack ? disposeLine(groundTrack) : null);
    }
}

// ============================================================
// COVERAGE FOOTPRINT
// ============================================================
function createCoverageFootprint() {
    clearCoverageFootprint();
    const segs = BEAM_SEGMENTS;
    const rings = BEAM_RINGS;
    const vertsPerBeam = 1 + rings * segs;
    const totalVerts = NUM_BEAMS * vertsPerBeam;
    const positions = new Float32Array(totalVerts * 3);
    const colors = new Float32Array(totalVerts * 3);

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const indices = [];
    for (let b = 0; b < NUM_BEAMS; b++) {
        const base = b * vertsPerBeam;
        // Center fan to first ring
        for (let i = 0; i < segs; i++) {
            indices.push(base, base + 1 + i, base + 1 + ((i + 1) % segs));
        }
        // Quad strips between consecutive rings
        for (let r = 0; r < rings - 1; r++) {
            const ring0 = base + 1 + r * segs;
            const ring1 = base + 1 + (r + 1) * segs;
            for (let i = 0; i < segs; i++) {
                const i1 = (i + 1) % segs;
                indices.push(ring0 + i, ring1 + i, ring1 + i1);
                indices.push(ring0 + i, ring1 + i1, ring0 + i1);
            }
        }
        // Vertex colors for this beam
        const c = BEAM_COLORS[b];
        for (let v = 0; v < vertsPerBeam; v++) {
            const ci = (base + v) * 3;
            colors[ci] = c.r; colors[ci + 1] = c.g; colors[ci + 2] = c.b;
        }
    }
    geo.setIndex(indices);

    const mat = new THREE.MeshBasicMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.25,
        side: THREE.DoubleSide,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1,
    });
    beamMesh = new THREE.Mesh(geo, mat);
    beamMesh.renderOrder = 1;
    beamMesh.frustumCulled = false;
    scene.add(beamMesh);

    // Outlines: LineSegments with vertex colors (all beams in one draw call)
    const totalLineVerts = NUM_BEAMS * segs * 2;
    const linePositions = new Float32Array(totalLineVerts * 3);
    const lineColors = new Float32Array(totalLineVerts * 3);
    for (let b = 0; b < NUM_BEAMS; b++) {
        const c = BEAM_COLORS[b];
        const lb = b * segs * 2;
        for (let v = 0; v < segs * 2; v++) {
            const ci = (lb + v) * 3;
            lineColors[ci] = c.r; lineColors[ci + 1] = c.g; lineColors[ci + 2] = c.b;
        }
    }
    const lineGeo = new THREE.BufferGeometry();
    lineGeo.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
    lineGeo.setAttribute('color', new THREE.BufferAttribute(lineColors, 3));
    const lineMat = new THREE.LineBasicMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
    });
    beamOutline = new THREE.LineSegments(lineGeo, lineMat);
    beamOutline.renderOrder = 1;
    beamOutline.frustumCulled = false;
    scene.add(beamOutline);
}

function updateCoverageFootprint() {
    if (!beamMesh || selectedIndex < 0) return;
    const sat = satellites[selectedIndex];
    if (!sat || sat.alt == null) return;

    const surfR = EARTH_RADIUS * 1.003;
    const segs = BEAM_SEGMENTS;
    const rings = BEAM_RINGS;
    const vertsPerBeam = 1 + rings * segs;

    // Nadir direction (Earth center → satellite)
    _beamNadir.set(sat.x, sat.y, sat.z).normalize();

    // Determine along-track direction from ECI velocity
    if (sat.eciVx != null && sat.eciVy != null && sat.eciVz != null) {
        if (referenceFrame === 'eci') {
            _beamVel.set(sat.eciVx, sat.eciVz, -sat.eciVy);
        } else {
            const gmst = satellite.gstime(simTime);
            const cosG = Math.cos(gmst), sinG = Math.sin(gmst);
            const vx = sat.eciVx * cosG + sat.eciVy * sinG;
            const vy = -sat.eciVx * sinG + sat.eciVy * cosG;
            const vz = sat.eciVz;
            _beamVel.set(vx, vz, -vy);
        }
    } else {
        // Fallback: position delta
        _beamVel.set(
            sat.x - (sat._prevX || sat.x),
            sat.y - (sat._prevY || sat.y),
            sat.z - (sat._prevZ || sat.z)
        );
    }
    // Project velocity onto local horizontal (perpendicular to nadir)
    const vDotN = _beamVel.dot(_beamNadir);
    _beamAlongTrack.copy(_beamVel).addScaledVector(_beamNadir, -vDotN);
    if (_beamAlongTrack.lengthSq() < 1e-10) {
        // Fallback: pick arbitrary tangent
        _beamAlongTrack.set(0, 1, 0);
        if (Math.abs(_beamNadir.dot(_beamAlongTrack)) > 0.9) _beamAlongTrack.set(1, 0, 0);
        _beamAlongTrack.addScaledVector(_beamNadir, -_beamAlongTrack.dot(_beamNadir));
    }
    _beamAlongTrack.normalize();

    // Cross-track = nadir × along-track (perpendicular, E-W direction)
    _beamCrossTrack.crossVectors(_beamNadir, _beamAlongTrack).normalize();

    const posAttr = beamMesh.geometry.getAttribute('position');

    for (let b = 0; b < NUM_BEAMS; b++) {
        // Beam center offset along-track from nadir: 16 beams tiled N-S
        const alongOffset = (b - 7.5) * BEAM_SPACING_RAD;
        const cosA = Math.cos(alongOffset), sinA = Math.sin(alongOffset);
        _beamCenter.set(
            cosA * _beamNadir.x + sinA * _beamAlongTrack.x,
            cosA * _beamNadir.y + sinA * _beamAlongTrack.y,
            cosA * _beamNadir.z + sinA * _beamAlongTrack.z
        ).normalize();

        const base = b * vertsPerBeam;
        // Center vertex
        posAttr.setXYZ(base, _beamCenter.x * surfR, _beamCenter.y * surfR, _beamCenter.z * surfR);

        // Concentric elliptical rings on the sphere
        for (let r = 0; r < rings; r++) {
            const frac = (r + 1) / rings;
            const ringBase = base + 1 + r * segs;
            for (let i = 0; i < segs; i++) {
                const theta = (i / segs) * Math.PI * 2;
                const ct = Math.cos(theta), st = Math.sin(theta);
                // Elliptical angular offsets
                const angCross = frac * BEAM_SEMI_MAJOR_RAD * ct;
                const angAlong = frac * BEAM_SEMI_MINOR_RAD * st;
                const angTotal = Math.sqrt(angCross * angCross + angAlong * angAlong);

                if (angTotal < 1e-10) {
                    posAttr.setXYZ(ringBase + i,
                        _beamCenter.x * surfR, _beamCenter.y * surfR, _beamCenter.z * surfR);
                    continue;
                }
                // Direction on tangent plane
                const odx = angCross * _beamCrossTrack.x + angAlong * _beamAlongTrack.x;
                const ody = angCross * _beamCrossTrack.y + angAlong * _beamAlongTrack.y;
                const odz = angCross * _beamCrossTrack.z + angAlong * _beamAlongTrack.z;
                const odLen = Math.sqrt(odx * odx + ody * ody + odz * odz);
                const nx = odx / odLen, ny = ody / odLen, nz = odz / odLen;
                // Point on sphere
                const cosT = Math.cos(angTotal), sinT = Math.sin(angTotal);
                posAttr.setXYZ(ringBase + i,
                    (cosT * _beamCenter.x + sinT * nx) * surfR,
                    (cosT * _beamCenter.y + sinT * ny) * surfR,
                    (cosT * _beamCenter.z + sinT * nz) * surfR);
            }
        }
    }
    posAttr.needsUpdate = true;

    // Update outlines — outer ring of each beam
    const lineAttr = beamOutline.geometry.getAttribute('position');
    for (let b = 0; b < NUM_BEAMS; b++) {
        const outerRing = b * vertsPerBeam + 1 + (rings - 1) * segs;
        const lb = b * segs * 2;
        for (let i = 0; i < segs; i++) {
            const i1 = (i + 1) % segs;
            lineAttr.setXYZ(lb + i * 2,
                posAttr.getX(outerRing + i), posAttr.getY(outerRing + i), posAttr.getZ(outerRing + i));
            lineAttr.setXYZ(lb + i * 2 + 1,
                posAttr.getX(outerRing + i1), posAttr.getY(outerRing + i1), posAttr.getZ(outerRing + i1));
        }
    }
    lineAttr.needsUpdate = true;
}

function clearCoverageFootprint() {
    if (beamMesh) {
        scene.remove(beamMesh);
        beamMesh.geometry.dispose();
        beamMesh.material.dispose();
        beamMesh = null;
    }
    if (beamOutline) {
        scene.remove(beamOutline);
        beamOutline.geometry.dispose();
        beamOutline.material.dispose();
        beamOutline = null;
    }
}

// ============================================================
// ALL-BEAMS CONSTELLATION VIEW
// ============================================================
function createAllBeams() {
    clearAllBeams();
    const satCount = satellites.length;
    if (satCount === 0) return;

    const segs = ALL_BEAMS_SEGS;
    const totalVerts = satCount * NUM_BEAMS * segs * 2;
    const positions = new Float32Array(totalVerts * 3);
    const colors = new Float32Array(totalVerts * 3);

    // Pre-fill colors: each beam gets its BEAM_COLOR, repeated for all sats
    for (let si = 0; si < satCount; si++) {
        for (let b = 0; b < NUM_BEAMS; b++) {
            const c = BEAM_COLORS[b];
            const baseIdx = (si * NUM_BEAMS * segs * 2 + b * segs * 2) * 3;
            for (let v = 0; v < segs * 2; v++) {
                const ci = baseIdx + v * 3;
                colors[ci] = c.r; colors[ci + 1] = c.g; colors[ci + 2] = c.b;
            }
        }
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const mat = new THREE.LineBasicMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.4,
    });
    allBeamsOutline = new THREE.LineSegments(geo, mat);
    allBeamsOutline.renderOrder = 1;
    allBeamsOutline.frustumCulled = false;
    scene.add(allBeamsOutline);
}

function updateAllBeams() {
    if (!allBeamsOutline) return;
    const arr = allBeamsOutline.geometry.getAttribute('position').array;
    const surfR = EARTH_RADIUS * 1.003;
    const segs = ALL_BEAMS_SEGS;
    const isEci = referenceFrame === 'eci';
    let cosG = 0, sinG = 0;
    if (!isEci) {
        const gmst = satellite.gstime(simTime);
        cosG = Math.cos(gmst); sinG = Math.sin(gmst);
    }

    let vi = 0;
    const skipCount = NUM_BEAMS * segs * 2 * 3;

    for (let si = 0; si < satellites.length; si++) {
        const sat = satellites[si];
        if (!sat || sat.x === undefined || sat.alt == null || sat.eciVx == null) {
            arr.fill(0, vi, vi + skipCount);
            vi += skipCount;
            continue;
        }

        // Nadir direction
        const sx = sat.x, sy = sat.y, sz = sat.z;
        const sLen = Math.sqrt(sx * sx + sy * sy + sz * sz);
        if (sLen < 1e-6) { arr.fill(0, vi, vi + skipCount); vi += skipCount; continue; }
        const ndx = sx / sLen, ndy = sy / sLen, ndz = sz / sLen;

        // Velocity → along-track direction (projected onto local horizontal)
        let vx, vy, vz;
        if (isEci) {
            vx = sat.eciVx; vy = sat.eciVz; vz = -sat.eciVy;
        } else {
            vx = sat.eciVx * cosG + sat.eciVy * sinG;
            const rvy = -sat.eciVx * sinG + sat.eciVy * cosG;
            vy = sat.eciVz; vz = -rvy;
        }
        const vdot = vx * ndx + vy * ndy + vz * ndz;
        let ax = vx - vdot * ndx, ay = vy - vdot * ndy, az = vz - vdot * ndz;
        let aLen = Math.sqrt(ax * ax + ay * ay + az * az);
        if (aLen < 1e-10) { ax = 0; ay = 1; az = 0; aLen = 1; }
        ax /= aLen; ay /= aLen; az /= aLen;

        // Cross-track = nadir × along-track
        const cx = ndy * az - ndz * ay;
        const cy = ndz * ax - ndx * az;
        const cz = ndx * ay - ndy * ax;

        for (let b = 0; b < NUM_BEAMS; b++) {
            const bo = _beamOffsets[b];
            let bcx = bo.cosA * ndx + bo.sinA * ax;
            let bcy = bo.cosA * ndy + bo.sinA * ay;
            let bcz = bo.cosA * ndz + bo.sinA * az;
            const bcLen = Math.sqrt(bcx * bcx + bcy * bcy + bcz * bcz);
            bcx /= bcLen; bcy /= bcLen; bcz /= bcLen;

            for (let i = 0; i < segs; i++) {
                const e0 = _ABE[i];
                const e1 = _ABE[(i + 1) % segs];
                // Point i
                const nd0x = e0.wC * cx + e0.wA * ax;
                const nd0y = e0.wC * cy + e0.wA * ay;
                const nd0z = e0.wC * cz + e0.wA * az;
                arr[vi++] = (e0.cosT * bcx + e0.sinT * nd0x) * surfR;
                arr[vi++] = (e0.cosT * bcy + e0.sinT * nd0y) * surfR;
                arr[vi++] = (e0.cosT * bcz + e0.sinT * nd0z) * surfR;
                // Point i+1
                const nd1x = e1.wC * cx + e1.wA * ax;
                const nd1y = e1.wC * cy + e1.wA * ay;
                const nd1z = e1.wC * cz + e1.wA * az;
                arr[vi++] = (e1.cosT * bcx + e1.sinT * nd1x) * surfR;
                arr[vi++] = (e1.cosT * bcy + e1.sinT * nd1y) * surfR;
                arr[vi++] = (e1.cosT * bcz + e1.sinT * nd1z) * surfR;
            }
        }
    }
    allBeamsOutline.geometry.getAttribute('position').needsUpdate = true;
}

function clearAllBeams() {
    if (allBeamsOutline) {
        scene.remove(allBeamsOutline);
        allBeamsOutline.geometry.dispose();
        allBeamsOutline.material.dispose();
        allBeamsOutline = null;
    }
}

function clearOrbitPath() {
    orbitLine = disposeLine(orbitLine);
    groundTrack = disposeLine(groundTrack);
    pastOrbitLine = disposeLine(pastOrbitLine);
    pastGroundTrack = disposeLine(pastGroundTrack);
}

// ============================================================
// CONSTELLATION TRAIL LINES
// ============================================================

function _trailParams(satCount) {
    if (satCount > 3000) return { maxSats: 200, steps: 40 };
    if (satCount > 500) return { maxSats: 300, steps: 60 };
    if (satCount > 200) return { maxSats: satCount, steps: 60 };
    if (satCount > 50) return { maxSats: satCount, steps: 80 };
    return { maxSats: satCount, steps: 120 };
}

function _resolveTrailSats(key) {
    const group = CATALOG_GROUPS.find(g => g.key === key);
    if (!group) return null;
    if (group.builtin === 'oneweb') return satellites;
    if (group.builtin === 'geo') return geoSatellites;
    const cs = catalogState[key];
    return (cs && cs.loaded) ? cs.satellites : null;
}

function _isGroupVisible(key) {
    const group = CATALOG_GROUPS.find(g => g.key === key);
    if (!group) return false;
    if (group.builtin === 'oneweb') return satPointCloud && satPointCloud.visible;
    if (group.builtin === 'geo') return geoSatsVisible;
    const cs = catalogState[key];
    return cs && cs.loaded && cs.visible;
}

async function computeConstellationTrail(key) {
    const sats = _resolveTrailSats(key);
    if (!sats || sats.length === 0) return null;

    const { maxSats, steps } = _trailParams(sats.length);
    const isEci = referenceFrame === 'eci';
    const sc = SAT_SCALE;

    // Evenly sample if exceeding maxSats
    let indices;
    if (sats.length <= maxSats) {
        indices = Array.from({ length: sats.length }, (_, i) => i);
    } else {
        indices = [];
        const step = sats.length / maxSats;
        for (let i = 0; i < maxSats; i++) {
            indices.push(Math.floor(i * step));
        }
    }

    const now = simTime.getTime();
    // LineSegments format: pairs of adjacent points (A0,A1, A1,A2, ..., An-1,An) per sat
    // Each sat produces `steps` segments = `steps * 2` vertices
    const totalVerts = indices.length * steps * 2;
    const positions = new Float32Array(totalVerts * 3);
    let writeIdx = 0;
    const BATCH_SIZE = 50;

    for (let b = 0; b < indices.length; b += BATCH_SIZE) {
        const end = Math.min(b + BATCH_SIZE, indices.length);
        for (let si = b; si < end; si++) {
            const sat = sats[indices[si]];
            if (!sat.satrec) continue;
            const periodMs = (sat.period || 90) * 60 * 1000;
            const dt = periodMs / steps;

            // Compute orbit points
            let prevX, prevY, prevZ;
            let hasPrev = false;
            for (let s = 0; s <= steps; s++) {
                const t = new Date(now + s * dt);
                const pv = satellite.propagate(sat.satrec, t);
                if (!pv.position || typeof pv.position === 'boolean') {
                    hasPrev = false;
                    continue;
                }
                let px, py, pz;
                if (isEci) {
                    const e = pv.position;
                    px = e.x * sc; py = e.z * sc; pz = -e.y * sc;
                } else {
                    const gmst = satellite.gstime(t);
                    const geo = satellite.eciToGeodetic(pv.position, gmst);
                    const latR = geo.latitude;
                    const lonR = geo.longitude;
                    const r = (EARTH_RADIUS_KM + geo.height) * sc;
                    const cLat = Math.cos(latR), sLat = Math.sin(latR);
                    const cLon = Math.cos(lonR), sLon = Math.sin(lonR);
                    px = r * cLat * cLon;
                    py = r * sLat;
                    pz = -r * cLat * sLon;
                }
                if (hasPrev) {
                    positions[writeIdx++] = prevX;
                    positions[writeIdx++] = prevY;
                    positions[writeIdx++] = prevZ;
                    positions[writeIdx++] = px;
                    positions[writeIdx++] = py;
                    positions[writeIdx++] = pz;
                }
                prevX = px; prevY = py; prevZ = pz;
                hasPrev = true;
            }
        }
        // Yield to main thread
        if (end < indices.length) {
            await new Promise(r => setTimeout(r, 0));
        }
    }

    return { positions, vertexCount: writeIdx / 3, sampledCount: indices.length, stepsPerSat: steps };
}

function buildTrailLineSegments(key, data) {
    const group = CATALOG_GROUPS.find(g => g.key === key);
    const color = group ? group.color : '#ffffff';
    const trail = _constellationTrails[key];

    if (trail && trail.lineSegments) {
        // Reuse if buffer large enough
        const posAttr = trail.geometry.getAttribute('position');
        if (posAttr.array.length >= data.vertexCount * 3) {
            posAttr.array.set(data.positions.subarray(0, data.vertexCount * 3));
            posAttr.needsUpdate = true;
            trail.geometry.setDrawRange(0, data.vertexCount);
            trail.lineSegments.visible = true;
            return;
        }
        // Buffer too small — dispose and recreate
        scene.remove(trail.lineSegments);
        trail.geometry.dispose();
        trail.material.dispose();
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(data.positions, 3));
    geo.setDrawRange(0, data.vertexCount);
    const mat = new THREE.LineBasicMaterial({
        color, transparent: true, opacity: 0.18,
        depthWrite: false, blending: THREE.AdditiveBlending,
    });
    const ls = new THREE.LineSegments(geo, mat);
    scene.add(ls);

    _constellationTrails[key] = {
        lineSegments: ls, geometry: geo, material: mat,
        enabled: true, dirty: false, computing: false,
        lastComputeMs: performance.now(),
        sampledCount: data.sampledCount,
        stepsPerSat: data.stepsPerSat,
        satCount: (_resolveTrailSats(key) || []).length,
    };
}

function removeTrailLineSegments(key) {
    const trail = _constellationTrails[key];
    if (!trail) return;
    if (trail.lineSegments) {
        scene.remove(trail.lineSegments);
        trail.geometry.dispose();
        trail.material.dispose();
    }
    delete _constellationTrails[key];
}

async function toggleConstellationTrail(key) {
    const trail = _constellationTrails[key];
    if (trail && trail.enabled) {
        // Disable
        trail.enabled = false;
        if (trail.lineSegments) trail.lineSegments.visible = false;
        removeTrailLineSegments(key);
        _updateTrailBtnState(key, false);
        return;
    }

    // Enable — compute and build
    if (!_isGroupVisible(key)) return;
    _updateTrailBtnState(key, true);
    const data = await computeConstellationTrail(key);
    if (data && data.vertexCount > 0) {
        buildTrailLineSegments(key, data);
    }
}

function _updateTrailBtnState(key, active) {
    const btn = document.querySelector(`.catalog-trail-btn[data-trail-key="${key}"]`);
    if (btn) btn.classList.toggle('active', active);
}

function updateConstellationTrails() {
    const speed = Math.abs(timeMultiplier || 1);
    const interval = speed > 100 ? 1000 : speed > 10 ? 2000 : 4000;
    const now = performance.now();

    for (const key of Object.keys(_constellationTrails)) {
        const trail = _constellationTrails[key];
        if (!trail.enabled) continue;

        // Hide trail if source group is no longer visible
        if (!_isGroupVisible(key)) {
            if (trail.lineSegments) trail.lineSegments.visible = false;
            continue;
        } else if (trail.lineSegments && !trail.lineSegments.visible) {
            trail.lineSegments.visible = true;
        }

        // Time-based recomputation
        if (trail.computing) continue;
        if (trail.dirty || (now - trail.lastComputeMs > interval)) {
            trail.computing = true;
            trail.dirty = false;
            computeConstellationTrail(key).then(data => {
                trail.computing = false;
                if (data && data.vertexCount > 0 && trail.enabled) {
                    buildTrailLineSegments(key, data);
                    trail.lastComputeMs = performance.now();
                }
            });
        }
    }
}

function clearAllConstellationTrails() {
    for (const key of Object.keys(_constellationTrails)) {
        removeTrailLineSegments(key);
        _updateTrailBtnState(key, false);
    }
}

// ============================================================
// ORBITAL ELEMENT VISUALISATIONS
// ============================================================
function eciToScene(eciX, eciY, eciZ, gmst) {
    const cosG = Math.cos(gmst), sinG = Math.sin(gmst);
    const ecefX = eciX * cosG + eciY * sinG;
    const ecefY = -eciX * sinG + eciY * cosG;
    const ecefZ = eciZ;
    return new THREE.Vector3(ecefX, ecefZ, -ecefY);
}

function makeRingPoints(radius, normal, center, segments) {
    segments = segments || 64;
    const n = normal.clone().normalize();
    const arb = Math.abs(n.y) < 0.9 ? new THREE.Vector3(0, 1, 0) : new THREE.Vector3(1, 0, 0);
    const u = new THREE.Vector3().crossVectors(n, arb).normalize();
    const v = new THREE.Vector3().crossVectors(n, u).normalize();
    const pts = [];
    for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        const ct = Math.cos(theta), st = Math.sin(theta);
        pts.push(new THREE.Vector3(
            center.x + radius * (ct * u.x + st * v.x),
            center.y + radius * (ct * u.y + st * v.y),
            center.z + radius * (ct * u.z + st * v.z)
        ));
    }
    return pts;
}

function makeArcPoints(radius, axis, center, startDir, angleDeg, segments) {
    segments = segments || 32;
    const k = axis.clone().normalize();
    const d = startDir.clone().normalize();
    const angleRad = angleDeg * DEG2RAD;
    const kCrossD = new THREE.Vector3().crossVectors(k, d);
    const kDotD = k.dot(d);
    const pts = [];
    for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * angleRad;
        const cosT = Math.cos(theta), sinT = Math.sin(theta);
        const rotated = new THREE.Vector3()
            .copy(d).multiplyScalar(cosT)
            .addScaledVector(kCrossD, sinT)
            .addScaledVector(k, kDotD * (1 - cosT));
        pts.push(new THREE.Vector3(
            center.x + radius * rotated.x,
            center.y + radius * rotated.y,
            center.z + radius * rotated.z
        ));
    }
    return pts;
}

function addVizObject(obj) {
    scene.add(obj);
    orbitalVizObjects.push(obj);
}

function hideOrbitOverlays() {
    if (orbitLine) orbitLine.visible = false;
    if (groundTrack) groundTrack.visible = false;
    if (pastOrbitLine) pastOrbitLine.visible = false;
    if (pastGroundTrack) pastGroundTrack.visible = false;
    if (trackingArrow) trackingArrow.visible = false;
    // Keep trackingHalo visible so the satellite stays highlighted
}

function showOrbitOverlays() {
    if (orbitLine) orbitLine.visible = true;
    if (groundTrack) groundTrack.visible = true;
    if (pastOrbitLine) pastOrbitLine.visible = true;
    if (pastGroundTrack) pastGroundTrack.visible = true;
    if (trackingArrow) trackingArrow.visible = true;
}

function clearOrbitalViz(skipFrameRestore) {
    for (const obj of orbitalVizObjects) {
        scene.remove(obj);
        obj.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
    }
    orbitalVizObjects = [];
    if (orbitalVizLabel) {
        orbitalVizLabel.remove();
        orbitalVizLabel = null;
    }
    vizLabelAnchor = null;
    for (const tag of vizTags) tag.el.remove();
    vizTags = [];
    $detailInc.classList.remove('viz-active');
    $detailRaan.classList.remove('viz-active');
    $detailAol.classList.remove('viz-active');
    $detailEcc.classList.remove('viz-active');
    // Clean up live-update state (AoL, lat, lon)
    _clearLiveVizObjects();
    if (orbitalVizMode) showOrbitOverlays();
    orbitalVizMode = null;

    // Cancel any in-progress viz camera animation to prevent jolts
    cameraAnim = null;

    // Restore previous reference frame if auto-switched for viz
    if (!skipFrameRestore && _frameBeforeViz !== null) {
        setReferenceFrame(_frameBeforeViz);
        _frameBeforeViz = null;
    }
}

function addVizTag(text, anchor, color) {
    const el = document.createElement('div');
    el.className = 'viz-tag';
    el.textContent = text;
    el.style.color = color || '#e0e8f0';
    document.body.appendChild(el);
    vizTags.push({ el, anchor: anchor.clone() });
    requestAnimationFrame(() => el.classList.add('visible'));
}

function createEquatorialRing(orbitRadius) {
    const eqNormal = new THREE.Vector3(0, 1, 0);
    const eqCenter = new THREE.Vector3(0, 0, 0);
    const ringPts = makeRingPoints(orbitRadius, eqNormal, eqCenter, 96);
    const ringGeo = new THREE.BufferGeometry().setFromPoints(ringPts);
    const ringMat = new THREE.LineBasicMaterial({
        color: 0x00e5ff, transparent: true, opacity: 0.6, depthWrite: false
    });
    addVizObject(new THREE.Line(ringGeo, ringMat));

    // Shaded equatorial disc
    const discGeo = new THREE.RingGeometry(EARTH_RADIUS * 1.02, orbitRadius, 64);
    const discMat = new THREE.MeshBasicMaterial({
        color: 0x00e5ff, transparent: true, opacity: 0.12,
        side: THREE.DoubleSide, depthWrite: false
    });
    const disc = new THREE.Mesh(discGeo, discMat);
    disc.rotation.x = -Math.PI / 2;
    addVizObject(disc);
}

function createOrbitalRing(orbitRadius, orbNormal) {
    const center = new THREE.Vector3(0, 0, 0);
    const ringPts = makeRingPoints(orbitRadius, orbNormal, center, 96);
    const ringGeo = new THREE.BufferGeometry().setFromPoints(ringPts);
    const ringMat = new THREE.LineBasicMaterial({
        color: 0xff6b35, transparent: true, opacity: 0.6, depthWrite: false
    });
    addVizObject(new THREE.Line(ringGeo, ringMat));

    // Shaded orbital disc
    const discGeo = new THREE.RingGeometry(EARTH_RADIUS * 1.02, orbitRadius, 64);
    const discMat = new THREE.MeshBasicMaterial({
        color: 0xff6b35, transparent: true, opacity: 0.12,
        side: THREE.DoubleSide, depthWrite: false
    });
    const disc = new THREE.Mesh(discGeo, discMat);
    // Orient disc to match orbital plane normal
    const up = new THREE.Vector3(0, 0, 1); // RingGeometry default normal
    const quat = new THREE.Quaternion().setFromUnitVectors(up, orbNormal.clone().normalize());
    disc.quaternion.copy(quat);
    addVizObject(disc);
}

function createLineOfNodes(anDir, orbitRadius) {
    const len = orbitRadius * 1.15;
    const pts = [anDir.clone().multiplyScalar(-len), anDir.clone().multiplyScalar(len)];
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineDashedMaterial({
        color: 0x6a7b90, transparent: true, opacity: 0.5,
        dashSize: 0.2, gapSize: 0.1, depthWrite: false
    });
    const line = new THREE.Line(geo, mat);
    line.computeLineDistances();
    addVizObject(line);
}

function createArcTicks(radius, axis, center, startDir, angleDeg, tickInterval) {
    tickInterval = tickInterval || 10;
    const k = axis.clone().normalize();
    const d = startDir.clone().normalize();
    const kCrossD = new THREE.Vector3().crossVectors(k, d);
    const kDotD = k.dot(d);
    const pts = [];
    for (let deg = tickInterval; deg < angleDeg; deg += tickInterval) {
        const theta = deg * DEG2RAD;
        const cosT = Math.cos(theta), sinT = Math.sin(theta);
        const rotated = new THREE.Vector3()
            .copy(d).multiplyScalar(cosT)
            .addScaledVector(kCrossD, sinT)
            .addScaledVector(k, kDotD * (1 - cosT));
        pts.push(rotated.clone().multiplyScalar(radius * 0.92).add(center));
        pts.push(rotated.clone().multiplyScalar(radius * 1.08).add(center));
    }
    if (pts.length < 2) return;
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({
        color: 0x00e676, transparent: true, opacity: 0.5, depthWrite: false
    });
    addVizObject(new THREE.LineSegments(geo, mat));
}

function createVizArrow(from, to, color) {
    const dir = new THREE.Vector3().subVectors(to, from);
    const len = dir.length();
    if (len < 0.001) return;
    dir.normalize();
    const shaftLen = len * 0.82;
    const headLen = len * 0.18;
    const shaftGeo = new THREE.CylinderGeometry(0.05, 0.05, shaftLen, 8);
    const headGeo = new THREE.ConeGeometry(0.14, headLen, 10);
    const mat = new THREE.MeshBasicMaterial({ color });
    const shaft = new THREE.Mesh(shaftGeo, mat);
    shaft.position.y = shaftLen / 2;
    const head = new THREE.Mesh(headGeo, mat.clone());
    head.position.y = shaftLen + headLen / 2;
    const group = new THREE.Group();
    group.add(shaft);
    group.add(head);
    const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
    group.quaternion.copy(quat);
    group.position.copy(from);
    addVizObject(group);
}

function createBoldArc(arcPts, color) {
    if (arcPts.length < 3) return;
    // Arrowhead dimensions (matching createVizArrow style)
    const headLen = 0.25;
    const headRadius = 0.14;
    const tubeRadius = 0.05;

    // Shorten tube so it ends at the base of the arrowhead
    const endPt = arcPts[arcPts.length - 1];
    const prevPt = arcPts[arcPts.length - 2];
    const tangent = new THREE.Vector3().subVectors(endPt, prevPt).normalize();
    const headBase = endPt.clone().addScaledVector(tangent, -headLen);

    // Trim arc points: replace the last point with the head base
    const trimmed = arcPts.slice(0, -1);
    trimmed.push(headBase);

    // Tube shaft
    const curve = new THREE.CatmullRomCurve3(trimmed);
    const tubeGeo = new THREE.TubeGeometry(curve, trimmed.length * 2, tubeRadius, 8, false);
    const tubeMat = new THREE.MeshBasicMaterial({ color });
    addVizObject(new THREE.Mesh(tubeGeo, tubeMat));

    // Arrowhead — tip at end of measurement
    const headGeo = new THREE.ConeGeometry(headRadius, headLen, 10);
    const headMat = new THREE.MeshBasicMaterial({ color });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.copy(endPt).addScaledVector(tangent, -headLen / 2);
    const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), tangent);
    head.quaternion.copy(quat);
    addVizObject(head);
}

function createVizLabel(title, subtitle) {
    if (orbitalVizLabel) orbitalVizLabel.remove();
    const el = document.createElement('div');
    el.className = 'orbital-viz-label';
    el.innerHTML = '<div class="viz-title">' + title + '</div><div class="viz-subtitle">' + subtitle + '</div>';
    document.body.appendChild(el);
    orbitalVizLabel = el;
    requestAnimationFrame(() => el.classList.add('visible'));
}

function updateOrbitalVizLabel() {
    const w = window.innerWidth, h = window.innerHeight;
    if (orbitalVizLabel && vizLabelAnchor) {
        _projectedVec.copy(vizLabelAnchor).project(camera);
        if (_projectedVec.z > 1) {
            orbitalVizLabel.classList.remove('visible');
        } else {
            orbitalVizLabel.classList.add('visible');
            orbitalVizLabel.style.left = ((_projectedVec.x * 0.5 + 0.5) * w) + 'px';
            orbitalVizLabel.style.top = ((-_projectedVec.y * 0.5 + 0.5) * h - 12) + 'px';
        }
    }
    for (const tag of vizTags) {
        _projectedVec.copy(tag.anchor).project(camera);
        if (_projectedVec.z > 1) {
            tag.el.classList.remove('visible');
        } else {
            tag.el.classList.add('visible');
            tag.el.style.left = ((_projectedVec.x * 0.5 + 0.5) * w) + 'px';
            tag.el.style.top = ((-_projectedVec.y * 0.5 + 0.5) * h) + 'px';
        }
    }
}

function animateCameraToVizView(endLatRad, endLonRad, endDist) {
    const cp = camera.position;
    const currentDist = cp.length();
    const startLat = Math.asin(cp.y / currentDist);
    const startLon = Math.atan2(cp.z, cp.x);
    let dLon = endLonRad - startLon;
    if (dLon > Math.PI) dLon -= 2 * Math.PI;
    if (dLon < -Math.PI) dLon += 2 * Math.PI;
    const totalAngle = Math.abs(dLon) + Math.abs(endLatRad - startLat);
    const ratio = totalAngle / Math.PI;
    const duration = 1.0 + ratio * ratio * 3.0;
    cameraAnim = {
        startLat, startLon, endLat: endLatRad, dLon,
        startDist: currentDist, endDist: endDist,
        startTarget: controls.target.clone(),
        endTarget: new THREE.Vector3(0, 0, 0),
        progress: 0, duration
    };
}

function showInclinationViz(satIndex) {
    clearOrbitalViz(true);
    if (satIndex < 0 || satIndex >= satellites.length) return;
    // Auto-switch to ECI — inclination is defined in inertial frame
    if (referenceFrame !== 'eci') {
        _frameBeforeViz = referenceFrame;
        setReferenceFrame('eci');
    }
    hideOrbitOverlays();
    const sat = satellites[satIndex];
    const incRad = sat.satrec.inclo;
    const raanRad = sat.satrec.nodeo;
    const incDeg = incRad * RAD2DEG;
    vizGmst = 0;
    const orbitRadius = EARTH_RADIUS + (sat.alt || 1200) * SAT_SCALE;

    // Ascending node direction in ECI → scene
    const anScene = eciToScene(Math.cos(raanRad), Math.sin(raanRad), 0, vizGmst).normalize();

    // Orbital plane normal in ECI → scene
    const si = Math.sin(incRad), ci = Math.cos(incRad);
    const sO = Math.sin(raanRad), cO = Math.cos(raanRad);
    const normalScene = eciToScene(si * sO, -si * cO, ci, vizGmst).normalize();

    // Equatorial ring + disc
    createEquatorialRing(orbitRadius);

    // Orbital ring
    createOrbitalRing(orbitRadius, normalScene);

    // Line of nodes
    createLineOfNodes(anScene, orbitRadius);

    // Forward directions at ascending node
    const eqNormal = new THREE.Vector3(0, 1, 0);
    const eqForward = new THREE.Vector3().crossVectors(eqNormal, anScene).normalize();
    const orbForward = new THREE.Vector3().crossVectors(normalScene, anScene).normalize();

    // Reference arms from ascending node along each plane (frames the angle)
    const anPoint = anScene.clone().multiplyScalar(orbitRadius);
    const armLen = orbitRadius * 0.55;
    // Equatorial arm (cyan)
    const eqArmEnd = anPoint.clone().addScaledVector(eqForward, armLen);
    const eqArmGeo = new THREE.BufferGeometry().setFromPoints([anPoint.clone(), eqArmEnd]);
    const eqArmMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.7, depthWrite: false });
    addVizObject(new THREE.Line(eqArmGeo, eqArmMat));
    // Orbital arm (orange)
    const orbArmEnd = anPoint.clone().addScaledVector(orbForward, armLen);
    const orbArmGeo = new THREE.BufferGeometry().setFromPoints([anPoint.clone(), orbArmEnd]);
    const orbArmMat = new THREE.LineBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.7, depthWrite: false });
    addVizObject(new THREE.Line(orbArmGeo, orbArmMat));

    // Inclination measurement arc (bold 3D tube + arrowhead)
    const arcRadius = armLen * 0.6;
    const arcPts = makeArcPoints(arcRadius, anScene, anPoint, eqForward, incDeg, 48);
    createBoldArc(arcPts, 0x00e676);

    // Tick marks every 10°
    createArcTicks(arcRadius, anScene, anPoint, eqForward, incDeg, 10);

    // Label anchor at arc midpoint, offset outward
    const midTheta = (incDeg / 2) * DEG2RAD;
    const kCrossD = new THREE.Vector3().crossVectors(anScene.clone().normalize(), eqForward);
    const midDir = new THREE.Vector3()
        .copy(eqForward).multiplyScalar(Math.cos(midTheta))
        .addScaledVector(kCrossD, Math.sin(midTheta));
    vizLabelAnchor = anPoint.clone().addScaledVector(midDir.normalize(), arcRadius * 1.6);

    createVizLabel('INCLINATION', incDeg.toFixed(2) + '\u00B0');

    // Feature labels
    addVizTag('EQUATORIAL PLANE', anScene.clone().negate().multiplyScalar(orbitRadius * 1.06), '#00e5ff');
    addVizTag('ORBITAL PLANE', anScene.clone().negate().multiplyScalar(orbitRadius * 0.5).addScaledVector(orbForward, orbitRadius * 0.8), '#ff6b35');
    addVizTag('ASCENDING NODE', anPoint.clone().addScaledVector(anScene, 0.4), '#6a7b90');
    addVizTag('LINE OF NODES', anScene.clone().multiplyScalar(-orbitRadius * 0.9), '#6a7b90');

    orbitalVizMode = 'inclination';
    $detailInc.classList.add('viz-active');

    // Camera: position toward the arc midpoint so the arc's concave side faces the camera
    const camTarget = vizLabelAnchor.clone().normalize();
    const endLat = Math.asin(camTarget.y);
    const endLon = Math.atan2(camTarget.z, camTarget.x);
    animateCameraToVizView(endLat, endLon, 20);
}

function showRaanViz(satIndex) {
    clearOrbitalViz(true);
    if (satIndex < 0 || satIndex >= satellites.length) return;
    // Auto-switch to ECI — RAAN is defined in inertial frame
    if (referenceFrame !== 'eci') {
        _frameBeforeViz = referenceFrame;
        setReferenceFrame('eci');
    }
    hideOrbitOverlays();
    const sat = satellites[satIndex];
    const incRad = sat.satrec.inclo;
    const raanRad = sat.satrec.nodeo;
    const raanDeg = ((raanRad * RAD2DEG) % 360 + 360) % 360;
    vizGmst = 0;
    const orbitRadius = EARTH_RADIUS + (sat.alt || 1200) * SAT_SCALE;

    // Ascending node direction in scene
    const anScene = eciToScene(Math.cos(raanRad), Math.sin(raanRad), 0, vizGmst).normalize();

    // Orbital plane normal in scene
    const si = Math.sin(incRad), ci = Math.cos(incRad);
    const sO = Math.sin(raanRad), cO = Math.cos(raanRad);
    const normalScene = eciToScene(si * sO, -si * cO, ci, vizGmst).normalize();

    // Vernal equinox direction in scene
    const veScene = eciToScene(1, 0, 0, vizGmst).normalize();

    // Equatorial ring + disc
    createEquatorialRing(orbitRadius);

    // Orbital ring
    createOrbitalRing(orbitRadius, normalScene);

    // Vernal equinox 3D arrow
    const arrowLen = orbitRadius * 1.2;
    createVizArrow(new THREE.Vector3(0, 0, 0), veScene.clone().multiplyScalar(arrowLen), 0x00e5ff);

    // Ascending node marker (orange sphere)
    const anPoint = anScene.clone().multiplyScalar(orbitRadius);
    const markerGeo = new THREE.SphereGeometry(0.18, 16, 16);
    const markerMat = new THREE.MeshBasicMaterial({ color: 0xff6b35 });
    const marker = new THREE.Mesh(markerGeo, markerMat);
    marker.position.copy(anPoint);
    addVizObject(marker);

    // Reference arm from origin to ascending node (orange, solid)
    const anArmGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), anPoint.clone()]);
    const anArmMat = new THREE.LineBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.7, depthWrite: false });
    addVizObject(new THREE.Line(anArmGeo, anArmMat));

    // Reference arm from origin along vernal equinox (cyan, solid)
    const veArmEnd = veScene.clone().multiplyScalar(orbitRadius);
    const veArmGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), veArmEnd]);
    const veArmMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.7, depthWrite: false });
    addVizObject(new THREE.Line(veArmGeo, veArmMat));

    // RAAN measurement arc (bold 3D tube + arrowhead) — above Earth surface
    const arcRadius = EARTH_RADIUS * 1.12;
    const eqUp = new THREE.Vector3(0, 1, 0);
    const arcPts = makeArcPoints(arcRadius, eqUp, new THREE.Vector3(0, 0, 0), veScene, raanDeg, 64);
    createBoldArc(arcPts, 0x00e676);

    // Tick marks every 30°
    createArcTicks(arcRadius, eqUp, new THREE.Vector3(0, 0, 0), veScene, raanDeg, 30);

    // Label anchor at arc midpoint
    const midTheta = (raanDeg / 2) * DEG2RAD;
    const vePerp = new THREE.Vector3().crossVectors(eqUp, veScene);
    const midDir = new THREE.Vector3()
        .copy(veScene).multiplyScalar(Math.cos(midTheta))
        .addScaledVector(vePerp, Math.sin(midTheta));
    vizLabelAnchor = midDir.normalize().multiplyScalar(arcRadius * 1.3);
    vizLabelAnchor.y += 0.5;

    createVizLabel('RAAN', raanDeg.toFixed(2) + '\u00B0');

    // Feature labels
    addVizTag('VERNAL EQUINOX  \u2648', veScene.clone().multiplyScalar(arrowLen * 1.08), '#00e5ff');
    addVizTag('ASCENDING NODE', anPoint.clone().addScaledVector(anScene, 0.4), '#ff6b35');
    addVizTag('EQUATORIAL PLANE', veScene.clone().negate().multiplyScalar(orbitRadius * 1.06), '#00e5ff');
    addVizTag('ORBITAL PLANE', anScene.clone().multiplyScalar(orbitRadius * 0.5).addScaledVector(new THREE.Vector3().crossVectors(normalScene, anScene).normalize(), orbitRadius * 0.8), '#ff6b35');

    orbitalVizMode = 'raan';
    $detailRaan.classList.add('viz-active');

    // Camera: directly above, looking straight down on Earth
    const endLat = 89 * DEG2RAD;
    const endLon = Math.atan2(midDir.z, midDir.x);
    animateCameraToVizView(endLat, endLon, 20);
}

// Live viz dynamic state — updated every frame (used by AoL, lat, lon)
let _liveVizState = null;

function _clearLiveVizObjects() {
    if (!_liveVizState) return;
    const st = _liveVizState;
    for (const obj of (st.dynamicObjects || [])) {
        scene.remove(obj);
        obj.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
    }
    for (const el of (st.dynamicTags || [])) {
        vizTags = vizTags.filter(t => t.el !== el);
        el.remove();
    }
    _liveVizState = null;
}

function _removeDynamic() {
    if (!_liveVizState) return;
    const st = _liveVizState;
    for (const obj of st.dynamicObjects) {
        scene.remove(obj);
        obj.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
    }
    st.dynamicObjects = [];
    for (const el of st.dynamicTags) {
        vizTags = vizTags.filter(t => t.el !== el);
        el.remove();
    }
    st.dynamicTags = [];
}

function _addDynObj(obj) {
    scene.add(obj);
    _liveVizState.dynamicObjects.push(obj);
}

function _addDynTag(text, anchor, color) {
    const el = document.createElement('div');
    el.className = 'viz-tag';
    el.textContent = text;
    el.style.color = color;
    document.body.appendChild(el);
    requestAnimationFrame(() => el.classList.add('visible'));
    vizTags.push({ el, anchor });
    _liveVizState.dynamicTags.push(el);
}

function showAolViz(satIndex) {
    clearOrbitalViz(true);
    if (satIndex < 0 || satIndex >= satellites.length) return;
    if (referenceFrame !== 'eci') {
        _frameBeforeViz = referenceFrame;
        setReferenceFrame('eci');
    }
    hideOrbitOverlays();
    const sat = satellites[satIndex];
    const incRad = sat.satrec.inclo;
    const raanRad = sat.satrec.nodeo;
    vizGmst = 0;
    const orbitRadius = EARTH_RADIUS + (sat.alt || 1200) * SAT_SCALE;

    const anScene = eciToScene(Math.cos(raanRad), Math.sin(raanRad), 0, vizGmst).normalize();
    const si = Math.sin(incRad), ci = Math.cos(incRad);
    const sO = Math.sin(raanRad), cO = Math.cos(raanRad);
    const normalScene = eciToScene(si * sO, -si * cO, ci, vizGmst).normalize();

    createEquatorialRing(orbitRadius);
    createOrbitalRing(orbitRadius, normalScene);
    createLineOfNodes(anScene, orbitRadius);

    // Ascending node point (static)
    const anPoint = anScene.clone().multiplyScalar(orbitRadius);
    const markerGeo = new THREE.SphereGeometry(0.18, 16, 16);
    const markerMat = new THREE.MeshBasicMaterial({ color: 0xff6b35 });
    const marker = new THREE.Mesh(markerGeo, markerMat);
    marker.position.copy(anPoint);
    addVizObject(marker);

    // Ascending node arm (static)
    const anArmGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), anPoint.clone()]);
    const anArmMat = new THREE.LineBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.7, depthWrite: false });
    addVizObject(new THREE.Line(anArmGeo, anArmMat));

    const orbForward = new THREE.Vector3().crossVectors(normalScene, anScene).normalize();
    addVizTag('ASCENDING NODE', anPoint.clone().addScaledVector(anScene, 0.4), '#ff6b35');
    addVizTag('ORBITAL PLANE', anScene.clone().negate().multiplyScalar(orbitRadius * 0.5).addScaledVector(orbForward, orbitRadius * 0.8), '#ff6b35');

    _liveVizState = {
        mode: 'aol', satIndex, incRad, raanRad, orbitRadius,
        anScene: anScene.clone(), normalScene: normalScene.clone(),
        arcRadius: orbitRadius * 0.85,
        dynamicObjects: [], dynamicTags: [],
    };
    updateAolViz();

    orbitalVizMode = 'aol';
    $detailAol.classList.add('viz-active');

    // Camera: exact same position as inclination camera
    const incDeg = incRad * RAD2DEG;
    const eqNormal = new THREE.Vector3(0, 1, 0);
    const eqForward = new THREE.Vector3().crossVectors(eqNormal, anScene).normalize();
    const armLen = orbitRadius * 0.55;
    const arcR = armLen * 0.6;
    const midTheta = (incDeg / 2) * DEG2RAD;
    const kCrossD = new THREE.Vector3().crossVectors(anScene.clone().normalize(), eqForward);
    const midDir = new THREE.Vector3()
        .copy(eqForward).multiplyScalar(Math.cos(midTheta))
        .addScaledVector(kCrossD, Math.sin(midTheta));
    const camTarget = anPoint.clone().addScaledVector(midDir.normalize(), arcR * 1.6).normalize();
    animateCameraToVizView(Math.asin(camTarget.y), Math.atan2(camTarget.z, camTarget.x), 20);
}

function updateAolViz() {
    if (!_liveVizState || _liveVizState.mode !== 'aol') return;
    const st = _liveVizState;
    const sat = satellites[st.satIndex];
    if (!sat || sat.eciX === undefined) return;

    const nx = Math.cos(st.raanRad), ny = Math.sin(st.raanRad);
    const px = sat.eciX * nx + sat.eciY * ny;
    const py = (-sat.eciX * ny + sat.eciY * nx) * Math.cos(st.incRad) + sat.eciZ * Math.sin(st.incRad);
    const aolDeg = ((Math.atan2(py, px) * RAD2DEG) % 360 + 360) % 360;
    const satScene = eciToScene(sat.eciX, sat.eciY, sat.eciZ, vizGmst).normalize().multiplyScalar(st.orbitRadius);

    _removeDynamic();

    // Satellite marker
    const smGeo = new THREE.SphereGeometry(0.22, 16, 16);
    const smMat = new THREE.MeshBasicMaterial({ color: 0x00e676 });
    const sm = new THREE.Mesh(smGeo, smMat);
    sm.position.copy(satScene);
    _addDynObj(sm);

    // Sat arm
    const armGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), satScene.clone()]);
    const armMat = new THREE.LineBasicMaterial({ color: 0x00e676, transparent: true, opacity: 0.7, depthWrite: false });
    _addDynObj(new THREE.Line(armGeo, armMat));

    // Arc + ticks
    const arcGroup = new THREE.Group();
    const arcPts = makeArcPoints(st.arcRadius, st.normalScene, new THREE.Vector3(0,0,0), st.anScene, aolDeg, 64);
    if (arcPts.length >= 2) {
        const curve = new THREE.CatmullRomCurve3(arcPts);
        const tubeGeo = new THREE.TubeGeometry(curve, arcPts.length, 0.06, 8, false);
        const tubeMat = new THREE.MeshBasicMaterial({ color: 0x00e676, transparent: true, opacity: 0.9, depthWrite: false });
        arcGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
    }
    if (aolDeg > 30) {
        const k = st.normalScene.clone().normalize();
        const d = st.anScene.clone().normalize();
        const kCrossD = new THREE.Vector3().crossVectors(k, d);
        const kDotD = k.dot(d);
        const numTicks = Math.floor(aolDeg / 30);
        for (let t = 1; t <= numTicks; t++) {
            const theta = (t * 30) * DEG2RAD;
            const cosT = Math.cos(theta), sinT = Math.sin(theta);
            const rotated = new THREE.Vector3().copy(d).multiplyScalar(cosT).addScaledVector(kCrossD, sinT).addScaledVector(k, kDotD * (1 - cosT));
            const inner = rotated.clone().multiplyScalar(st.arcRadius * 0.92);
            const outer = rotated.clone().multiplyScalar(st.arcRadius * 1.08);
            const tickGeo = new THREE.BufferGeometry().setFromPoints([inner, outer]);
            const tickMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3, depthWrite: false });
            arcGroup.add(new THREE.Line(tickGeo, tickMat));
        }
    }
    _addDynObj(arcGroup);

    _addDynTag('SATELLITE', satScene.clone().addScaledVector(satScene.clone().normalize(), 0.4), '#00e676');

    // Label
    const midTheta = (aolDeg / 2) * DEG2RAD;
    const kCross = new THREE.Vector3().crossVectors(st.normalScene.clone().normalize(), st.anScene);
    const midDir = new THREE.Vector3().copy(st.anScene).multiplyScalar(Math.cos(midTheta)).addScaledVector(kCross, Math.sin(midTheta));
    vizLabelAnchor = midDir.normalize().multiplyScalar(st.arcRadius * 1.4);
    if (orbitalVizLabel) {
        const sub = orbitalVizLabel.querySelector('.viz-subtitle');
        if (sub) sub.textContent = aolDeg.toFixed(2) + '\u00B0';
    } else {
        createVizLabel('ARG OF LATITUDE', aolDeg.toFixed(2) + '\u00B0');
    }
}

function showEccentricityViz(satIndex) {
    clearOrbitalViz(true);
    if (satIndex < 0 || satIndex >= satellites.length) return;
    if (referenceFrame !== 'eci') {
        _frameBeforeViz = referenceFrame;
        setReferenceFrame('eci');
    }
    hideOrbitOverlays();
    const sat = satellites[satIndex];
    vizGmst = 0;

    // Compute osculating orbital elements (snapshot for static geometry)
    const mu_km = 398600.4418;
    const rx = sat.eciX, ry = sat.eciY, rz = sat.eciZ;
    const vx = sat.eciVx, vy = sat.eciVy, vz = sat.eciVz;
    const rMag = Math.sqrt(rx*rx + ry*ry + rz*rz);
    const vMag = Math.sqrt(vx*vx + vy*vy + vz*vz);
    const hx = ry*vz - rz*vy, hy = rz*vx - rx*vz, hz = rx*vy - ry*vx;
    const hMag = Math.sqrt(hx*hx + hy*hy + hz*hz);
    const vxh_x = vy*hz - vz*hy, vxh_y = vz*hx - vx*hz, vxh_z = vx*hy - vy*hx;
    const ex = vxh_x/mu_km - rx/rMag, ey = vxh_y/mu_km - ry/rMag, ez = vxh_z/mu_km - rz/rMag;
    const ecc = Math.sqrt(ex*ex + ey*ey + ez*ez);
    const a_km = 1 / (2/rMag - vMag*vMag/mu_km);
    const a = a_km * SAT_SCALE;
    const incRad = Math.acos(Math.max(-1, Math.min(1, hz / hMag)));
    const nnx = -hy, nny = hx, nMag = Math.sqrt(nnx*nnx + nny*nny);
    let raanRad = 0;
    if (nMag > 1e-10) { raanRad = Math.acos(Math.max(-1, Math.min(1, nnx / nMag))); if (nny < 0) raanRad = 2*Math.PI - raanRad; }
    let argpRad = 0;
    if (nMag > 1e-10 && ecc > 1e-10) { const ndote = (nnx*ex + nny*ey) / (nMag * ecc); argpRad = Math.acos(Math.max(-1, Math.min(1, ndote))); if (ez < 0) argpRad = 2*Math.PI - argpRad; }

    const anScene = eciToScene(Math.cos(raanRad), Math.sin(raanRad), 0, vizGmst).normalize();
    const si = Math.sin(incRad), ci = Math.cos(incRad), sO = Math.sin(raanRad), cO = Math.cos(raanRad);
    const normalScene = eciToScene(si * sO, -si * cO, ci, vizGmst).normalize();
    const orbForward = new THREE.Vector3().crossVectors(normalScene, anScene).normalize();
    const perigeeDir = new THREE.Vector3().copy(anScene).multiplyScalar(Math.cos(argpRad)).addScaledVector(orbForward, Math.sin(argpRad)).normalize();
    const apogeeDir = perigeeDir.clone().negate();

    // Static elliptical orbit
    const ellipsePts = [];
    const perpDir = new THREE.Vector3().crossVectors(normalScene, perigeeDir).normalize();
    for (let i = 0; i <= 128; i++) {
        const theta = (i / 128) * 2 * Math.PI;
        const slr = a * (1 - ecc * ecc);
        const rr = slr / (1 + ecc * Math.cos(theta));
        ellipsePts.push(new THREE.Vector3()
            .addScaledVector(perigeeDir, rr * Math.cos(theta))
            .addScaledVector(perpDir, rr * Math.sin(theta)));
    }
    addVizObject(new THREE.Line(new THREE.BufferGeometry().setFromPoints(ellipsePts),
        new THREE.LineBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.8, depthWrite: false })));

    // Earth marker
    addVizObject(new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), new THREE.MeshBasicMaterial({ color: 0x00e5ff })));

    // Static perigee/apogee markers
    const rPerigee = a * (1 - ecc);
    const perigeePos = perigeeDir.clone().multiplyScalar(rPerigee);
    const periMarker = new THREE.Mesh(new THREE.SphereGeometry(0.18, 16, 16), new THREE.MeshBasicMaterial({ color: 0x00e676 }));
    periMarker.position.copy(perigeePos);
    addVizObject(periMarker);

    const rApogee = a * (1 + ecc);
    const apogeePos = apogeeDir.clone().multiplyScalar(rApogee);
    const apoMarker = new THREE.Mesh(new THREE.SphereGeometry(0.18, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff6b35 }));
    apoMarker.position.copy(apogeePos);
    addVizObject(apoMarker);

    // Axis line
    addVizObject(new THREE.Line(new THREE.BufferGeometry().setFromPoints([perigeePos.clone(), apogeePos.clone()]),
        new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, depthWrite: false })));

    // Circular reference orbit
    const circPts = [];
    for (let i = 0; i <= 128; i++) {
        const theta = (i / 128) * 2 * Math.PI;
        circPts.push(new THREE.Vector3().addScaledVector(perigeeDir, a * Math.cos(theta)).addScaledVector(perpDir, a * Math.sin(theta)));
    }
    const circLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(circPts),
        new THREE.LineDashedMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.3, dashSize: 0.3, gapSize: 0.2, depthWrite: false }));
    circLine.computeLineDistances();
    addVizObject(circLine);

    // Labels
    vizLabelAnchor = perigeeDir.clone().multiplyScalar(rPerigee * 0.5).addScaledVector(normalScene, 1.5);
    createVizLabel('ECCENTRICITY', ecc.toFixed(6));
    addVizTag('PERIGEE', perigeePos.clone().addScaledVector(perigeeDir, 0.5), '#00e676');
    addVizTag('APOGEE', apogeePos.clone().addScaledVector(apogeeDir, 0.5), '#ff6b35');
    addVizTag('EARTH (FOCUS)', new THREE.Vector3(0, -0.6, 0), '#00e5ff');

    // Altitude tags (text updated live)
    const periAltEl = document.createElement('div');
    periAltEl.className = 'viz-tag'; periAltEl.style.color = '#6a7b90';
    document.body.appendChild(periAltEl);
    requestAnimationFrame(() => periAltEl.classList.add('visible'));
    const periAltTag = { el: periAltEl, anchor: perigeePos.clone().addScaledVector(perigeeDir, -0.8) };
    vizTags.push(periAltTag);

    const apoAltEl = document.createElement('div');
    apoAltEl.className = 'viz-tag'; apoAltEl.style.color = '#6a7b90';
    document.body.appendChild(apoAltEl);
    requestAnimationFrame(() => apoAltEl.classList.add('visible'));
    const apoAltTag = { el: apoAltEl, anchor: apogeePos.clone().addScaledVector(apogeeDir, -0.8) };
    vizTags.push(apoAltTag);

    _liveVizState = { satIndex, dynamicObjects: [], dynamicTags: [], periAltTag, apoAltTag };
    updateEccentricityViz();

    orbitalVizMode = 'eccentricity';
    $detailEcc.classList.add('viz-active');

    // Camera: face-on to orbital plane
    const camTarget = normalScene.clone();
    const camDir = camera.position.clone().normalize();
    if (camTarget.dot(camDir) < 0) camTarget.negate();
    animateCameraToVizView(Math.asin(camTarget.y), Math.atan2(camTarget.z, camTarget.x), 22);
}

function updateEccentricityViz() {
    if (!_liveVizState || orbitalVizMode !== 'eccentricity') return;
    const sat = satellites[_liveVizState.satIndex];
    if (!sat || sat.eciX === undefined || sat.eciVx === undefined) return;

    // Compute current osculating a and e for altitude labels
    const mu = 398600.4418;
    const rx = sat.eciX, ry = sat.eciY, rz = sat.eciZ;
    const vx = sat.eciVx, vy = sat.eciVy, vz = sat.eciVz;
    const r = Math.sqrt(rx*rx + ry*ry + rz*rz);
    const v2 = vx*vx + vy*vy + vz*vz;
    const a = 1 / (2/r - v2/mu);
    const hx = ry*vz - rz*vy, hy = rz*vx - rx*vz, hz = rx*vy - ry*vx;
    const vxh_x = vy*hz - vz*hy, vxh_y = vz*hx - vx*hz, vxh_z = vx*hy - vy*hx;
    const ex = vxh_x/mu - rx/r, ey = vxh_y/mu - ry/r, ez = vxh_z/mu - rz/r;
    const ecc = Math.sqrt(ex*ex + ey*ey + ez*ez);

    // Fixed altitude labels using mean Earth radius (stable, shows orbital mechanics)
    const R_mean = 6371;
    const periAlt = a * (1 - ecc) - R_mean;
    const apoAlt = a * (1 + ecc) - R_mean;

    _liveVizState.periAltTag.el.textContent = Math.round(periAlt) + ' km';
    _liveVizState.apoAltTag.el.textContent = Math.round(apoAlt) + ' km';
}

// ============================================================
// TRACKING HALO
// ============================================================
function getHaloTexture(red) {
    if (!red && haloTexture) return haloTexture;
    const size = 128;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    if (red) {
        gradient.addColorStop(0, 'rgba(255,80,80,1)');
        gradient.addColorStop(0.15, 'rgba(255,50,50,0.8)');
        gradient.addColorStop(0.4, 'rgba(255,30,30,0.25)');
        gradient.addColorStop(1, 'rgba(255,0,0,0)');
    } else {
        gradient.addColorStop(0, 'rgba(255,140,50,1)');
        gradient.addColorStop(0.15, 'rgba(255,107,53,0.8)');
        gradient.addColorStop(0.4, 'rgba(255,80,30,0.25)');
        gradient.addColorStop(1, 'rgba(255,50,0,0)');
    }
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);
    const tex = new THREE.CanvasTexture(canvas);
    if (!red) haloTexture = tex;
    return tex;
}

function createTrackingHalo() {
    if (trackingHalo) removeTrackingHalo();
    const isExcluded = trackingIndex >= 0 && satellites[trackingIndex].excluded;
    const mat = new THREE.SpriteMaterial({
        map: getHaloTexture(isExcluded),
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        depthTest: false,
    });
    trackingHalo = new THREE.Sprite(mat);
    trackingHalo.scale.set(1.2, 1.2, 1);
    trackingHalo.renderOrder = 999;
    scene.add(trackingHalo);
}

function removeTrackingHalo() {
    if (!trackingHalo) return;
    scene.remove(trackingHalo);
    trackingHalo.material.map.dispose();
    trackingHalo.material.dispose();
    trackingHalo = null;
}

function updateTrackingHalo() {
    if (trackingIndex < 0 || !trackingHalo) return;
    const sat = satellites[trackingIndex];
    // Offset slightly toward camera to prevent z-fighting with sat point
    _satPos.set(sat.x, sat.y, sat.z);
    _toCamera.copy(camera.position).sub(_satPos).normalize().multiplyScalar(0.05);
    trackingHalo.position.copy(_satPos.add(_toCamera));
}

function createTrackingArrow() {
    if (trackingArrow) return;
    const shaftGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.35, 8);
    const headGeo = new THREE.ConeGeometry(0.035, 0.1, 8);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.55 });
    const shaft = new THREE.Mesh(shaftGeo, mat);
    shaft.position.y = 0.175;
    const head = new THREE.Mesh(headGeo, mat.clone());
    head.position.y = 0.45;
    trackingArrow = new THREE.Group();
    trackingArrow.add(shaft);
    trackingArrow.add(head);
    scene.add(trackingArrow);
}

function removeTrackingArrow() {
    if (!trackingArrow) return;
    scene.remove(trackingArrow);
    trackingArrow.traverse(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
    });
    trackingArrow = null;
}

function updateTrackingArrow() {
    if (trackingIndex < 0 || !trackingArrow) return;
    const sat = satellites[trackingIndex];
    _satPos.set(sat.x, sat.y, sat.z);

    // Compute velocity direction from previous/current world position (cached per frame)
    if (sat._prevX !== undefined) {
        _velDir.set(sat.x - sat._prevX, sat.y - sat._prevY, sat.z - sat._prevZ);
        if (_velDir.lengthSq() > 1e-12) {
            _velDir.normalize();
            // Position arrow ahead of the satellite along its velocity
            _arrowOrigin.copy(_velDir).multiplyScalar(0.3).add(_satPos);
            trackingArrow.position.copy(_arrowOrigin);
            // Orient arrow along velocity direction
            _quatTemp.setFromUnitVectors(_upVec, _velDir);
            trackingArrow.quaternion.copy(_quatTemp);
        }
    }
}

// ============================================================
// UI: SATELLITE LIST
// ============================================================
function _createFolder(id, label, count, isSub, accentClass) {
    const wrap = document.createElement('div');
    wrap.className = 'folder' + (isSub ? ' folder-sub' : '');
    wrap.dataset.folderId = id;
    const header = document.createElement('div');
    header.className = 'folder-header';
    header.innerHTML = `<span class="folder-chevron">&#9660;</span><span class="folder-label ${accentClass || ''}">${label}</span><span class="folder-count">${count}</span>`;
    const body = document.createElement('div');
    body.className = 'folder-body';
    wrap.appendChild(header);
    wrap.appendChild(body);
    header.addEventListener('click', () => wrap.classList.toggle('collapsed'));
    return wrap;
}

function buildSatList() {
    $satList.innerHTML = '';
    const frag = document.createDocumentFragment();

    // Search result count (hidden by default, shown during formation search)
    const resultCountDiv = document.createElement('div');
    resultCountDiv.className = 'search-result-count';
    resultCountDiv.id = 'search-result-count';
    frag.appendChild(resultCountDiv);

    // Count sats per plane for the plane items
    const planeCounts = {};
    for (const sat of satellites) {
        if (sat.plane > 0) planeCounts[sat.plane] = (planeCounts[sat.plane] || 0) + 1;
    }

    // Insert plane group items (hidden by default, shown during search)
    const unassignedCount = satellites.filter(s => s.plane === 0).length;
    if (unassignedCount > 0) {
        const div = document.createElement('div');
        div.className = 'plane-item';
        div.dataset.plane = '0';
        div.innerHTML = `
            <div class="plane-dot" style="background:#ff5252"></div>
            <div class="sat-info">
                <div class="sat-name">Unassigned</div>
                <div class="sat-meta">${unassignedCount} satellites</div>
            </div>
        `;
        div.addEventListener('click', () => selectPlane(0));
        frag.appendChild(div);
    }
    for (let p = 1; p <= 12; p++) {
        if (!planeCounts[p]) continue;
        const div = document.createElement('div');
        div.className = 'plane-item';
        div.dataset.plane = p;
        div.innerHTML = `
            <div class="plane-dot"></div>
            <div class="sat-info">
                <div class="sat-name">Plane ${p}</div>
                <div class="sat-meta">${planeCounts[p]} satellites</div>
            </div>
        `;
        div.addEventListener('click', () => selectPlane(p));
        frag.appendChild(div);
    }

    // ONEWEB folder (collapsed by default)
    const onewebFolder = _createFolder('oneweb', 'ONEWEB', satellites.length, false, 'accent-blue');
    onewebFolder.classList.add('collapsed');
    _folderRefs.oneweb = onewebFolder;
    const onewebBody = onewebFolder.querySelector('.folder-body');

    // Group satellites by plane
    const satsByPlane = {};
    satellites.forEach((sat, i) => {
        const p = sat.plane || 0;
        if (!satsByPlane[p]) satsByPlane[p] = [];
        satsByPlane[p].push({ sat, index: i });
    });

    // Plane sub-folders inside ONEWEB
    _folderRefs.planes = {};

    // Unassigned plane (plane 0) if any
    if (satsByPlane[0] && satsByPlane[0].length > 0) {
        const planeFolder = _createFolder('plane-0', 'UNASSIGNED', satsByPlane[0].length, true, 'accent-red');
        planeFolder.classList.add('collapsed');
        _folderRefs.planes[0] = planeFolder;
        const planeBody = planeFolder.querySelector('.folder-body');
        // Add accent-red class support via inline style
        const planeLabel = planeFolder.querySelector('.folder-label');
        if (planeLabel) planeLabel.style.color = '#ff5252';
        satsByPlane[0].forEach(({ sat, index }) => {
            const div = document.createElement('div');
            div.className = 'sat-item';
            div.dataset.index = index;
            div.innerHTML = `
                <div class="sat-dot"></div>
                <div class="sat-info">
                    <div class="sat-name">${sat.name}</div>
                    <div class="sat-meta">ID ${sat.noradId} &middot; ${sat.inclination.toFixed(1)}&deg; inc</div>
                </div>
            `;
            div.addEventListener('click', () => selectSatellite(index));
            planeBody.appendChild(div);
        });
        onewebBody.appendChild(planeFolder);
    }

    // Planes 1-12
    for (let p = 1; p <= 12; p++) {
        if (!satsByPlane[p] || satsByPlane[p].length === 0) continue;
        const planeFolder = _createFolder('plane-' + p, 'PLANE ' + p, satsByPlane[p].length, true, 'accent-blue');
        planeFolder.classList.add('collapsed');
        _folderRefs.planes[p] = planeFolder;
        const planeBody = planeFolder.querySelector('.folder-body');
        satsByPlane[p].forEach(({ sat, index }) => {
            const div = document.createElement('div');
            div.className = 'sat-item';
            div.dataset.index = index;
            div.innerHTML = `
                <div class="sat-dot"></div>
                <div class="sat-info">
                    <div class="sat-name">${sat.name}</div>
                    <div class="sat-meta">ID ${sat.noradId} &middot; Plane ${p} &middot; ${sat.inclination.toFixed(1)}&deg; inc</div>
                </div>
            `;
            div.addEventListener('click', () => selectSatellite(index));
            planeBody.appendChild(div);
        });
        onewebBody.appendChild(planeFolder);
    }

    frag.appendChild(onewebFolder);

    // GEO folder (collapsed by default)
    const geoFolder = _createFolder('geo', 'GEO', geoSatellites.length, false, 'accent-gold');
    geoFolder.classList.add('collapsed');
    _folderRefs.geo = geoFolder;
    if (geoSatellites.length > 0) {
        _appendGeoItemsToContainer(geoFolder.querySelector('.folder-body'));
    }
    frag.appendChild(geoFolder);

    $satList.appendChild(frag);

    // Build formation map from current data
    rebuildFormationMap();
}

function _appendGeoItemsToContainer(container) {
    geoSatellites.forEach((gs, gi) => {
        const div = document.createElement('div');
        div.className = 'sat-item geo-sat-item';
        div.dataset.geoIndex = gi;
        const displayName = gs.name.replace(/^EUTELSAT\s*/i, '').trim() || gs.name;
        const absLon = Math.abs(gs.lon).toFixed(1);
        const dir = gs.lon >= 0 ? 'E' : 'W';
        div.innerHTML = `
            <div class="sat-dot"></div>
            <div class="sat-info">
                <div class="sat-name">${displayName}</div>
                <div class="sat-meta">GEO &middot; ${absLon}&deg;${dir} &middot; ID ${gs.noradId}</div>
            </div>
        `;
        div.addEventListener('click', () => focusGeoSatellite(gi));
        container.appendChild(div);
    });
}

function appendGeoListItems() {
    // Remove any existing GEO items (in case of rebuild)
    if (_folderRefs.geo) {
        _folderRefs.geo.querySelectorAll('.geo-sat-item').forEach(el => el.remove());
        _appendGeoItemsToContainer(_folderRefs.geo.querySelector('.folder-body'));
        // Update count badge
        const badge = _folderRefs.geo.querySelector('.folder-count');
        if (badge) badge.textContent = geoSatellites.length;
    } else {
        $satList.querySelectorAll('.geo-sat-item').forEach(el => el.remove());
        const frag = document.createDocumentFragment();
        geoSatellites.forEach((gs, gi) => {
            const div = document.createElement('div');
            div.className = 'sat-item geo-sat-item';
            div.dataset.geoIndex = gi;
            const displayName = gs.name.replace(/^EUTELSAT\s*/i, '').trim() || gs.name;
            const absLon = Math.abs(gs.lon).toFixed(1);
            const dir = gs.lon >= 0 ? 'E' : 'W';
            div.innerHTML = `<div class="sat-dot"></div><div class="sat-info"><div class="sat-name">${displayName}</div><div class="sat-meta">GEO &middot; ${absLon}&deg;${dir} &middot; ID ${gs.noradId}</div></div>`;
            div.addEventListener('click', () => focusGeoSatellite(gi));
            frag.appendChild(div);
        });
        $satList.appendChild(frag);
    }
}

function filterSatList(query) {
    const q = query.trim();
    const ql = q.toLowerCase();

    // Toggle search-active class for flat vs folder view
    if (ql) {
        $satList.classList.add('search-active');
    } else {
        $satList.classList.remove('search-active');
    }

    const planeItems = $satList.querySelectorAll('.plane-item');
    const leoItems = $satList.querySelectorAll('.sat-item:not(.geo-sat-item)');
    const geoItems = $satList.querySelectorAll('.geo-sat-item');

    // Formation keyword detection
    const isSupersmash = /^super\s*smash$/i.test(q);
    const isMonstermash = /^monster\s*mash$/i.test(q);
    const isFormationSearch = isSupersmash || isMonstermash;

    // Leaving formation search — restore colors and meta text
    if (_activeFormationSearch && !isFormationSearch) {
        _activeFormationSearch = null;
        restoreAllSatColors();
        const $resultCount = document.getElementById('search-result-count');
        if ($resultCount) $resultCount.classList.remove('visible');
        // Restore original sat-meta text
        leoItems.forEach(item => {
            const i = parseInt(item.dataset.index, 10);
            const sat = satellites[i];
            const planePart = sat.plane > 0 ? ' \u00B7 Plane ' + sat.plane : '';
            const meta = item.querySelector('.sat-meta');
            if (meta) meta.textContent = 'ID ' + sat.noradId + planePart + ' \u00B7 ' + sat.inclination.toFixed(1) + '\u00B0 inc';
        });
    }

    // Formation search: show only matching satellites
    if (isFormationSearch) {
        const formType = isSupersmash ? 'supersmash' : 'monstermash';
        _activeFormationSearch = formType;
        const formations = _formations[formType];
        const matchSet = new Set();
        const satAolMap = {};
        const satPlaneMap = {};
        formations.forEach(f => {
            f.indices.forEach((idx, j) => {
                matchSet.add(idx);
                satAolMap[idx] = f.aols[j];
                satPlaneMap[idx] = f.plane;
            });
        });

        // Hide plane items and GEO items
        planeItems.forEach(item => item.style.display = 'none');
        geoItems.forEach(item => item.style.display = 'none');

        // Show only matching LEO items with updated meta
        leoItems.forEach(item => {
            const i = parseInt(item.dataset.index, 10);
            if (matchSet.has(i)) {
                item.style.display = '';
                const meta = item.querySelector('.sat-meta');
                if (meta) meta.textContent = 'Plane ' + satPlaneMap[i] + ' \u00B7 AoL ' + satAolMap[i].toFixed(1) + '\u00B0';
            } else {
                item.style.display = 'none';
            }
        });

        // Show result count
        const $resultCount = document.getElementById('search-result-count');
        if ($resultCount) {
            const label = isSupersmash ? 'SUPERSMASH' : 'MONSTER MASH';
            $resultCount.textContent = label + ' \u2014 ' + matchSet.size + ' satellite' + (matchSet.size !== 1 ? 's' : '');
            $resultCount.classList.add('visible');
        }
        return;
    }

    // Default view (no query): folders handle structure, just reset item visibility
    if (!ql) {
        const $resultCount = document.getElementById('search-result-count');
        if ($resultCount) $resultCount.classList.remove('visible');
        planeItems.forEach(item => item.style.display = 'none');
        leoItems.forEach(item => item.style.display = '');
        geoItems.forEach(item => item.style.display = '');
        return;
    }

    const planeExact = q.match(/^plane\s*(\d+)$/i);
    const planePartial = ql && ('plane'.startsWith(ql) || ql.startsWith('plane'));
    const unassignedMatch = ql && 'unassigned'.startsWith(ql);

    // Does query match "geo" or a GEO sat name?
    const geoMatch = ql && ('geo'.startsWith(ql) || ql.startsWith('geo') || ql.includes('eutelsat'));

    // Show/hide plane group items
    planeItems.forEach(item => {
        const p = parseInt(item.dataset.plane, 10);
        if (unassignedMatch) {
            item.style.display = p === 0 ? 'flex' : 'none';
        } else if (planeExact) {
            item.style.display = p === parseInt(planeExact[1], 10) ? 'flex' : 'none';
        } else if (planePartial) {
            item.style.display = 'flex';
        } else {
            item.style.display = 'none';
        }
        // Update selected state
        item.classList.toggle('selected', selectedPlane === p);
    });

    // Show/hide LEO satellite items
    if (unassignedMatch) {
        leoItems.forEach(item => {
            const i = parseInt(item.dataset.index, 10);
            item.style.display = satellites[i].plane === 0 ? '' : 'none';
        });
    } else if (planeExact) {
        const planeNum = parseInt(planeExact[1], 10);
        leoItems.forEach(item => {
            const i = parseInt(item.dataset.index, 10);
            item.style.display = satellites[i].plane === planeNum ? '' : 'none';
        });
    } else {
        leoItems.forEach(item => {
            const i = parseInt(item.dataset.index, 10);
            const sat = satellites[i];
            const match = !ql || sat.name.toLowerCase().includes(ql) || String(sat.noradId).includes(ql);
            item.style.display = match ? '' : 'none';
        });
    }

    // Show/hide GEO satellite items
    geoItems.forEach(item => {
        const gi = parseInt(item.dataset.geoIndex, 10);
        const gs = geoSatellites[gi];
        if (!gs) { item.style.display = 'none'; return; }
        const nameMatch = gs.name.toLowerCase().includes(ql) || String(gs.noradId).includes(ql);
        item.style.display = (geoMatch || nameMatch) && ql ? '' : 'none';
        item.classList.toggle('selected', gi === selectedGeoIndex);
    });

    // Show/hide catalog satellite items (+ dynamic search for large groups)
    if (ql) {
        for (const key of Object.keys(catalogState)) {
            const cs = catalogState[key];
            if (!cs.visible || !cs.loaded) continue;
            const folder = $satList.querySelector(`.folder[data-folder-id="catalog-${key}"]`);
            if (!folder) continue;

            if (cs.satellites.length <= 200) {
                // Filter existing DOM items
                const catItems = folder.querySelectorAll('.catalog-sat-item');
                catItems.forEach(item => {
                    const ci = parseInt(item.dataset.catIndex, 10);
                    const sat = cs.satellites[ci];
                    if (!sat) { item.style.display = 'none'; return; }
                    const match = sat.name.toLowerCase().includes(ql) || String(sat.noradId).includes(ql);
                    item.style.display = match ? '' : 'none';
                });
            } else {
                // Dynamic search for large groups: create up to 20 result items
                const body = folder.querySelector('.folder-body');
                body.innerHTML = '';
                const group = CATALOG_GROUPS.find(g => g.key === key);
                let count = 0;
                for (let i = 0; i < cs.satellites.length && count < 20; i++) {
                    const sat = cs.satellites[i];
                    if (sat.name.toLowerCase().includes(ql) || String(sat.noradId).includes(ql)) {
                        const div = document.createElement('div');
                        div.className = 'sat-item catalog-sat-item';
                        div.dataset.group = key;
                        div.dataset.catIndex = i;
                        div.innerHTML = `<div class="sat-dot" style="background:${group ? group.color : '#b388ff'}"></div><div class="sat-info"><div class="sat-name">${sat.name}</div><div class="sat-meta">${group ? group.label : key} &middot; ID ${sat.noradId}</div></div>`;
                        div.addEventListener('click', () => selectCatalogSatellite(key, i));
                        body.appendChild(div);
                        count++;
                    }
                }
                if (count === 0) {
                    const info = document.createElement('div');
                    info.className = 'sat-item'; info.style.opacity = '0.5'; info.style.cursor = 'default';
                    info.innerHTML = `<div class="sat-info"><div class="sat-name">No matches</div></div>`;
                    body.appendChild(info);
                } else if (count >= 20) {
                    const info = document.createElement('div');
                    info.className = 'sat-item'; info.style.opacity = '0.5'; info.style.cursor = 'default';
                    info.innerHTML = `<div class="sat-info"><div class="sat-meta">Showing first 20 results</div></div>`;
                    body.appendChild(info);
                }
            }
        }
    } else {
        // Restore large group folders to summary view when search cleared
        for (const key of Object.keys(catalogState)) {
            const cs = catalogState[key];
            if (!cs.visible || !cs.loaded || cs.satellites.length <= 200) continue;
            const folder = $satList.querySelector(`.folder[data-folder-id="catalog-${key}"]`);
            if (!folder) continue;
            const body = folder.querySelector('.folder-body');
            body.innerHTML = '';
            const info = document.createElement('div');
            info.className = 'sat-item'; info.style.opacity = '0.6'; info.style.cursor = 'default';
            info.innerHTML = `<div class="sat-info"><div class="sat-name">${cs.satellites.length} satellites</div><div class="sat-meta">Use search to find individual sats</div></div>`;
            body.appendChild(info);
        }
    }
}

// ============================================================
// SELECTION
// ============================================================
function selectSatellite(index) {
    closeGeoPanel();
    clearCatalogSelection();
    clearOrbitalViz();
    // Show OneWeb-specific buttons
    document.getElementById('detail-alarm').style.display = '';
    document.getElementById('detail-beams').style.display = '';
    // Clear plane selection if active
    if (selectedPlane >= 0) {
        const oldPlaneItem = $satList.querySelector('.plane-item.selected');
        if (oldPlaneItem) oldPlaneItem.classList.remove('selected');
        selectedPlane = -1;
        removePlaneGlow();
        restoreAllSatColors();
    }

    // Deselect old
    if (selectedIndex >= 0) {
        const oldItem = $satList.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        resetSatColor(selectedIndex);
    }

    if (index === selectedIndex) {
        if ($detailPanel.classList.contains('hidden')) {
            // Detail panel was dismissed — re-show it
            $detailPanel.classList.remove('hidden');
        } else {
            // Toggle off — stop tracking but keep camera where it is
            stopTracking();
            selectedIndex = -1;
            $detailPanel.classList.add('hidden');
            clearOrbitPath();
            clearCoverageFootprint();
            clearTtcPasses();
        }
        return;
    }

    // If we were tracking something else, stop without resetting view
    if (trackingIndex >= 0 && trackingIndex !== index) {
        stopTracking();
    }

    selectedIndex = index;
    const item = $satList.querySelector(`.sat-item[data-index="${index}"]`);
    if (item) {
        // Auto-expand parent folders if collapsed
        let parentFolder = item.closest('.folder.collapsed');
        while (parentFolder) {
            parentFolder.classList.remove('collapsed');
            parentFolder = parentFolder.parentElement && parentFolder.parentElement.closest('.folder.collapsed');
        }
        item.classList.add('selected');
        item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }

    // Update detail panel
    $detailPanel.classList.remove('hidden');
    updateDetailPanel();
    updateAlarmButtonState();
    document.getElementById('detail-beams').classList.toggle('active', beamMode === 'individual');
    _ttcDirty = true;
    updateTtcPassDisplay();

    // Always track the selected satellite
    focusSatellite(index);
    if (beamMode === 'individual') createCoverageFootprint();

}

function setSatColor(index, r, g, b) {
    if (!satColorAttr) return;
    satColorAttr.setXYZ(index, r, g, b);
    satColorAttr.needsUpdate = true;
}

function resetSatColor(index) {
    if (satellites[index].excluded) {
        setSatColor(index, 1.0, 0.2, 0.2); // red for excluded
    } else if (trackingIndex >= 0 && index !== trackingIndex) {
        setSatColor(index, 0.08, 0.12, 0.18);
    } else if (selectedPlane >= 0) {
        if (satellites[index].plane === selectedPlane) {
            setSatColor(index, 0.2, 0.85, 1.0);
        } else {
            setSatColor(index, 0.05, 0.08, 0.12);
        }
    } else {
        setSatColor(index, 0, 0.9, 1.0);
    }
}

function computeSatAoL(sat) {
    // Lightweight AoL computation from ECI state vector
    if (sat.eciX === undefined || sat.eciVx === undefined) return NaN;
    const _mu = 398600.4418;
    const _rx = sat.eciX, _ry = sat.eciY, _rz = sat.eciZ;
    const _vx = sat.eciVx, _vy = sat.eciVy, _vz = sat.eciVz;
    const _rM = Math.sqrt(_rx*_rx + _ry*_ry + _rz*_rz);
    // Angular momentum h = r × v
    const _hx = _ry*_vz - _rz*_vy, _hy = _rz*_vx - _rx*_vz, _hz = _rx*_vy - _ry*_vx;
    const _hM = Math.sqrt(_hx*_hx + _hy*_hy + _hz*_hz);
    // Inclination
    const oscInc = Math.acos(Math.max(-1, Math.min(1, _hz / _hM))) * RAD2DEG;
    // Node vector n = z × h
    const _nnx = -_hy, _nny = _hx;
    const _nM = Math.sqrt(_nnx*_nnx + _nny*_nny);
    // RAAN
    let oscRaan = 0;
    if (_nM > 1e-10) {
        oscRaan = Math.acos(Math.max(-1, Math.min(1, _nnx / _nM)));
        if (_nny < 0) oscRaan = 2*Math.PI - oscRaan;
    }
    // Argument of latitude
    const nx = Math.cos(oscRaan), ny = Math.sin(oscRaan);
    const px = _rx * nx + _ry * ny;
    const py = (-_rx * ny + _ry * nx) * Math.cos(oscInc * DEG2RAD) + _rz * Math.sin(oscInc * DEG2RAD);
    return ((Math.atan2(py, px) * RAD2DEG) % 360 + 360) % 360;
}

function detectFormations() {
    const supersmash = [];
    const monstermash = [];
    // Group satellites by plane (1-12 only)
    const planeGroups = {};
    for (let i = 0; i < satellites.length; i++) {
        const p = satellites[i].plane;
        if (p < 1 || p > 12) continue;
        const aol = computeSatAoL(satellites[i]);
        if (isNaN(aol)) continue;
        if (!planeGroups[p]) planeGroups[p] = [];
        planeGroups[p].push({ idx: i, aol });
    }

    for (const p in planeGroups) {
        const sats = planeGroups[p];
        if (sats.length < 2) continue;
        sats.sort((a, b) => a.aol - b.aol);

        // Build adjacency: pairs within threshold (handle 0/360 wrap)
        const adj = new Map(); // idx -> Set of adjacent idx
        for (let i = 0; i < sats.length; i++) {
            for (let j = i + 1; j < sats.length; j++) {
                let diff = Math.abs(sats[i].aol - sats[j].aol);
                if (diff > 180) diff = 360 - diff;
                if (diff <= MONSTERMASH_AOL_THRESHOLD) {
                    if (!adj.has(sats[i].idx)) adj.set(sats[i].idx, new Set());
                    if (!adj.has(sats[j].idx)) adj.set(sats[j].idx, new Set());
                    adj.get(sats[i].idx).add(sats[j].idx);
                    adj.get(sats[j].idx).add(sats[i].idx);
                }
            }
        }

        // Find triples: all three mutually adjacent
        const inTriple = new Set();
        const satIndices = sats.map(s => s.idx);
        const aolMap = {};
        sats.forEach(s => aolMap[s.idx] = s.aol);

        for (let i = 0; i < satIndices.length; i++) {
            const a = satIndices[i];
            const adjA = adj.get(a);
            if (!adjA || adjA.size < 2) continue;
            const neighbors = [...adjA];
            for (let j = 0; j < neighbors.length; j++) {
                for (let k = j + 1; k < neighbors.length; k++) {
                    const b = neighbors[j], c = neighbors[k];
                    const adjB = adj.get(b);
                    if (adjB && adjB.has(c)) {
                        // All three mutually adjacent = monster mash
                        const triKey = [a, b, c].sort((x, y) => x - y).join(',');
                        if (!inTriple.has(triKey)) {
                            inTriple.add(triKey);
                            const indices = [a, b, c].sort((x, y) => x - y);
                            monstermash.push({
                                indices,
                                plane: parseInt(p),
                                aols: indices.map(idx => aolMap[idx])
                            });
                        }
                    }
                }
            }
        }

        // Collect indices consumed by triples
        const tripleIndices = new Set();
        monstermash.forEach(m => { if (m.plane === parseInt(p)) m.indices.forEach(idx => tripleIndices.add(idx)); });

        // Remaining pairs not in any triple
        for (const [a, neighbors] of adj) {
            if (tripleIndices.has(a)) continue;
            for (const b of neighbors) {
                if (tripleIndices.has(b)) continue;
                if (a < b) { // avoid duplicates
                    let pairDiff = Math.abs(aolMap[a] - aolMap[b]);
                    if (pairDiff > 180) pairDiff = 360 - pairDiff;
                    if (pairDiff > SUPERSMASH_AOL_THRESHOLD) continue;
                    supersmash.push({
                        indices: [a, b],
                        plane: parseInt(p),
                        aols: [aolMap[a], aolMap[b]]
                    });
                }
            }
        }
    }

    _formations = { supersmash, monstermash };
}

function rebuildFormationMap() {
    if (!_folderRefs.oneweb) return;
    const ssIndices = new Set();
    _formations.supersmash.forEach(f => f.indices.forEach(i => ssIndices.add(i)));
    const mmIndices = new Set();
    _formations.monstermash.forEach(f => f.indices.forEach(i => mmIndices.add(i)));
    const key = [...ssIndices].sort((a,b)=>a-b).join(',') + '|' + [...mmIndices].sort((a,b)=>a-b).join(',');
    if (key === _lastFormationKey) return;
    _lastFormationKey = key;

    // Rebuild _formationMap
    _formationMap = {};
    ssIndices.forEach(idx => { _formationMap[idx] = 'supersmash'; });
    mmIndices.forEach(idx => { _formationMap[idx] = 'monstermash'; });

    // Update formation badges on sat items
    const leoItems = $satList.querySelectorAll('.sat-item:not(.geo-sat-item)');
    leoItems.forEach(item => {
        const idx = parseInt(item.dataset.index, 10);
        const nameEl = item.querySelector('.sat-name');
        if (!nameEl) return;
        const existing = nameEl.querySelector('.formation-badge');
        const formation = _formationMap[idx];
        if (formation === 'supersmash') {
            if (existing) {
                existing.className = 'formation-badge ss';
                existing.textContent = 'SS';
            } else {
                const badge = document.createElement('span');
                badge.className = 'formation-badge ss';
                badge.textContent = 'SS';
                nameEl.appendChild(badge);
            }
        } else if (formation === 'monstermash') {
            if (existing) {
                existing.className = 'formation-badge mm';
                existing.textContent = 'MM';
            } else {
                const badge = document.createElement('span');
                badge.className = 'formation-badge mm';
                badge.textContent = 'MM';
                nameEl.appendChild(badge);
            }
        } else if (existing) {
            existing.remove();
        }
    });
}

function updateDetailPanel() {
    if (selectedIndex < 0) return;
    const sat = satellites[selectedIndex];
    $detailName.textContent = sat.name.replace('ONEWEB-', 'ONEWEB ');
    $detailLat.textContent = sat.lat.toFixed(3) + '\u00B0';
    $detailLon.textContent = sat.lon.toFixed(3) + '\u00B0';
    $detailAlt.textContent = Math.round(sat.alt).toLocaleString() + ' km';
    $detailVel.textContent = (sat.speed || 0).toFixed(1) + ' km/s';
    // Osculating orbital elements from state vector (matches SGP4 propagated orbit)
    if (sat.eciX !== undefined && sat.eciVx !== undefined) {
        const _mu = 398600.4418;
        const _rx = sat.eciX, _ry = sat.eciY, _rz = sat.eciZ;
        const _vx = sat.eciVx, _vy = sat.eciVy, _vz = sat.eciVz;
        const _rM = Math.sqrt(_rx*_rx + _ry*_ry + _rz*_rz);
        const _vM = Math.sqrt(_vx*_vx + _vy*_vy + _vz*_vz);

        // Angular momentum h = r × v
        const _hx = _ry*_vz - _rz*_vy, _hy = _rz*_vx - _rx*_vz, _hz = _rx*_vy - _ry*_vx;
        const _hM = Math.sqrt(_hx*_hx + _hy*_hy + _hz*_hz);

        // Eccentricity vector
        const _vxh_x = _vy*_hz - _vz*_hy, _vxh_y = _vz*_hx - _vx*_hz, _vxh_z = _vx*_hy - _vy*_hx;
        const _ex = _vxh_x/_mu - _rx/_rM, _ey = _vxh_y/_mu - _ry/_rM, _ez = _vxh_z/_mu - _rz/_rM;
        const oscEcc = Math.sqrt(_ex*_ex + _ey*_ey + _ez*_ez);

        // Inclination
        const oscInc = Math.acos(Math.max(-1, Math.min(1, _hz / _hM))) * RAD2DEG;

        // Semi-major axis (vis-viva)
        const oscA = 1 / (2/_rM - _vM*_vM/_mu);

        // Period
        const oscPeriod = 2 * Math.PI * Math.sqrt(oscA*oscA*oscA / _mu) / 60; // minutes

        // Node vector n = z × h
        const _nnx = -_hy, _nny = _hx;
        const _nM = Math.sqrt(_nnx*_nnx + _nny*_nny);

        // RAAN
        let oscRaan = 0;
        if (_nM > 1e-10) {
            oscRaan = Math.acos(Math.max(-1, Math.min(1, _nnx / _nM)));
            if (_nny < 0) oscRaan = 2*Math.PI - oscRaan;
        }

        // Argument of latitude (angle from ascending node to satellite in orbital plane)
        const nx = Math.cos(oscRaan), ny = Math.sin(oscRaan);
        const px = _rx * nx + _ry * ny;
        const py = (-_rx * ny + _ry * nx) * Math.cos(oscInc * DEG2RAD) + _rz * Math.sin(oscInc * DEG2RAD);
        const aol = ((Math.atan2(py, px) * RAD2DEG) % 360 + 360) % 360;

        $detailInc.textContent = oscInc.toFixed(2) + '\u00B0';
        $detailEcc.textContent = oscEcc.toFixed(6);
        $detailRaan.textContent = (oscRaan * RAD2DEG).toFixed(2) + '\u00B0';
        $detailAol.textContent = aol.toFixed(2) + '\u00B0';
        $detailPeriod.textContent = oscPeriod.toFixed(1) + ' min';
    } else {
        $detailInc.textContent = sat.inclination.toFixed(2) + '\u00B0';
        $detailEcc.textContent = sat.eccentricity.toFixed(6);
        const raan = (sat.satrec.nodeo * RAD2DEG % 360 + 360) % 360;
        $detailRaan.textContent = raan.toFixed(2) + '\u00B0';
        $detailAol.textContent = '--';
        $detailPeriod.textContent = sat.period.toFixed(1) + ' min';
    }
    $detailNorad.textContent = sat.noradId;
    // TLE age from satrec epoch (Julian date → JS Date)
    var tleEpochMs = (sat.satrec.jdsatepoch - 2440587.5) * 86400000;
    var tleAgeMs = Date.now() - tleEpochMs;
    var tleAgeDays = tleAgeMs / 86400000;
    if (tleAgeDays < 1) {
        var tleAgeHrs = Math.floor(tleAgeDays * 24);
        $detailTleAge.textContent = tleAgeHrs + 'h';
        $detailTleAge.style.color = 'var(--success)';
    } else if (tleAgeDays < 3) {
        $detailTleAge.textContent = tleAgeDays.toFixed(1) + ' days';
        $detailTleAge.style.color = 'var(--success)';
    } else if (tleAgeDays < 7) {
        $detailTleAge.textContent = tleAgeDays.toFixed(1) + ' days';
        $detailTleAge.style.color = '#ffeb3b';
    } else {
        $detailTleAge.textContent = tleAgeDays.toFixed(1) + ' days';
        $detailTleAge.style.color = '#ff5252';
    }
    $detailPlane.textContent = sat.plane > 0 ? 'Plane ' + sat.plane : 'Unassigned';
    const formation = _formationMap[selectedIndex];
    if (formation === 'supersmash') {
        $detailFormation.textContent = 'SUPERSMASH';
        $detailFormation.style.color = 'var(--success)';
    } else if (formation === 'monstermash') {
        $detailFormation.textContent = 'MONSTER MASH';
        $detailFormation.style.color = '#bb86fc';
    } else {
        $detailFormation.textContent = '\u2014';
        $detailFormation.style.color = '';
    }
}

// ============================================================
// TT&C PASS PREDICTIONS
// ============================================================
function computeElevation(satrec, observerGd, date) {
    const posVel = satellite.propagate(satrec, date);
    if (!posVel.position) return -Infinity;
    const gmst = satellite.gstime(date);
    const ecf = satellite.eciToEcf(posVel.position, gmst);
    const lookAngles = satellite.ecfToLookAngles(observerGd, ecf);
    return lookAngles.elevation;
}

function findNextPass(satrec, observerGd, startTime) {
    const startMs = startTime.getTime();
    const endMs = startMs + TTC_SEARCH_WINDOW_MS;

    // Check if currently in pass
    const elNow = computeElevation(satrec, observerGd, startTime);
    if (elNow > TTC_MIN_ELEV_RAD) {
        // Already in pass — find AOS by searching backwards (up to 15 min)
        let aosMs = startMs;
        for (let t = startMs - TTC_STEP_MS; t >= startMs - 15 * 60 * 1000; t -= TTC_STEP_MS) {
            const el = computeElevation(satrec, observerGd, new Date(t));
            if (el <= TTC_MIN_ELEV_RAD) {
                // Refine forward
                for (let r = t; r <= t + TTC_STEP_MS; r += TTC_REFINE_MS) {
                    if (computeElevation(satrec, observerGd, new Date(r)) > TTC_MIN_ELEV_RAD) {
                        aosMs = r;
                        break;
                    }
                }
                break;
            }
            aosMs = t;
        }

        // Find LOS forward
        let losMs = startMs;
        let maxEl = elNow;
        for (let t = startMs + TTC_STEP_MS; t <= endMs; t += TTC_STEP_MS) {
            const el = computeElevation(satrec, observerGd, new Date(t));
            if (el > maxEl) maxEl = el;
            if (el <= TTC_MIN_ELEV_RAD) {
                // Refine backwards
                for (let r = t; r >= t - TTC_STEP_MS; r -= TTC_REFINE_MS) {
                    if (computeElevation(satrec, observerGd, new Date(r)) > TTC_MIN_ELEV_RAD) {
                        losMs = r;
                        break;
                    }
                }
                break;
            }
            losMs = t;
        }

        return {
            aosTime: new Date(aosMs),
            losTime: new Date(losMs),
            maxElDeg: maxEl * RAD2DEG,
            durationSec: (losMs - aosMs) / 1000,
            isCurrentlyInPass: true
        };
    }

    // Search forward for next AOS
    for (let t = startMs + TTC_STEP_MS; t <= endMs; t += TTC_STEP_MS) {
        const el = computeElevation(satrec, observerGd, new Date(t));
        if (el > TTC_MIN_ELEV_RAD) {
            // Refine AOS backwards
            let aosMs = t;
            for (let r = t - TTC_STEP_MS; r <= t; r += TTC_REFINE_MS) {
                if (computeElevation(satrec, observerGd, new Date(r)) > TTC_MIN_ELEV_RAD) {
                    aosMs = r;
                    break;
                }
            }

            // Find max elevation and LOS
            let maxEl = el;
            let losMs = t;
            for (let t2 = t + TTC_STEP_MS; t2 <= endMs; t2 += TTC_STEP_MS) {
                const el2 = computeElevation(satrec, observerGd, new Date(t2));
                if (el2 > maxEl) maxEl = el2;
                if (el2 <= TTC_MIN_ELEV_RAD) {
                    // Refine LOS backwards
                    for (let r = t2; r >= t2 - TTC_STEP_MS; r -= TTC_REFINE_MS) {
                        if (computeElevation(satrec, observerGd, new Date(r)) > TTC_MIN_ELEV_RAD) {
                            losMs = r;
                            break;
                        }
                    }
                    break;
                }
                losMs = t2;
            }

            return {
                aosTime: new Date(aosMs),
                losTime: new Date(losMs),
                maxElDeg: maxEl * RAD2DEG,
                durationSec: (losMs - aosMs) / 1000,
                isCurrentlyInPass: false
            };
        }
    }

    return null; // no pass within search window
}

function computeTtcPasses() {
    if (selectedIndex < 0) return;
    const sat = satellites[selectedIndex];
    if (!sat || !sat.satrec) return;

    for (let i = 0; i < TTC_OBSERVERS.length; i++) {
        _ttcPasses[i] = findNextPass(sat.satrec, TTC_OBSERVERS[i].gd, simTime);
    }
    _ttcLastPredictTime = simTime.getTime();
    _ttcLastSatIndex = selectedIndex;
    _ttcDirty = false;
}

function formatCountdown(sec) {
    if (sec < 0) sec = 0;
    const h = Math.floor(sec / 3600);
    const m = Math.floor((sec % 3600) / 60);
    const s = Math.floor(sec % 60);
    if (h > 0) return h + 'h ' + m + 'm';
    if (m > 0) return m + 'm ' + s + 's';
    return s + 's';
}

function formatUtcTime(date) {
    const h = String(date.getUTCHours()).padStart(2, '0');
    const m = String(date.getUTCMinutes()).padStart(2, '0');
    const s = String(date.getUTCSeconds()).padStart(2, '0');
    return h + ':' + m + ':' + s + ' UTC';
}

function updateTtcPassDisplay() {
    if (selectedIndex < 0 || $detailPanel.classList.contains('hidden')) {
        $ttcPanelSvalbard.classList.remove('visible');
        $ttcPanelInuvik.classList.remove('visible');
        return;
    }

    // Recompute if dirty, satellite changed, or 60s sim-time drift
    const simMs = simTime.getTime();
    if (_ttcDirty || _ttcLastSatIndex !== selectedIndex ||
        Math.abs(simMs - _ttcLastPredictTime) > 60000) {
        computeTtcPasses();
    }

    // Sort panels: soonest pass first (in-pass < upcoming AOS < no pass)
    function passSortKey(pass) {
        if (!pass) return Infinity;
        const aosMs = pass.aosTime.getTime();
        // In-pass: use negative value so it sorts first
        if (simMs >= aosMs && simMs < pass.losTime.getTime()) return -1;
        return aosMs;
    }
    const svalbardKey = passSortKey(_ttcPasses[0]);
    const inuvikKey = passSortKey(_ttcPasses[1]);
    const svalbardFirst = svalbardKey <= inuvikKey;

    const $firstPanel = svalbardFirst ? $ttcPanelSvalbard : $ttcPanelInuvik;
    const $secondPanel = svalbardFirst ? $ttcPanelInuvik : $ttcPanelSvalbard;

    // Position panels stacked below detail panel
    const detailRect = $detailPanel.getBoundingClientRect();
    $firstPanel.style.top = (detailRect.bottom + 8) + 'px';
    $firstPanel.classList.add('visible');
    const firstRect = $firstPanel.getBoundingClientRect();
    $secondPanel.style.top = (firstRect.bottom + 6) + 'px';
    $secondPanel.classList.add('visible');

    const panels = [
        [_ttcPasses[0], $ttcSvalbardCountdown, $ttcSvalbardTimes],
        [_ttcPasses[1], $ttcInuvikCountdown, $ttcInuvikTimes],
    ];

    for (let i = 0; i < 2; i++) {
        const [pass, $countdown, $times] = panels[i];

        if (!pass) {
            $countdown.textContent = 'No pass within 2h';
            $countdown.className = 'ttc-panel-countdown no-pass';
            $times.textContent = '';
            continue;
        }

        const aosMs = pass.aosTime.getTime();
        const losMs = pass.losTime.getTime();

        if (simMs >= aosMs && simMs < losMs) {
            const remaining = (losMs - simMs) / 1000;
            $countdown.textContent = 'IN PASS \u2022 ' + formatCountdown(remaining);
            $countdown.className = 'ttc-panel-countdown in-pass';
            $times.textContent = 'AOS ' + formatUtcTime(pass.aosTime) + '  \u2022  LOS ' + formatUtcTime(pass.losTime);
        } else if (simMs < aosMs) {
            const until = (aosMs - simMs) / 1000;
            $countdown.textContent = 'AOS ' + formatCountdown(until);
            $countdown.className = 'ttc-panel-countdown';
            $times.textContent = 'AOS ' + formatUtcTime(pass.aosTime) + '  \u2022  LOS ' + formatUtcTime(pass.losTime);
        } else {
            _ttcDirty = true;
            $countdown.textContent = '--';
            $countdown.className = 'ttc-panel-countdown';
            $times.textContent = '';
        }
    }

    checkAllTtcAlarms();
}

function clearTtcPasses() {
    _ttcPasses = [null, null];
    _ttcLastPredictTime = 0;
    _ttcLastSatIndex = -1;
    _ttcDirty = true;
    $ttcPanelSvalbard.classList.remove('visible');
    $ttcPanelInuvik.classList.remove('visible');
    $ttcSvalbardCountdown.textContent = '--';
    $ttcSvalbardCountdown.className = 'ttc-panel-countdown';
    $ttcSvalbardTimes.textContent = '';
    $ttcInuvikCountdown.textContent = '--';
    $ttcInuvikCountdown.className = 'ttc-panel-countdown';
    $ttcInuvikTimes.textContent = '';
}

function _playAlarmChime(ctx) {
    [660, 880, 1100].forEach((freq, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.15, ctx.currentTime + i * 0.15);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.15 + 0.3);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime + i * 0.15);
        osc.stop(ctx.currentTime + i * 0.15 + 0.3);
    });
}

function playAlarmSound() {
    stopAlarmSound();
    try {
        _alarmAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
        _playAlarmChime(_alarmAudioCtx);
        // Repeat every 2.5s until dismissed
        _alarmInterval = setInterval(() => {
            if (_alarmAudioCtx && _alarmAudioCtx.state !== 'closed') {
                _playAlarmChime(_alarmAudioCtx);
            }
        }, 2500);
    } catch (e) { /* audio not available */ }
}

function stopAlarmSound() {
    if (_alarmInterval) { clearInterval(_alarmInterval); _alarmInterval = null; }
    if (_alarmAudioCtx) {
        try { _alarmAudioCtx.close(); } catch (e) {}
        _alarmAudioCtx = null;
    }
}

// ============================================================
// MULTI-SATELLITE ALARM SYSTEM
// ============================================================

function toggleAlarm(satIndex) {
    if (satIndex < 0 || satIndex >= satellites.length) return;
    if (_ttcAlarms.has(satIndex)) {
        _ttcAlarms.delete(satIndex);
    } else {
        _ttcAlarms.set(satIndex, { firedForAos: new Set(), passes: [null, null], lastPredictTime: 0 });
    }
    updateAlarmButtonState();
    updateAlarmCount();
    renderAlarmPanel();
    saveAlarmsToStorage();
}

function saveAlarmsToStorage() {
    try {
        const noradIds = [];
        for (const [idx] of _ttcAlarms) {
            const sat = satellites[idx];
            if (sat) noradIds.push(sat.noradId);
        }
        localStorage.setItem('ttcAlarms', JSON.stringify(noradIds));
    } catch (e) { /* storage unavailable */ }
}

function saveManualAlarms() {
    try {
        const data = _manualAlarms.map(a => ({ id: a.id, scid: a.scid, description: a.description, time: a.time.toISOString(), fired: a.fired }));
        localStorage.setItem('manualAlarms', JSON.stringify(data));
    } catch (e) { /* storage unavailable */ }
}

function restoreManualAlarms() {
    try {
        const raw = localStorage.getItem('manualAlarms');
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return;
        _manualAlarms = arr.map(a => ({ id: a.id, scid: a.scid, description: a.description, time: new Date(a.time), fired: !!a.fired }));
        _manualAlarmId = _manualAlarms.reduce((max, a) => Math.max(max, a.id), 0) + 1;
    } catch (e) { /* storage unavailable or corrupt */ }
}

function restoreAlarmsFromStorage() {
    _ttcAlarms.clear();
    try {
        const raw = localStorage.getItem('ttcAlarms');
        if (!raw) return;
        const noradIds = JSON.parse(raw);
        if (!Array.isArray(noradIds) || noradIds.length === 0) return;
        const idSet = new Set(noradIds.map(String));
        for (let i = 0; i < satellites.length; i++) {
            if (idSet.has(String(satellites[i].noradId))) {
                _ttcAlarms.set(i, { firedForAos: new Set(), passes: [null, null], lastPredictTime: 0 });
            }
        }
    } catch (e) { /* storage unavailable or corrupt */ }
    restoreManualAlarms();
    updateAlarmCount();
}

function updateAlarmButtonState() {
    const btn = document.getElementById('detail-alarm');
    if (!btn) return;
    btn.classList.toggle('active', selectedIndex >= 0 && _ttcAlarms.has(selectedIndex));
}

function updateAlarmCount() {
    const count = _ttcAlarms.size + _manualAlarms.filter(a => !a.fired).length;
    $statAlarms.textContent = count;
    $alarmStat.classList.toggle('has-alarms', count > 0);
}

function renderAlarmPanel() {
    const hasTtc = _ttcAlarms.size > 0;
    const hasManual = _manualAlarms.length > 0;
    if (!hasTtc && !hasManual) {
        $alarmList.innerHTML = '<div class="alarm-empty">No alarms set</div>';
        return;
    }
    let html = '';
    const showLabels = hasTtc && hasManual;

    if (hasTtc) {
        if (showLabels) html += '<div class="alarm-section-label">TT&C Alarms</div>';
        for (const [satIdx] of _ttcAlarms) {
            const sat = satellites[satIdx];
            if (!sat) continue;
            const name = sat.name || ('SAT-' + satIdx);
            html += '<div class="alarm-item">' +
                '<span class="alarm-item-name" data-idx="' + satIdx + '">' + name + '</span>' +
                '<button class="alarm-item-remove" data-idx="' + satIdx + '" title="Remove alarm">&times;</button>' +
                '</div>';
        }
    }

    if (hasManual) {
        if (showLabels) html += '<div class="alarm-section-label">Manual Alarms</div>';
        for (const a of _manualAlarms) {
            const timeStr = a.time.toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
            const firedClass = a.fired ? ' style="opacity:0.4"' : '';
            html += '<div class="alarm-manual-item"' + firedClass + '>' +
                '<div><div class="alarm-manual-desc">' + a.scid + ' &middot; ' + (a.description || '') + '</div>' +
                '<div class="alarm-manual-time">' + timeStr + '</div></div>' +
                '<button class="alarm-item-remove" data-manual-id="' + a.id + '" title="Remove alarm">&times;</button>' +
                '</div>';
        }
    }
    $alarmList.innerHTML = html;

    // Bind TT&C click handlers
    $alarmList.querySelectorAll('.alarm-item-name').forEach(el => {
        el.addEventListener('click', () => {
            const idx = parseInt(el.dataset.idx);
            selectSatellite(idx);
            $alarmPanel.classList.remove('visible');
        });
    });
    $alarmList.querySelectorAll('.alarm-item-remove[data-idx]').forEach(el => {
        el.addEventListener('click', () => {
            const idx = parseInt(el.dataset.idx);
            const sat = satellites[idx];
            const name = sat ? (sat.name || 'SAT-' + idx) : 'this satellite';
            showAlarmConfirm(name, () => toggleAlarm(idx));
        });
    });
    // Bind manual alarm remove handlers
    $alarmList.querySelectorAll('.alarm-item-remove[data-manual-id]').forEach(el => {
        el.addEventListener('click', () => {
            const id = parseInt(el.dataset.manualId);
            const alarm = _manualAlarms.find(a => a.id === id);
            const name = alarm ? (alarm.scid + (alarm.description ? ' · ' + alarm.description : '')) : 'this alarm';
            showAlarmConfirm(name, () => {
                _manualAlarms = _manualAlarms.filter(a => a.id !== id);
                saveManualAlarms();
                updateAlarmCount();
                renderAlarmPanel();
            });
        });
    });
}

let _alarmConfirmCallback = null;
function showAlarmConfirm(name, onConfirm) {
    const $overlay = document.getElementById('alarm-confirm-overlay');
    document.getElementById('alarm-confirm-text').textContent = 'Are you sure you want to remove the alarm for ' + name + '?';
    _alarmConfirmCallback = onConfirm;
    $overlay.classList.add('visible');
}

function showTtcToast(satName, stationName) {
    $ttcToastTitle.textContent = satName;
    $ttcToastMessage.textContent = 'Pass over ' + stationName + ' in ~1 min';
    $ttcToast.classList.add('visible');
}

function checkAllTtcAlarms() {
    // Always use real wall-clock time so alarms fire regardless of sim time
    const now = new Date();
    const nowMs = now.getTime();

    // Check TT&C alarms
    if (_ttcAlarms.size > 0) {
        for (const [satIdx, alarm] of _ttcAlarms) {
            const sat = satellites[satIdx];
            if (!sat || !sat.satrec) continue;

            // Recompute passes if stale (>60s real-time drift)
            if (Math.abs(nowMs - alarm.lastPredictTime) > 60000) {
                for (let i = 0; i < TTC_OBSERVERS.length; i++) {
                    alarm.passes[i] = findNextPass(sat.satrec, TTC_OBSERVERS[i].gd, now);
                }
                alarm.lastPredictTime = nowMs;
            }

            // Check each station — fire once per unique AOS timestamp
            for (let i = 0; i < TTC_OBSERVERS.length; i++) {
                const pass = alarm.passes[i];
                if (!pass) continue;
                const aosMs = pass.aosTime.getTime();
                const untilSec = (aosMs - nowMs) / 1000;
                const firedKey = i + ':' + (Math.round(aosMs / 10000) * 10000);
                if (untilSec > 0 && untilSec <= 60 && !alarm.firedForAos.has(firedKey)) {
                    alarm.firedForAos.add(firedKey);
                    playAlarmSound();
                    const satName = sat.name || ('SAT-' + satIdx);
                    showTtcToast(satName, TTC_OBSERVERS[i].name);
                    return; // one alarm per cycle
                }
            }
        }
    }

}

function checkManualAlarms() {
    if (_manualAlarms.length === 0) return;
    // Always use real wall-clock time so alarms fire regardless of sim time
    const nowMs = Date.now();
    for (const a of _manualAlarms) {
        if (!a.fired && nowMs >= a.time.getTime()) {
            a.fired = true;
            saveManualAlarms();
            updateAlarmCount();
            playAlarmSound();
            $ttcToastTitle.textContent = a.scid + ': ' + (a.description || 'Manual alarm');
            $ttcToastMessage.textContent = 'Manual alarm triggered';
            $ttcToast.classList.add('visible');
            renderAlarmPanel();
            return; // one alarm per cycle
        }
    }
}

function updateStats() {
    $statTotal.textContent = satellites.length;
}

// ============================================================
// GROUND STATION LABELS
// ============================================================
function updateGroundStationLabels() {
    if (!camera || !renderer) return;
    const widthHalf = window.innerWidth / 2;
    const heightHalf = window.innerHeight / 2;

    for (const gs of ALL_STATIONS) {
        if (!gs._el) gs._el = document.getElementById(gs.id);
        const el = gs._el;
        if (!el) continue;

        // Cache base position (earth-local, stations don't move on surface)
        if (!gs._basePos) {
            gs._basePos = geoToVec3(gs.lat, gs.lon, 0).multiplyScalar(1.01);
            gs._worldPos = gs._basePos.clone();
        }

        // In ECI mode, rotate base position by earthGroup's GMST rotation
        if (referenceFrame === 'eci') {
            const gmst = earthGroup.rotation.y;
            const c = Math.cos(gmst), s = Math.sin(gmst);
            const bx = gs._basePos.x, bz = gs._basePos.z;
            gs._worldPos.set(bx * c + bz * s, gs._basePos.y, -bx * s + bz * c);
        } else {
            gs._worldPos.copy(gs._basePos);
        }

        // Check if behind globe (reuse module-level objects)
        _camToStation.copy(gs._worldPos).sub(camera.position).normalize();
        raycaster.set(camera.position, _camToStation);
        const hits = raycaster.ray.intersectSphere(_earthSphere, _intersectPt);
        const distToStation = camera.position.distanceTo(gs._worldPos);
        const isBehind = hits && camera.position.distanceTo(_intersectPt) < distToStation * 0.98;
        const wasBehind = el.classList.contains('behind-globe');
        if (isBehind !== wasBehind) el.classList.toggle('behind-globe', isBehind);

        // Project to screen (reuse _projectedVec, use transform for GPU-composited positioning)
        _projectedVec.copy(gs._worldPos).project(camera);
        const x = (_projectedVec.x * widthHalf) + widthHalf;
        const y = -(_projectedVec.y * heightHalf) + heightHalf;
        // Only update DOM if position moved more than 0.5px
        const dx = x - (gs._screenX || 0), dy = y - (gs._screenY || 0);
        if (dx * dx + dy * dy > 0.25) {
            el.style.transform = `translate(${x}px, ${y}px)`;
            gs._screenX = x; gs._screenY = y;
        }
    }
}

// ============================================================
// CAMERA ANIMATION / TRACKING
// ============================================================
function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function focusSatellite(index) {
    if (index < 0 || index >= satellites.length) return;

    // If already tracking this one, stop tracking
    if (trackingIndex === index) {
        resetView();
        return;
    }

    // Select it if not already selected
    if (selectedIndex !== index) {
        selectSatellite(index);
    }

    trackingIndex = index;
    const sat = satellites[index];
    const satPos = new THREE.Vector3(sat.x, sat.y, sat.z);
    const endDir = satPos.clone().normalize();

    // Keep current distance, rotate around the globe to face the satellite
    const dist = camera.position.length();
    const cp = camera.position;

    // Convert start/end to lat/lon so we rotate around rather than over the globe
    const startLat = Math.asin(cp.y / dist);
    const startLon = Math.atan2(cp.z, cp.x);
    const endLat = Math.asin(endDir.y);
    const endLon = Math.atan2(endDir.z, endDir.x);

    // Shortest longitude path (wrap around)
    let dLon = endLon - startLon;
    if (dLon > Math.PI) dLon -= 2 * Math.PI;
    if (dLon < -Math.PI) dLon += 2 * Math.PI;

    // Duration based on total angular distance (lon dominates)
    const totalAngle = Math.abs(dLon) + Math.abs(endLat - startLat);
    const ratio = totalAngle / Math.PI;
    const duration = 1.0 + ratio * ratio * 5.0;
    cameraAnim = {
        startLat, startLon, endLat, dLon,
        dist: dist,
        startTarget: controls.target.clone(),
        endTarget: new THREE.Vector3(0, 0, 0),
        progress: 0,
        duration: duration,
    };

    // Refresh orbit path with past/future tracking colours
    showOrbitPath(index);

    // Dim all non-selected satellites
    dimOtherSatellites(index);

    // Show tracking halo + direction arrow
    createTrackingHalo();
    updateTrackingHalo();
    createTrackingArrow();
    updateTrackingArrow();

    // Reset follow mode
    followMode = false;
    document.getElementById('detail-track').classList.remove('active');
    document.getElementById('detail-track').textContent = 'Follow';
}

function panToPlane(planeNum) {
    // Compute the orbital plane normal, then rotate 90° so the camera
    // looks along the plane edge-on from the equator — one half of the
    // satellite ring visible as a vertical line, the other half behind Earth.
    const positions = [];
    for (const sat of satellites) {
        if (sat.plane === planeNum) {
            positions.push(new THREE.Vector3(sat.x, sat.y, sat.z));
        }
    }
    if (positions.length < 2) return;

    // Average cross-products of well-spaced position pairs → plane normal
    const normal = new THREE.Vector3(0, 0, 0);
    const quarter = Math.max(1, Math.floor(positions.length / 4));
    for (let i = 0; i < positions.length; i++) {
        const j = (i + quarter) % positions.length;
        const cross = new THREE.Vector3().crossVectors(positions[i], positions[j]);
        normal.add(cross);
    }
    normal.normalize();

    // Camera: inclination-style tilt, but pick whichever side of the plane is closer
    const sat0 = satellites.find(s => s.plane === planeNum);
    const raanRad = sat0.satrec.nodeo;
    const incRad = sat0.satrec.inclo;
    const incDeg = incRad * RAD2DEG;
    const gmst = referenceFrame === 'eci' ? 0 : satellite.gstime(simTime);
    const anScene = eciToScene(Math.cos(raanRad), Math.sin(raanRad), 0, gmst).normalize();
    const eqForward = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), anScene).normalize();
    const orbitR = EARTH_RADIUS + (sat0.alt || 1200) * SAT_SCALE;
    const anPoint = anScene.clone().multiplyScalar(orbitR);
    const arcR = orbitR * 0.55 * 0.6;
    const midTheta = (incDeg / 2) * DEG2RAD;
    const kCrossD = new THREE.Vector3().crossVectors(anScene, eqForward);
    const midDir = new THREE.Vector3().copy(eqForward).multiplyScalar(Math.cos(midTheta)).addScaledVector(kCrossD, Math.sin(midTheta));
    const camTarget = anPoint.clone().addScaledVector(midDir.normalize(), arcR * 1.6).normalize();
    // Flip to whichever side is closer to current camera — avoid swinging all the way round
    const camDir = camera.position.clone().normalize();
    if (camTarget.dot(camDir) < 0) camTarget.negate();
    // Always look slightly down (positive latitude) regardless of which side
    const endLat = Math.abs(Math.asin(camTarget.y));
    animateCameraToVizView(endLat, Math.atan2(camTarget.z, camTarget.x), 20);
}

function stopTracking() {
    trackingIndex = -1;
    cameraAnim = null;
    followMode = false;
    removeTrackingHalo();
    removeTrackingArrow();
    restoreAllSatColors();
}

function disableFollowMode() {
    if (!followMode) return;
    followMode = false;
    const btn = document.getElementById('detail-track');
    if (btn) {
        btn.classList.remove('active');
        btn.textContent = 'Follow';
    }
}

function resetView() {
    closeGeoPanel();
    clearOrbitalViz();
    // Clear satellite selection
    if (selectedIndex >= 0) {
        resetSatColor(selectedIndex);
        const oldItem = document.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        selectedIndex = -1;
        $detailPanel.classList.add('hidden');
        clearOrbitPath();
        clearCoverageFootprint();
        clearTtcPasses();
    }
    // Clear plane selection
    if (selectedPlane >= 0) {
        const oldPlaneItem = document.querySelector('.plane-item.selected');
        if (oldPlaneItem) oldPlaneItem.classList.remove('selected');
        selectedPlane = -1;
        removePlaneGlow();
    }
    stopTracking();
    restoreAllSatColors();

    // Animate back to default UK view
    const cp = camera.position;
    const dist = cp.length();
    const startLat = Math.asin(cp.y / dist);
    const startLon = Math.atan2(cp.z, cp.x);
    const endDir = defaultCameraPos.clone().normalize();
    const endLat = Math.asin(endDir.y);
    const endLon = Math.atan2(endDir.z, endDir.x);
    let dLon = endLon - startLon;
    if (dLon > Math.PI) dLon -= 2 * Math.PI;
    if (dLon < -Math.PI) dLon += 2 * Math.PI;
    const totalAngle = Math.abs(dLon) + Math.abs(endLat - startLat);
    const ratio = totalAngle / Math.PI;
    const duration = 1.0 + ratio * ratio * 5.0;
    cameraAnim = {
        startLat, startLon, endLat, dLon,
        dist: defaultDist,
        startTarget: controls.target.clone(),
        endTarget: defaultCameraTarget.clone(),
        progress: 0,
        duration: duration,
    };
}

function dimOtherSatellites(keepIndex) {
    if (!satColorAttr) return;
    for (let i = 0; i < satellites.length; i++) {
        if (i === keepIndex) {
            satColorAttr.setXYZ(i, 1.0, 0.42, 0.21); // orange
        } else {
            satColorAttr.setXYZ(i, 0.08, 0.12, 0.18); // very dim
        }
    }
    satColorAttr.needsUpdate = true;
}

function selectPlane(planeNum) {
    // Check if any satellites are in this plane
    const hasPlane = satellites.some(s => s.plane === planeNum);
    if (!hasPlane) return;

    // Deselect old plane item in list
    const oldPlaneItem = $satList.querySelector('.plane-item.selected');
    if (oldPlaneItem) oldPlaneItem.classList.remove('selected');

    // Toggle off if already selected
    if (selectedPlane === planeNum) {
        selectedPlane = -1;
        removePlaneGlow();
        restoreAllSatColors();
        return;
    }

    // Clear any individual satellite selection/tracking and orbital viz
    clearOrbitalViz();
    if (selectedIndex >= 0) {
        const oldItem = document.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        selectedIndex = -1;
    }
    stopTracking();
    document.getElementById('detail-panel').classList.add('hidden');
    clearOrbitPath();
    clearCoverageFootprint();
    clearTtcPasses();

    selectedPlane = planeNum;

    // Mark plane item as selected in list
    const planeItem = $satList.querySelector(`.plane-item[data-plane="${planeNum}"]`);
    if (planeItem) planeItem.classList.add('selected');

    // Highlight all satellites in this plane bright cyan, dim the rest
    if (!satColorAttr) return;
    for (let i = 0; i < satellites.length; i++) {
        if (satellites[i].plane === planeNum) {
            satColorAttr.setXYZ(i, 0.2, 0.85, 1.0); // bright cyan
        } else {
            satColorAttr.setXYZ(i, 0.05, 0.08, 0.12); // very dim
        }
    }
    satColorAttr.needsUpdate = true;

    // Add big blue glow overlay
    showPlaneGlow(planeNum);

    // Pan camera to edge-on view of the plane (skip for unassigned — not a coherent plane)
    if (planeNum !== 0) panToPlane(planeNum);

    // Show rotate buttons
}

function restoreAllSatColors() {
    if (!satColorAttr) return;
    for (let i = 0; i < satellites.length; i++) {
        if (satellites[i].excluded) {
            satColorAttr.setXYZ(i, 1.0, 0.2, 0.2); // red for excluded
        } else if (selectedPlane >= 0 && satellites[i].plane === selectedPlane) {
            satColorAttr.setXYZ(i, 0.2, 0.85, 1.0); // bright cyan for plane
        } else if (i === selectedIndex) {
            satColorAttr.setXYZ(i, 1.0, 0.42, 0.21);
        } else if (selectedPlane >= 0) {
            satColorAttr.setXYZ(i, 0.05, 0.08, 0.12); // dim when plane active
        } else {
            satColorAttr.setXYZ(i, 0, 0.9, 1.0);
        }
    }
    satColorAttr.needsUpdate = true;
}

function updateCameraAnimation(dt) {
    if (!cameraAnim) return;

    cameraAnim.progress = Math.min(1, cameraAnim.progress + dt / cameraAnim.duration);
    const t = easeInOutCubic(cameraAnim.progress);

    // Interpolate lat/lon separately — rotates around the globe, not over the top
    const lat = cameraAnim.startLat + (cameraAnim.endLat - cameraAnim.startLat) * t;
    const lon = cameraAnim.startLon + cameraAnim.dLon * t;
    const r = cameraAnim.startDist !== undefined
        ? cameraAnim.startDist + (cameraAnim.endDist - cameraAnim.startDist) * t
        : cameraAnim.dist;
    camera.position.set(
        r * Math.cos(lat) * Math.cos(lon),
        r * Math.sin(lat),
        r * Math.cos(lat) * Math.sin(lon)
    );
    controls.target.lerpVectors(cameraAnim.startTarget, cameraAnim.endTarget, t);

    if (cameraAnim.progress >= 1) {
        cameraAnim = null;
    }
}

function updateTracking() {
    if (!followMode) return;
    if (trackingIndex < 0 || trackingIndex >= satellites.length) return;
    if (cameraAnim) return;

    const sat = satellites[trackingIndex];
    _satPos.set(sat.x, sat.y, sat.z);
    _trackDir.copy(_satPos).normalize();

    const dist = camera.position.length();
    _trackTarget.copy(_trackDir).multiplyScalar(dist);

    camera.position.lerp(_trackTarget, 0.025);
    // Maintain distance — prevent inward spiral at high speeds
    // (straight-line lerp cuts through the sphere, shrinking radius each frame)
    camera.position.normalize().multiplyScalar(dist);
}

// ============================================================
// INTERACTION
// ============================================================
function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    _lastMouseX = event.clientX;
    _lastMouseY = event.clientY;
    _mouseDirty = true;
}

function showTooltip(html, x, y, cursor) {
    if (_tooltipContent !== html) {
        $tooltip.innerHTML = html;
        _tooltipContent = html;
    }
    if (_tooltipX !== x || _tooltipY !== y) {
        $tooltip.style.transform = `translate(${x}px, ${y}px)`;
        _tooltipX = x; _tooltipY = y;
    }
    $tooltip.classList.add('visible');
    renderer.domElement.style.cursor = cursor;
}

function hideTooltip() {
    if (_tooltipContent !== '') {
        _tooltipContent = '';
        $tooltip.classList.remove('visible');
        renderer.domElement.style.cursor = 'grab';
    }
}

// Returns true if satellite at given index is on the visible side of the globe
function isSatVisible(idx) {
    const sat = satellites[idx];
    _satPos.set(sat.x, sat.y, sat.z);
    _camToStation.copy(_satPos).sub(camera.position).normalize();
    raycaster.set(camera.position, _camToStation);
    const hit = raycaster.ray.intersectSphere(_earthSphere, _intersectPt);
    if (!hit) return true;
    const distToSat = camera.position.distanceTo(_satPos);
    return camera.position.distanceTo(_intersectPt) >= distToSat * 0.98;
}

// Called once per frame from animate() — replaces per-mousemove raycasting
function processMouseHover() {
    if (!_mouseDirty || !satPointCloud) return;
    _mouseDirty = false;

    const tx = _lastMouseX + 14;
    const ty = _lastMouseY - 10;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(satPointCloud);

    if (intersects.length > 0) {
        // Find the nearest visible satellite (skip those behind Earth)
        let hitIdx = -1;
        for (let i = 0; i < intersects.length; i++) {
            if (isSatVisible(intersects[i].index)) {
                hitIdx = intersects[i].index;
                break;
            }
        }

        if (hitIdx >= 0) {
            if (hitIdx !== hoveredIndex) {
                if (hoveredIndex >= 0 && hoveredIndex !== selectedIndex) resetSatColor(hoveredIndex);
                hoveredIndex = hitIdx;
                if (hoveredIndex !== selectedIndex) {
                    setSatColor(hoveredIndex, satellites[hoveredIndex].excluded ? 1.0 : 0.3, satellites[hoveredIndex].excluded ? 0.4 : 1.0, satellites[hoveredIndex].excluded ? 0.4 : 0.6);
                }
            }
            // Hover expand sprite (skip for already-selected satellite)
            const hSat = satellites[hitIdx];
            if (hitIdx !== selectedIndex) {
                if (!hoverSprite) {
                    const hMat = new THREE.SpriteMaterial({ map: satPointCloud.material.map.clone(), transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
                    hoverSprite = new THREE.Sprite(hMat);
                    hoverSprite.renderOrder = 2;
                    scene.add(hoverSprite);
                }
                const hc = hSat.excluded ? [1.0, 0.4, 0.4] : [0.3, 1.0, 0.6];
                hoverSprite.material.color.setRGB(hc[0], hc[1], hc[2]);
                hoverSprite.position.set(hSat.x, hSat.y, hSat.z);
                hoverSprite.scale.set(0.45, 0.45, 1);
                hoverSprite.visible = true;
            } else {
                if (hoverSprite) hoverSprite.visible = false;
            }
            showTooltip(
                `<strong>${hSat.name}</strong><br>Alt: ${Math.round(hSat.alt)} km &middot; ${hSat.lat.toFixed(1)}&deg;, ${hSat.lon.toFixed(1)}&deg;`,
                tx, ty, 'pointer'
            );
        } else {
            // All hits were behind Earth
            if (hoveredIndex >= 0 && hoveredIndex !== selectedIndex) resetSatColor(hoveredIndex);
            hoveredIndex = -1;
            if (hoverSprite) hoverSprite.visible = false;
            hideTooltip();
        }
    } else {
        if (hoveredIndex >= 0 && hoveredIndex !== selectedIndex) resetSatColor(hoveredIndex);
        hoveredIndex = -1;
        if (hoverSprite) hoverSprite.visible = false;

        // Check GEO satellite hover
        let geoHit = false;
        if (geoPointCloud && geoSatsVisible) {
            const geoHits = raycaster.intersectObject(geoPointCloud);
            for (let i = 0; i < geoHits.length; i++) {
                if (isGeoSatVisible(geoHits[i].index)) {
                    const gs = geoSatellites[geoHits[i].index];
                    const dn = gs.name.replace(/^EUTELSAT\s*/i, '').trim() || gs.name;
                    const absLon = Math.abs(gs.lon).toFixed(1);
                    const dir = gs.lon >= 0 ? 'E' : 'W';
                    showTooltip(
                        `<strong>${dn}</strong><br>${absLon}&deg;${dir} &middot; ${Math.round(gs.alt).toLocaleString()} km`,
                        tx, ty, 'pointer'
                    );
                    geoHit = true;
                    break;
                }
            }
        }

        // Check catalog satellite hover — single merged cloud raycast
        let catalogHit = false;
        if (!geoHit && _catalogMerged.pointCloud && _catalogMerged.totalUsed > 0) {
            const catHits = raycaster.intersectObject(_catalogMerged.pointCloud);
            for (let i = 0; i < catHits.length; i++) {
                const mapped = _catalogMergedIndexToGroup(catHits[i].index);
                if (!mapped) continue;
                const cs = catalogState[mapped.groupKey];
                if (!cs || !cs.visible) continue;
                if (isCatalogSatVisible(mapped.groupKey, mapped.localIndex)) {
                    const sat = cs.satellites[mapped.localIndex];
                    const group = CATALOG_GROUPS.find(g => g.key === mapped.groupKey);
                    showTooltip(
                        `<strong>${sat.name}</strong><br>${group ? group.label : mapped.groupKey} &middot; Alt: ${Math.round(sat.alt)} km`,
                        tx, ty, 'pointer'
                    );
                    catalogHit = true;
                    break;
                }
            }
        }

        if (geoHit || catalogHit) { /* already showing tooltip */ }
        // Check sun/moon hover (only when no satellite hit)
        else {
        let celestialHit = false;
        if (sunMesh && sunMesh.visible) {
            const sunHits = raycaster.intersectObject(sunMesh, true);
            if (sunHits.length > 0) {
                showTooltip('<strong>Sun</strong>', tx, ty, 'default');
                celestialHit = true;
            }
        }
        if (!celestialHit && moonMesh) {
            const moonHits = raycaster.intersectObject(moonMesh, true);
            if (moonHits.length > 0) {
                showTooltip('<strong>Moon</strong>', tx, ty, 'default');
                celestialHit = true;
            }
        }
        if (!celestialHit) {
            hideTooltip();
        }
        } // end else (sun/moon)
    }
}

function onMouseClick(event) {
    raycaster.setFromCamera(mouse, camera);

    // Check LEO satellites
    if (satPointCloud) {
        const intersects = raycaster.intersectObject(satPointCloud);
        for (let i = 0; i < intersects.length; i++) {
            if (isSatVisible(intersects[i].index)) {
                closeGeoPanel();
                selectSatellite(intersects[i].index);
                return;
            }
        }
    }

    // Check GEO satellites
    if (geoPointCloud && geoSatsVisible) {
        const geoHits = raycaster.intersectObject(geoPointCloud);
        for (let i = 0; i < geoHits.length; i++) {
            if (isGeoSatVisible(geoHits[i].index)) {
                selectGeoSatellite(geoHits[i].index);
                return;
            }
        }
    }

    // Check catalog satellites — single merged cloud raycast
    if (_catalogMerged.pointCloud && _catalogMerged.totalUsed > 0) {
        const catHits = raycaster.intersectObject(_catalogMerged.pointCloud);
        for (let i = 0; i < catHits.length; i++) {
            const mapped = _catalogMergedIndexToGroup(catHits[i].index);
            if (!mapped) continue;
            const cs = catalogState[mapped.groupKey];
            if (!cs || !cs.visible) continue;
            if (isCatalogSatVisible(mapped.groupKey, mapped.localIndex)) {
                selectCatalogSatellite(mapped.groupKey, mapped.localIndex);
                return;
            }
        }
    }
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    // Update merged catalog shader scale uniform
    if (_catalogMerged.material) {
        _catalogMerged.material.uniforms.uScale.value = window.innerHeight * (window.devicePixelRatio || 1) / 2.0;
    }
}

// ============================================================
// SPEED CONTROLS (slider: 1x–1200x, exponential curve)
// ============================================================
const $speedSlider = document.getElementById('speed-slider');
const $speedLabel = document.getElementById('speed-label');

function sliderToSpeed(val) {
    // Exponential: 0→1x, ±100→±1200x. Negative = reverse.
    if (val === 0) return 1;
    const sign = val > 0 ? 1 : -1;
    return sign * Math.round(Math.pow(1200, Math.abs(val) / 100));
}

function speedToSlider(speed) {
    if (Math.abs(speed) <= 1) return 0;
    const sign = speed > 0 ? 1 : -1;
    return sign * Math.round(100 * Math.log(Math.abs(speed)) / Math.log(1200));
}

function updateSpeedLabel(speed) {
    if (speed < 0) {
        $speedLabel.textContent = speed + 'x';
        $speedLabel.style.color = '#ff6b35';
    } else {
        $speedLabel.textContent = speed + 'x';
        $speedLabel.style.color = '';
    }
}

$speedSlider.addEventListener('input', () => {
    const speed = sliderToSpeed(parseInt($speedSlider.value));
    timeMultiplier = speed;
    _liveMode = false;
    if (_paused) {
        _paused = false;
        document.getElementById('pause-btn').classList.remove('paused');
        document.getElementById('pause-btn').innerHTML = '&#x23F8;';
    }
    updateSpeedLabel(speed);
});

// ============================================================
// LIVE BUTTON — reset to real time at 1x
// ============================================================
document.getElementById('live-btn').addEventListener('click', () => {
    simTime = new Date();
    timeMultiplier = 1;
    _liveMode = true;
    _paused = false;
    document.getElementById('pause-btn').classList.remove('paused');
    document.getElementById('pause-btn').innerHTML = '&#x23F8;';
    $speedSlider.value = '0';
    updateSpeedLabel(1);
    _ttcDirty = true;
});

// ============================================================
// PAUSE BUTTON
// ============================================================
document.getElementById('pause-btn').addEventListener('click', () => {
    _paused = !_paused;
    const btn = document.getElementById('pause-btn');
    btn.classList.toggle('paused', _paused);
    btn.innerHTML = _paused ? '&#x25B6;' : '&#x23F8;';
    if (_paused) {
        _liveMode = false;
    }
});

// ============================================================
// PANEL TOGGLE
// ============================================================
const $panelToggle = document.getElementById('panel-toggle');
$panelToggle.addEventListener('click', () => {
    panelOpen = !panelOpen;
    document.getElementById('side-panel').classList.toggle('collapsed', !panelOpen);
    $panelToggle.classList.toggle('panel-open', panelOpen);
    $panelToggle.innerHTML = panelOpen ? '&#x25C0;' : '&#x25B6;';
});

// ============================================================
// TT&C ALARM TOGGLE
// ============================================================
document.getElementById('detail-alarm').addEventListener('click', () => {
    if (selectedIndex < 0) return;
    toggleAlarm(selectedIndex);
});

// ============================================================
// DETAIL BEAMS TOGGLE
// ============================================================
document.getElementById('detail-beams').addEventListener('click', () => {
    if (selectedIndex < 0) return;
    const btn = document.getElementById('detail-beams');
    if (beamMode === 'individual') {
        beamMode = 'off';
        btn.classList.remove('active');
        clearCoverageFootprint();
    } else {
        if (beamMode === 'all') clearAllBeams();
        beamMode = 'individual';
        btn.classList.add('active');
        createCoverageFootprint();
    }
});

// ============================================================
// ORBITAL ELEMENT PLOT POPUP
// ============================================================

// This function runs INSIDE the popup's window context (injected via script element).
// All globals (document, window, Plotly, satellite) refer to the popup's own scope.
function _popupAppMain() {
    var MU = 398600.4418;
    var R2D = 180 / Math.PI;
    var D2R = Math.PI / 180;
    var sats = window._SAT_DATA;
    var COLORS = window._COLORS;
    var ELEMENTS = window._ELEMENTS;
    var plotData = null;

    // Parse datetime-local input value as UTC
    function inputToUTC(inputEl) {
        var val = inputEl.value;
        if (!val) return new Date(NaN);
        return new Date(val + 'Z');
    }

    function propagateData() {
        var idx = parseInt(document.getElementById('satSelect').value);
        var sat = sats[idx];
        if (!sat) return null;
        var satrec = sat.satrec;
        document.getElementById('title').textContent = 'Orbital Elements \u2014 ' + sat.name;

        var start = inputToUTC(document.getElementById('startTime'));
        var end = inputToUTC(document.getElementById('endTime'));
        if (isNaN(start) || isNaN(end) || end <= start) return null;

        var stepMs = 30000;
        var res = {times:[],lat:[],lon:[],alt:[],speed:[],inc:[],ecc:[],raan:[],aol:[],sma:[]};

        for (var t = start.getTime(); t <= end.getTime(); t += stepMs) {
            var d = new Date(t);
            var pv = satellite.propagate(satrec, d);
            if (!pv.position || !pv.velocity) continue;
            var r = pv.position, v = pv.velocity;
            var gmst = satellite.gstime(d);
            var geo = satellite.eciToGeodetic(r, gmst);

            var rx = r.x, ry = r.y, rz = r.z;
            var vx = v.x, vy = v.y, vz = v.z;
            var rM = Math.sqrt(rx*rx + ry*ry + rz*rz);
            var vM = Math.sqrt(vx*vx + vy*vy + vz*vz);

            var hx = ry*vz - rz*vy, hy = rz*vx - rx*vz, hz = rx*vy - ry*vx;
            var hM = Math.sqrt(hx*hx + hy*hy + hz*hz);

            var vxh_x = vy*hz - vz*hy, vxh_y = vz*hx - vx*hz, vxh_z = vx*hy - vy*hx;
            var ex = vxh_x/MU - rx/rM, ey = vxh_y/MU - ry/rM, ez = vxh_z/MU - rz/rM;
            var ecc = Math.sqrt(ex*ex + ey*ey + ez*ez);

            var inc = Math.acos(Math.max(-1, Math.min(1, hz / hM))) * R2D;
            var sma = 1 / (2/rM - vM*vM/MU);

            var nnx = -hy, nny = hx;
            var nM = Math.sqrt(nnx*nnx + nny*nny);
            var raanVal = 0;
            if (nM > 1e-10) {
                raanVal = Math.acos(Math.max(-1, Math.min(1, nnx / nM)));
                if (nny < 0) raanVal = 2*Math.PI - raanVal;
            }

            var nx2 = Math.cos(raanVal), ny2 = Math.sin(raanVal);
            var px = rx * nx2 + ry * ny2;
            var py = (-rx * ny2 + ry * nx2) * Math.cos(inc * D2R) + rz * Math.sin(inc * D2R);
            var aol = ((Math.atan2(py, px) * R2D) % 360 + 360) % 360;

            res.times.push(d.toISOString());
            res.lat.push(geo.latitude * R2D);
            res.lon.push(geo.longitude * R2D);
            res.alt.push(geo.height);
            res.speed.push(vM);
            res.inc.push(inc);
            res.ecc.push(ecc);
            res.raan.push(raanVal * R2D);
            res.aol.push(aol);
            res.sma.push(sma);
        }

        // Unwrap longitude to prevent vertical lines at ±180° boundary
        for (var i = 1; i < res.lon.length; i++) {
            var diff = res.lon[i] - res.lon[i - 1];
            if (diff > 180) res.lon[i] -= 360;
            if (diff < -180) res.lon[i] += 360;
        }

        return res;
    }

    function updatePlot() {
        if (!plotData || !plotData.times.length) {
            document.getElementById('plot').innerHTML = '<div style="text-align:center;padding:60px;color:#8892a4;font-size:13px">No data \u2014 select elements and set a valid time range</div>';
            return;
        }
        var checks = document.querySelectorAll('#checks input[type=checkbox]');
        var traces = [];
        var yAxes = {};
        var axisCount = 0;

        var unitMap = {};
        ELEMENTS.forEach(function(e) { unitMap[e.key] = e.unit || ''; });

        checks.forEach(function(cb, i) {
            if (!cb.checked) return;
            var key = cb.dataset.key;
            var el = ELEMENTS[i];
            var unit = unitMap[key];

            var axisName;
            if (!yAxes[unit]) {
                axisCount++;
                axisName = axisCount === 1 ? 'y' : 'y' + axisCount;
                yAxes[unit] = {name: axisName, idx: axisCount};
            } else {
                axisName = yAxes[unit].name;
            }

            traces.push({
                x: plotData.times, y: plotData[key],
                type: 'scatter', mode: 'lines',
                name: el.label + (el.unit ? ' (' + el.unit + ')' : ''),
                line: {color: COLORS[i], width: 1.5},
                yaxis: axisName,
                hovertemplate: '%{y:.4f} ' + (el.unit || '') + '<extra>' + el.label + '</extra>'
            });
        });

        if (traces.length === 0) {
            Plotly.react('plot', [], {
                plot_bgcolor: '#0a0e14', paper_bgcolor: '#0a0e14',
                font: {color: '#8892a4', size: 13},
                xaxis: {visible: false}, yaxis: {visible: false},
                annotations: [{text: 'Select at least one element to plot', showarrow: false, font: {size: 14, color: '#8892a4'}}]
            }, {responsive: true, displayModeBar: false});
            return;
        }

        var layout = {
            plot_bgcolor: '#0a0e14', paper_bgcolor: '#0a0e14',
            font: {color: '#c8d0dc', size: 12, family: '-apple-system,BlinkMacSystemFont,sans-serif'},
            xaxis: {
                gridcolor: 'rgba(255,255,255,0.08)',
                title: {text: 'Time (UTC)', font: {size: 12, color: '#8892a4'}},
                tickfont: {size: 11},
                zeroline: false
            },
            legend: {orientation: 'h', y: -0.18, x: 0.5, xanchor: 'center', font: {size: 11}},
            margin: {l: 60, r: 60, t: 10, b: 70},
            hovermode: 'x unified',
            hoverlabel: {bgcolor: '#141a24', bordercolor: '#2a3a4a', font: {size: 12}}
        };

        // Unit labels for Y-axis titles
        var unitLabels = {'\u00B0': 'Degrees (\u00B0)', 'km': 'km', 'km/s': 'km/s', '': ''};

        var sides = ['left', 'right'];
        var sideIdx = 0;
        Object.keys(yAxes).forEach(function(unit) {
            var info = yAxes[unit];
            var axKey = info.idx === 1 ? 'yaxis' : 'yaxis' + info.idx;
            layout[axKey] = {
                title: {text: unitLabels[unit] || unit || '', font: {size: 11, color: '#8892a4'}},
                gridcolor: info.idx === 1 ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0)',
                tickfont: {size: 11},
                side: sides[sideIdx % 2],
                overlaying: info.idx > 1 ? 'y' : undefined,
                zeroline: false
            };
            sideIdx++;
        });

        Plotly.react('plot', traces, layout, {responsive: true, displayModeBar: true,
            modeBarButtonsToRemove: ['select2d', 'lasso2d']});
    }

    function runUpdate() {
        try {
            plotData = propagateData();
            updatePlot();
            var countEl = document.getElementById('dataCount');
            if (countEl) {
                countEl.textContent = plotData ? plotData.times.length + ' pts' : '';
            }
        } catch (e) {
            console.error('Plot error:', e);
            document.getElementById('plot').innerHTML = '<div style="text-align:center;padding:60px;color:#ff5252;font-size:13px">Error: ' + e.message + '</div>';
        }
    }

    function getSatName() {
        var sel = document.getElementById('satSelect');
        return sel.options[sel.selectedIndex].text.replace(/[^a-zA-Z0-9\-]/g, '_');
    }

    document.getElementById('btnPNG').addEventListener('click', function() {
        var name = getSatName();
        Plotly.downloadImage('plot', {format: 'png', width: 1400, height: 700, filename: 'orbital_' + name});
    });

    document.getElementById('btnCSV').addEventListener('click', function() {
        if (!plotData || !plotData.times.length) return;
        var headers = ['Time','Latitude (deg)','Longitude (deg)','Altitude (km)','Velocity (km/s)',
                       'Inclination (deg)','Eccentricity','RAAN (deg)','Arg of Latitude (deg)','Semi-major Axis (km)'];
        var keys = ['times','lat','lon','alt','speed','inc','ecc','raan','aol','sma'];
        var csv = headers.join(',') + '\n';
        for (var i = 0; i < plotData.times.length; i++) {
            csv += keys.map(function(k) { return plotData[k][i]; }).join(',') + '\n';
        }
        var blob = new Blob([csv], {type: 'text/csv'});
        var a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        var name = getSatName();
        a.download = 'orbital_' + name + '.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(a.href);
    });

    document.querySelectorAll('#checks input[type=checkbox]').forEach(function(cb) {
        cb.addEventListener('change', updatePlot);
    });

    document.getElementById('satSelect').addEventListener('change', function() {
        var idx = parseInt(document.getElementById('satSelect').value);
        if (sats[idx]) {
            var p = sats[idx].period || 109;
            var n = new Date();
            var s = new Date(n.getTime() - p * 60000);
            var e = new Date(n.getTime() + p * 60000);
            document.getElementById('startTime').value = s.toISOString().slice(0, 16);
            document.getElementById('endTime').value = e.toISOString().slice(0, 16);
        }
        runUpdate();
    });

    document.getElementById('btnUpdate').addEventListener('click', runUpdate);

    // Remove loading spinner before first plot
    var loadingEl = document.getElementById('loading');
    if (loadingEl) loadingEl.remove();
    runUpdate();
}

document.getElementById('detail-plot').addEventListener('click', () => {
    if (selectedIndex < 0) return;
    const sat = satellites[selectedIndex];
    const period = sat.period || 109;
    const now = new Date(simTime);
    const startDefault = new Date(now.getTime() - period * 60000);
    const endDefault = new Date(now.getTime() + period * 60000);

    const satOptions = satellites.map((s, i) =>
        '<option value="' + i + '"' + (i === selectedIndex ? ' selected' : '') + '>' + s.name + '</option>'
    ).join('');

    const colors = ['#00d4ff','#ff6b35','#4caf50','#e040fb','#ffeb3b','#ff5252','#00e5ff','#76ff03','#ffd740'];
    // If an orbital viz is active, pre-select that element instead of altitude
    const vizToKey = { inclination: 'inc', raan: 'raan', aol: 'aol', eccentricity: 'ecc' };
    const activeKey = vizToKey[orbitalVizMode] || null;
    const defaultKey = activeKey || 'alt';
    const elements = [
        {key:'lat',label:'Latitude',unit:'\u00B0',checked:false},
        {key:'lon',label:'Longitude',unit:'\u00B0',checked:false},
        {key:'alt',label:'Altitude',unit:'km',checked:defaultKey === 'alt'},
        {key:'speed',label:'Velocity',unit:'km/s',checked:false},
        {key:'inc',label:'Inclination',unit:'\u00B0',checked:defaultKey === 'inc'},
        {key:'ecc',label:'Eccentricity',unit:'',checked:defaultKey === 'ecc'},
        {key:'raan',label:'RAAN',unit:'\u00B0',checked:defaultKey === 'raan'},
        {key:'aol',label:'Arg of Latitude',unit:'\u00B0',checked:defaultKey === 'aol'},
        {key:'sma',label:'Semi-major Axis',unit:'km',checked:false}
    ];

    const checkboxHtml = elements.map((e, i) =>
        '<label class="check-label">' +
        '<input type="checkbox" data-key="' + e.key + '"' + (e.checked ? ' checked' : '') + ' style="accent-color:' + colors[i] + '"> ' +
        '<span style="color:' + colors[i] + '">' + e.label + (e.unit ? ' (' + e.unit + ')' : '') + '</span></label>'
    ).join('');

    const pw = Math.min(Math.round(window.innerWidth * 0.85), 1200);
    const ph = Math.min(Math.round(window.innerHeight * 0.85), 800);
    const popupWindow = window.open('', '', 'width=' + pw + ',height=' + ph);
    if (!popupWindow) return;

    // Write full HTML structure immediately (no scripts yet)
    // Time inputs display UTC ISO values directly (parsed as UTC in popup via 'Z' suffix)
    const startVal = startDefault.toISOString().slice(0, 16);
    const endVal = endDefault.toISOString().slice(0, 16);
    popupWindow.document.open();
    popupWindow.document.write(`<!DOCTYPE html><html><head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Orbital Elements \u2014 ${sat.name}</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0e14;color:#c8d0dc;font-family:-apple-system,BlinkMacSystemFont,sans-serif;padding:14px;display:flex;flex-direction:column;height:100vh;overflow:hidden}
.header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;flex-shrink:0}
.header h2{font-size:15px;font-weight:600;color:#e8ecf2;letter-spacing:0.3px}
.header .btns{display:flex;gap:6px;align-items:center}
.data-count{font-size:11px;color:#5a6a7a;font-family:'JetBrains Mono',monospace;margin-right:4px}
.btn{padding:6px 14px;background:transparent;border:1px solid #1e2a3a;border-radius:6px;color:#8892a4;cursor:pointer;font-size:12px;transition:all 0.2s;white-space:nowrap}
.btn:hover{border-color:#00d4ff;color:#e8ecf2}
.btn:active{border-color:#00d4ff;background:rgba(0,212,255,0.08)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:8px;flex-shrink:0}
.controls label{font-size:12px;color:#8892a4;display:inline-flex;align-items:center;gap:4px}
.controls select,.controls input{background:#0d1117;border:1px solid #1e2a3a;border-radius:4px;color:#c8d0dc;padding:5px 8px;font-size:12px;transition:border-color 0.2s}
.controls select:focus,.controls input:focus{border-color:#00d4ff;outline:none}
.controls select:hover,.controls input:hover{border-color:rgba(0,212,255,0.3)}
.controls select{min-width:200px}
.checks{margin-bottom:8px;display:flex;flex-wrap:wrap;gap:6px 4px;flex-shrink:0}
.check-label{display:inline-flex;align-items:center;gap:5px;cursor:pointer;font-size:12px;padding:3px 8px;border-radius:4px;transition:background 0.15s}
.check-label:hover{background:rgba(255,255,255,0.04)}
.check-label input[type=checkbox]{cursor:pointer}
#plot{width:100%;flex:1;min-height:250px}
#loading{display:flex;align-items:center;justify-content:center;height:100%;color:#8892a4;font-size:13px;gap:12px;flex-direction:column}
#loading::before{content:'';width:28px;height:28px;border:2px solid #1e2a3a;border-top-color:#00d4ff;border-radius:50%;animation:spin 0.8s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
</style>
</head><body>
<div class="header">
    <h2 id="title">Orbital Elements \u2014 ${sat.name}</h2>
    <div class="btns">
        <span class="data-count" id="dataCount"></span>
        <button class="btn" id="btnPNG">Export PNG</button>
        <button class="btn" id="btnCSV">Export CSV</button>
    </div>
</div>
<div class="controls">
    <label>Satellite <select id="satSelect">${satOptions}</select></label>
    <label>Start (UTC) <input type="datetime-local" id="startTime" value="${startVal}"></label>
    <label>End (UTC) <input type="datetime-local" id="endTime" value="${endVal}"></label>
    <button class="btn" id="btnUpdate">Update</button>
</div>
<div class="checks" id="checks">${checkboxHtml}</div>
<div id="plot"><div id="loading">Loading libraries...</div></div>
</body></html>`);
    popupWindow.document.close();

    // Inject data onto popup window — accessible as window._SAT_DATA etc in popup context
    popupWindow._SAT_DATA = satellites.map(s => ({
        name: s.name, period: s.period, satrec: s.satrec
    }));
    popupWindow._COLORS = colors;
    popupWindow._ELEMENTS = elements;

    // Load satellite.js → Plotly → inject app script (all run in popup's context)
    const loadErr = msg => { popupWindow.document.getElementById('loading').textContent = msg; };
    const satScript = popupWindow.document.createElement('script');
    satScript.src = 'https://cdn.jsdelivr.net/npm/satellite.js@5.0.0/dist/satellite.min.js';
    satScript.onerror = () => loadErr('Failed to load satellite.js');
    satScript.onload = () => {
        const plotlyScript = popupWindow.document.createElement('script');
        plotlyScript.src = 'https://cdn.jsdelivr.net/npm/plotly.js-dist-min@2.35.2/plotly.min.js';
        plotlyScript.onerror = () => loadErr('Failed to load Plotly.js');
        plotlyScript.onload = () => {
            // Inject app logic as a script element — runs in the POPUP's window context
            // so Plotly, satellite, document, window all refer to the popup's own globals
            const appScript = popupWindow.document.createElement('script');
            appScript.textContent = '(' + _popupAppMain.toString() + ')()';
            popupWindow.document.body.appendChild(appScript);
        };
        popupWindow.document.head.appendChild(plotlyScript);
    };
    popupWindow.document.head.appendChild(satScript);
});

// ============================================================
// ALARM PANEL TOGGLE + CLOSE
// ============================================================
$alarmStat.addEventListener('click', () => {
    renderAlarmPanel();
    $alarmPanel.classList.toggle('visible');
});
document.getElementById('alarm-panel-close').addEventListener('click', () => {
    $alarmPanel.classList.remove('visible');
});
document.getElementById('ttc-toast-close').addEventListener('click', () => {
    $ttcToast.classList.remove('visible');
    stopAlarmSound();
});

// Manual alarm modal handlers
const $alarmModalOverlay = document.getElementById('alarm-modal-overlay');
document.getElementById('alarm-add-manual').addEventListener('click', () => {
    // Pre-fill time with current simTime in UTC
    const d = simTime || new Date();
    const iso = d.toISOString().slice(0, 16); // YYYY-MM-DDTHH:MM
    document.getElementById('alarm-time').value = iso;
    document.getElementById('alarm-scid').value = '';
    document.getElementById('alarm-desc').value = '';
    $alarmModalOverlay.classList.add('visible');
});
document.getElementById('alarm-modal-close').addEventListener('click', () => {
    $alarmModalOverlay.classList.remove('visible');
});
$alarmModalOverlay.addEventListener('click', (e) => {
    if (e.target === $alarmModalOverlay) $alarmModalOverlay.classList.remove('visible');
});
document.getElementById('alarm-modal-save').addEventListener('click', () => {
    const scid = document.getElementById('alarm-scid').value.trim();
    const desc = document.getElementById('alarm-desc').value.trim();
    const timeVal = document.getElementById('alarm-time').value;
    if (!scid || !timeVal) return;
    const time = new Date(timeVal + 'Z'); // treat as UTC
    if (isNaN(time.getTime())) return;
    _manualAlarms.push({ id: _manualAlarmId++, scid, description: desc, time, fired: false });
    saveManualAlarms();
    updateAlarmCount();
    renderAlarmPanel();
    $alarmModalOverlay.classList.remove('visible');
});

// Alarm confirm modal handlers
const $alarmConfirmOverlay = document.getElementById('alarm-confirm-overlay');
function hideAlarmConfirm() {
    $alarmConfirmOverlay.classList.remove('visible');
    _alarmConfirmCallback = null;
}
document.getElementById('alarm-confirm-close').addEventListener('click', hideAlarmConfirm);
document.getElementById('alarm-confirm-cancel').addEventListener('click', hideAlarmConfirm);
$alarmConfirmOverlay.addEventListener('click', (e) => {
    if (e.target === $alarmConfirmOverlay) hideAlarmConfirm();
});
document.getElementById('alarm-confirm-yes').addEventListener('click', () => {
    if (_alarmConfirmCallback) _alarmConfirmCallback();
    hideAlarmConfirm();
});

// ============================================================
// DETAIL CLOSE
// ============================================================
document.getElementById('detail-close').addEventListener('click', () => {
    if (window.innerWidth <= 480) {
        // Mobile: just hide panel (existing behavior)
        $detailPanel.classList.add('hidden');
        $ttcPanelSvalbard.classList.remove('visible');
        $ttcPanelInuvik.classList.remove('visible');
    } else if (selectedCatalogGroup && selectedCatalogIndex >= 0) {
        // Catalog satellite selected — clear it
        clearCatalogSelection();
        $detailPanel.classList.add('hidden');
        clearOrbitPath();
    } else {
        // Desktop: full deselect (OneWeb)
        stopTracking();
        const oldItem = document.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        resetSatColor(selectedIndex);
        selectedIndex = -1;
        $detailPanel.classList.add('hidden');
        clearOrbitPath();
        clearCoverageFootprint();
        clearTtcPasses();
    }
});

document.getElementById('detail-track').addEventListener('click', () => {
    if (trackingIndex < 0) return;
    followMode = !followMode;
    const btn = document.getElementById('detail-track');
    btn.classList.toggle('active', followMode);
    btn.textContent = followMode ? 'Following' : 'Follow';
});

// ============================================================
// SEARCH
// ============================================================
$searchInput.addEventListener('input', (e) => filterSatList(e.target.value));

// Enter key in search: select + focus first visible result
$searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        const q = $searchInput.value.trim();
        if (!q) return;
        const planeMatch = q.match(/^plane\s*(\d+)$/i);
        if (planeMatch) {
            const planeNum = parseInt(planeMatch[1], 10);
            selectPlane(planeNum);
            return;
        }
        // Formation keyword match
        const formMatch = q.match(/^(supersmash|super\s*smash|monstermash|monster\s*mash)$/i);
        if (formMatch) {
            const formType = formMatch[1].replace(/\s+/g, '').toLowerCase();
            const formations = _formations[formType];
            if (!formations || formations.length === 0) return;
            // Collect all formation satellite indices
            const formSet = new Set();
            formations.forEach(f => f.indices.forEach(idx => formSet.add(idx)));
            // Highlight formation satellites on 3D globe
            if (satColorAttr) {
                for (let i = 0; i < satellites.length; i++) {
                    if (formSet.has(i)) {
                        satColorAttr.setXYZ(i, 1.0, 0.2, 0.5); // magenta
                    } else {
                        satColorAttr.setXYZ(i, 0.05, 0.08, 0.12); // very dim
                    }
                }
                satColorAttr.needsUpdate = true;
            }
            return;
        }
        const ql = q.toLowerCase();
        // Check LEO satellites first
        const matchIdx = satellites.findIndex(
            s => s.name.toLowerCase().includes(ql) || String(s.noradId).includes(ql)
        );
        if (matchIdx >= 0) {
            selectSatellite(matchIdx);
            return;
        }
        // Check GEO satellites
        const geoIdx = geoSatellites.findIndex(
            s => s.name.toLowerCase().includes(ql) || String(s.noradId).includes(ql)
        );
        if (geoIdx >= 0) {
            focusGeoSatellite(geoIdx);
        }
    }
});


// ============================================================
// RESET VIEW
// ============================================================
document.getElementById('reset-view').addEventListener('click', resetView);

// ============================================================
// ROTATE VIEW ±90°
// ============================================================
function rotateView(degrees) {
    const radians = degrees * DEG2RAD;
    const dist = camera.position.length();
    const cp = camera.position;
    const startLat = Math.asin(cp.y / dist);
    const startLon = Math.atan2(cp.z, cp.x);

    cameraAnim = {
        startLat, startLon,
        endLat: startLat, // stay at same latitude
        dLon: radians,
        dist: dist,
        startTarget: controls.target.clone(),
        endTarget: new THREE.Vector3(0, 0, 0),
        progress: 0,
        duration: 1.5,
    };
}

document.getElementById('rotate-minus').addEventListener('click', () => rotateView(-90));
document.getElementById('rotate-plus').addEventListener('click', () => rotateView(90));

// ============================================================
// ANIMATION LOOP
// ============================================================
let frameCount = 0;

function animate(now) {
    requestAnimationFrame(animate);

    const dt = Math.min((now - lastFrameTime) / 1000, 0.1);
    lastFrameTime = now;

    // Advance sim time
    if (!_paused) {
        if (_liveMode) {
            simTime = new Date();
        } else {
            simTime = new Date(simTime.getTime() + dt * timeMultiplier * 1000);
        }
    }

    // Update sun direction — every frame at high speed, every 10th at 1x
    const sunInterval = Math.abs(timeMultiplier) > 10 ? 1 : 10;
    if (frameCount % sunInterval === 0 && sunEnabled) {
        // In ECI mode, world space = inertial, so use ECI sun/moon directions
        const isEci = referenceFrame === 'eci';
        const sunDir = isEci ? computeSunDirectionECI(simTime) : computeSunDirection(simTime);
        // Move directional light to match sun
        sunLight.position.copy(sunDir).multiplyScalar(20);
        // Update earth shader (sunDirection must match world space of earthGroup)
        if (earthDayNightMat) {
            earthDayNightMat.uniforms.sunDirection.value.copy(sunDir);
        }
        // Update atmosphere shader
        if (atmosphereMesh && atmosphereMesh.material.uniforms) {
            atmosphereMesh.material.uniforms.sunDirection.value.copy(sunDir);
        }
        // Update sun visual position
        if (sunMesh) {
            sunMesh.position.copy(sunDir).multiplyScalar(150);
        }
        // Update moon position
        if (moonMesh) {
            const moonDir = isEci ? computeMoonDirectionECI(simTime) : computeMoonDirection(simTime);
            moonMesh.position.copy(moonDir).multiplyScalar(60);
        }
    }

    // Update satellite positions — adaptive frequency based on time multiplier
    // Bulk update (all sats): every 4th frame at 1x, every 2nd at 10-100x, every frame at >100x
    // Selected satellite: every frame at 1x for real-time monitoring accuracy
    frameCount++;
    const satInterval = Math.abs(timeMultiplier) > 100 ? 1 : Math.abs(timeMultiplier) > 10 ? 2 : 4;
    if (frameCount % satInterval === 0) {
        updateSatellitePositions();
    } else if (selectedIndex >= 0 && Math.abs(timeMultiplier) <= 1) {
        // Fast single-satellite update for selected sat on off-frames
        const sat = satellites[selectedIndex];
        if (sat && sat.satrec) {
            const posVel = satellite.propagate(sat.satrec, simTime);
            if (posVel.position && typeof posVel.position !== 'boolean') {
                const eci = posVel.position;
                const gmst = satellite.gstime(simTime);
                const geo = satellite.eciToGeodetic(eci, gmst);
                sat.lat = satellite.degreesLat(geo.latitude);
                sat.lon = satellite.degreesLong(geo.longitude);
                sat.alt = geo.height;
                sat.eciX = eci.x; sat.eciY = eci.y; sat.eciZ = eci.z;
                if (posVel.velocity) {
                    const v = posVel.velocity;
                    sat.speed = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                    sat.eciVx = v.x; sat.eciVy = v.y; sat.eciVz = v.z;
                }
                sat._prevX = sat.x; sat._prevY = sat.y; sat._prevZ = sat.z;
                if (referenceFrame === 'eci') {
                    const s = SAT_SCALE;
                    sat.x = eci.x * s; sat.y = eci.z * s; sat.z = -eci.y * s;
                } else {
                    geoToVec3Into(sat.lat, sat.lon, sat.alt, _geoOut);
                    sat.x = _geoOut.x; sat.y = _geoOut.y; sat.z = _geoOut.z;
                }
                const posAttr = satGeometry.getAttribute('position');
                posAttr.setXYZ(selectedIndex, sat.x, sat.y, sat.z);
                posAttr.needsUpdate = true;
            }
        }
    }

    // Update GEO satellite positions — GEO sats barely move, every 30th frame at 1x
    if (geoSatsVisible && geoSatellites.length) {
        _geoFrameCount++;
        const geoInterval = Math.abs(timeMultiplier) > 100 ? 1 : Math.abs(timeMultiplier) > 10 ? 5 : 30;
        if (_geoFrameCount % geoInterval === 0) {
            updateGeoPositions(false);
        }
    }

    // Update catalog satellite positions — adaptive per group size
    for (const key of Object.keys(catalogState)) {
        const cs = catalogState[key];
        if (!cs.visible || !cs.loaded || !_catalogMerged.ranges[key]) continue;
        cs.frameCount++;
        const n = cs.satellites.length;
        const absM = Math.abs(timeMultiplier);
        let catInterval;
        if (n > 3000) catInterval = absM > 100 ? 4 : absM > 10 ? 8 : 16;
        else if (n > 200) catInterval = absM > 100 ? 2 : absM > 10 ? 4 : 8;
        else catInterval = absM > 100 ? 1 : absM > 10 ? 2 : 4;
        if (cs.frameCount % catInterval === 0) {
            updateCatalogPositions(key, false);
        }
    }

    // Update beam footprints
    if (beamMode === 'individual') {
        updateCoverageFootprint();
    } else if (beamMode === 'all' && allBeamsOutline) {
        _allBeamsFrameCount++;
        const abInterval = Math.abs(timeMultiplier) > 100 ? 1 : Math.abs(timeMultiplier) > 10 ? 2 : 8;
        if (_allBeamsFrameCount % abInterval === 0) {
            updateAllBeams();
        }
    }

    // Update orbit path — more often at higher speeds so tails stay current
    const pathInterval = Math.max(3, Math.floor(150 / Math.abs(timeMultiplier || 1)));
    if (selectedIndex >= 0 && !orbitalVizMode && frameCount % pathInterval === 0) {
        showOrbitPath(selectedIndex);
    } else if (selectedCatalogGroup && selectedCatalogIndex >= 0 && frameCount % pathInterval === 0) {
        showCatalogOrbitPath(selectedCatalogGroup, selectedCatalogIndex);
    }

    // Update constellation trail lines
    if (frameCount % 30 === 0) updateConstellationTrails();

    // Update detail panel
    const detailInterval = Math.max(2, Math.floor(30 / Math.abs(timeMultiplier || 1)));
    if (selectedCatalogGroup && selectedCatalogIndex >= 0 && frameCount % detailInterval === 0) {
        updateCatalogDetailPanel(selectedCatalogGroup, selectedCatalogIndex);
    } else if (selectedIndex >= 0 && frameCount % detailInterval === 0) {
        updateDetailPanel();
        updateTtcPassDisplay();
    }

    // Check alarms every ~30 frames (independent of satellite selection and panel visibility)
    if (frameCount % 30 === 0) {
        checkAllTtcAlarms();
        checkManualAlarms();
    }

    // Detect formations every ~90 frames (~3s at 30fps)
    if (frameCount % 90 === 0) {
        detectFormations();
        rebuildFormationMap();
        if (_activeFormationSearch) filterSatList($searchInput.value);
    }

    // Camera animation
    updateCameraAnimation(dt);

    // Tracking: follow satellite + halo + direction arrow
    updateTracking();
    updateTrackingHalo();
    updateTrackingArrow();

    // Process mouse hover (once per frame instead of per-mousemove event)
    processMouseHover();

    // Update live viz (AoL, lat, lon) + label position
    if (orbitalVizMode === 'aol') updateAolViz();
    if (orbitalVizMode === 'eccentricity' && frameCount % 10 === 0) updateEccentricityViz();
    updateOrbitalVizLabel();

    // ECI: Earth rotates by GMST; ECEF: Earth is static
    if (referenceFrame === 'eci') {
        earthGroup.rotation.y = satellite.gstime(simTime);
    } else {
        earthGroup.rotation.y = 0;
    }

    // Stars slowly drift for subtle visual motion (skip in ECI — inertial relative to stars)
    if (starField && referenceFrame !== 'eci') {
        starField.rotation.y += 0.00002;
    }

    // Update clock + live indicator
    if (frameCount % 10 === 0) {
        const iso = simTime.toISOString();
        $clockTime.textContent = iso.slice(0, 10) + '  ' + iso.slice(11, 19);

        // Check if we're live
        document.getElementById('live-btn').classList.toggle('is-live', _liveMode && !_paused);
    }

    controls.update();

    // Ground station labels (after controls.update so camera position matches rendered frame)
    if (ttcVisible || gwVisible) {
        updateGroundStationLabels();
    }

    // GEO satellite labels
    if (geoSatsVisible) {
        updateGeoLabels();
    }

    renderer.render(scene, camera);
}

// ============================================================
// CREATE GROUND STATION 3D MARKERS
// ============================================================
function createStationMarkers3D(stations, color) {
    const markerGeo = new THREE.SphereGeometry(0.04, 8, 8);
    const markerMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 });
    const ringGeo = new THREE.RingGeometry(0.08, 0.12, 24);
    const ringMat = new THREE.MeshBasicMaterial({
        color, transparent: true, opacity: 0.5,
        side: THREE.DoubleSide, depthWrite: false,
    });

    for (const gs of stations) {
        const pos = geoToVec3(gs.lat, gs.lon, 0);
        const surfacePos = pos.clone().multiplyScalar(1.005);

        const dot = new THREE.Mesh(markerGeo, markerMat);
        dot.position.copy(surfacePos);
        gs.dot3d = dot;
        earthGroup.add(dot);

        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.copy(surfacePos);
        ring.lookAt(surfacePos.clone().multiplyScalar(2));
        gs.ring3d = ring;
        earthGroup.add(ring);
    }
}

function createGroundStationMarkers() {
    createStationMarkers3D(TTC_STATIONS, 0xff6b9d);
    createStationMarkers3D(GW_STATIONS, 0x4ecdc4);
}

function createSAAOverlay() {
    const r = EARTH_RADIUS * 1.005;

    // Catmull-Rom spline in lat/lon space for smooth boundary
    const raw = SAA_BOUNDARY.slice(0, -1); // remove closing duplicate
    const N = raw.length;
    const segsPerPt = 8;
    const smooth = [];
    for (let i = 0; i < N; i++) {
        const p0 = raw[(i - 1 + N) % N];
        const p1 = raw[i];
        const p2 = raw[(i + 1) % N];
        const p3 = raw[(i + 2) % N];
        for (let s = 0; s < segsPerPt; s++) {
            const t = s / segsPerPt;
            const t2 = t * t, t3 = t2 * t;
            const lat = 0.5 * ((2*p1[0]) + (-p0[0]+p2[0])*t + (2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2 + (-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3);
            const lon = 0.5 * ((2*p1[1]) + (-p0[1]+p2[1])*t + (2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2 + (-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3);
            smooth.push([lat, lon]);
        }
    }
    smooth.push(smooth[0]); // close

    // Project smooth boundary to 3D sphere
    function latLonTo3D(lat, lon) {
        const latRad = lat * DEG2RAD;
        const lonRad = -lon * DEG2RAD;
        return new THREE.Vector3(
            r * Math.cos(latRad) * Math.cos(lonRad),
            r * Math.sin(latRad),
            r * Math.cos(latRad) * Math.sin(lonRad)
        );
    }
    const pts3d = smooth.map(([lat, lon]) => latLonTo3D(lat, lon));

    // Compute centroid projected onto sphere
    const centroid = new THREE.Vector3();
    for (const p of pts3d) centroid.add(p);
    centroid.divideScalar(pts3d.length).normalize().multiplyScalar(r);

    // Subdivide triangles (positions only)
    function subdivide(v1, v2, v3, depth, out) {
        if (depth === 0) {
            out.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z);
            return;
        }
        const m12 = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5).normalize().multiplyScalar(r);
        const m23 = new THREE.Vector3().addVectors(v2, v3).multiplyScalar(0.5).normalize().multiplyScalar(r);
        const m31 = new THREE.Vector3().addVectors(v3, v1).multiplyScalar(0.5).normalize().multiplyScalar(r);
        subdivide(v1,  m12, m31, depth - 1, out);
        subdivide(m12, v2,  m23, depth - 1, out);
        subdivide(m31, m23, v3,  depth - 1, out);
        subdivide(m12, m23, m31, depth - 1, out);
    }

    const n = pts3d.length - 1; // closed — last == first
    const verts = [];
    for (let i = 0; i < n; i++) {
        subdivide(centroid, pts3d[i], pts3d[(i + 1) % n], 3, verts);
    }

    // Compute per-vertex distance from nearest boundary point
    // aT = 0 at boundary, 1 deep inside
    const nBoundary = pts3d.length - 1;
    const bNorms = [];
    for (let j = 0; j < nBoundary; j++) {
        const p = pts3d[j];
        const len = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);
        bNorms.push(p.x / len, p.y / len, p.z / len);
    }
    const numVerts = verts.length / 3;
    const tValues = new Float32Array(numVerts);
    let maxDist = 0;
    for (let i = 0; i < numVerts; i++) {
        const vx = verts[i * 3], vy = verts[i * 3 + 1], vz = verts[i * 3 + 2];
        const len = Math.sqrt(vx * vx + vy * vy + vz * vz);
        const nx = vx / len, ny = vy / len, nz = vz / len;
        let minAngle = Infinity;
        for (let j = 0; j < nBoundary; j++) {
            const cosA = nx * bNorms[j * 3] + ny * bNorms[j * 3 + 1] + nz * bNorms[j * 3 + 2];
            const angle = Math.acos(Math.max(-1, Math.min(1, cosA)));
            if (angle < minAngle) minAngle = angle;
        }
        tValues[i] = minAngle;
        if (minAngle > maxDist) maxDist = minAngle;
    }
    for (let i = 0; i < numVerts; i++) {
        tValues[i] /= maxDist;
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
    geo.setAttribute('aT', new THREE.Float32BufferAttribute(tValues, 1));

    // ShaderMaterial: distance-from-boundary gradient (green at edge → yellow → red inside)
    const saaMat = new THREE.ShaderMaterial({
        vertexShader: `
            attribute float aT;
            varying float vT;
            void main() {
                vT = aT;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            varying float vT;
            void main() {
                vec3 red = vec3(1.0, 0.15, 0.05);
                vec3 yellow = vec3(1.0, 0.9, 0.0);
                vec3 green = vec3(0.15, 0.8, 0.2);
                vec3 col;
                // vT: 0 = at boundary, 1 = deepest inside
                if (vT < 0.2) {
                    col = mix(green, yellow, vT / 0.2);
                } else {
                    col = mix(yellow, red, (vT - 0.2) / 0.8);
                }
                float alpha = 0.35;
                gl_FragColor = vec4(col, alpha);
            }
        `,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false,
    });
    saaMesh = new THREE.Mesh(geo, saaMat);
    saaMesh.visible = saaVisible;
    earthGroup.add(saaMesh);

    // Smooth boundary outline — green at edges
    const lineVerts = [];
    for (const p of pts3d) lineVerts.push(p.x, p.y, p.z);
    const lineGeo = new THREE.BufferGeometry();
    lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(lineVerts, 3));
    const lineMat = new THREE.LineBasicMaterial({
        color: 0x33cc44, transparent: true, opacity: 0.45
    });
    saaOutline = new THREE.Line(lineGeo, lineMat);
    saaOutline.visible = saaVisible;
    earthGroup.add(saaOutline);
}

// ============================================================
// BOOT
// ============================================================
initScene();
createStars();
createEarth();
createSunVisual();
createMoonVisual();
createGroundStationMarkers();
createSAAOverlay();
loadTLEData();
loadGeoTLEData();
animate(performance.now());

// Background-load all catalog groups after a short delay so the UI is responsive first
setTimeout(() => {
    const groups = CATALOG_GROUPS.filter(g => !g.builtin);
    let i = 0;
    function loadNext() {
        if (i >= groups.length) return;
        const g = groups[i++];
        const cs = catalogState[g.key];
        if (cs && cs.loaded) { loadNext(); return; }
        loadCatalogGroup(g.key, { showOnLoad: false }).then(() => setTimeout(loadNext, 300));
    }
    // Load 2 in parallel, staggered
    loadNext();
    setTimeout(loadNext, 150);
}, 2000);

// TT&C toggle
document.getElementById('toggle-ttc').addEventListener('click', () => {
    ttcVisible = !ttcVisible;
    document.getElementById('toggle-ttc').classList.toggle('active-ttc', ttcVisible);
    for (const gs of TTC_STATIONS) {
        const el = document.getElementById(gs.id);
        if (el) el.classList.toggle('gs-hidden', !ttcVisible);
        if (gs.dot3d) gs.dot3d.visible = ttcVisible;
        if (gs.ring3d) gs.ring3d.visible = ttcVisible;
    }
});

// Gateway toggle
document.getElementById('toggle-gw').addEventListener('click', () => {
    gwVisible = !gwVisible;
    document.getElementById('toggle-gw').classList.toggle('active-gw', gwVisible);
    for (const gs of GW_STATIONS) {
        const el = document.getElementById(gs.id);
        if (el) el.classList.toggle('gs-hidden', !gwVisible);
        if (gs.dot3d) gs.dot3d.visible = gwVisible;
        if (gs.ring3d) gs.ring3d.visible = gwVisible;
    }
});


// Stars toggle
let starsVisible = true;
document.getElementById('toggle-stars').addEventListener('click', () => {
    starsVisible = !starsVisible;
    document.getElementById('toggle-stars').classList.toggle('active-stars', starsVisible);
    if (starField) starField.visible = starsVisible;
});


// SAA zone toggle
document.getElementById('toggle-saa').addEventListener('click', () => {
    saaVisible = !saaVisible;
    document.getElementById('toggle-saa').classList.toggle('active-saa', saaVisible);
    if (saaMesh) saaMesh.visible = saaVisible;
    if (saaOutline) saaOutline.visible = saaVisible;
});

// Catalog toggle
document.getElementById('toggle-catalog').addEventListener('click', () => {
    catalogPanelOpen = !catalogPanelOpen;
    document.getElementById('toggle-catalog').classList.toggle('active-catalog', catalogPanelOpen);
    document.getElementById('catalog-panel').classList.toggle('open', catalogPanelOpen);
});
document.getElementById('catalog-close').addEventListener('click', () => {
    catalogPanelOpen = false;
    document.getElementById('toggle-catalog').classList.remove('active-catalog');
    document.getElementById('catalog-panel').classList.remove('open');
});
buildCatalogPanel();

// Select All / Deselect All
document.getElementById('catalog-select-all').addEventListener('click', () => {
    const btn = document.getElementById('catalog-select-all');
    const isAllOn = btn.textContent === 'All On';

    if (isAllOn) {
        // Turn everything on
        // OneWeb builtin
        if (satPointCloud && !satPointCloud.visible) _toggleBuiltinOneweb();
        // GEO builtin
        if (!geoSatsVisible) _toggleBuiltinGeo();
        // All catalog groups: load unloaded, show hidden — parallel fetch
        const loadPromises = [];
        for (const g of CATALOG_GROUPS) {
            if (g.builtin) continue;
            const cs = catalogState[g.key];
            if (!cs || !cs.loaded) {
                loadPromises.push(loadCatalogGroup(g.key));
            } else if (!cs.visible) {
                toggleCatalogGroup(g.key);
            }
        }
        if (loadPromises.length > 0) Promise.all(loadPromises);
        btn.textContent = 'All Off';
    } else {
        // Turn everything off
        if (satPointCloud && satPointCloud.visible) _toggleBuiltinOneweb();
        if (geoSatsVisible) _toggleBuiltinGeo();
        for (const key of Object.keys(catalogState)) {
            const cs = catalogState[key];
            if (cs && cs.loaded && cs.visible) {
                toggleCatalogGroup(key);
            }
        }
        // Clear all constellation trails
        clearAllConstellationTrails();
        btn.textContent = 'All On';
    }
});

// Sun lighting toggle
document.getElementById('toggle-sun').addEventListener('click', () => {
    sunEnabled = !sunEnabled;
    document.getElementById('toggle-sun').classList.toggle('active-sun', sunEnabled);
    if (sunEnabled) {
        sunLight.visible = true;
        ambientLight.intensity = 0.6;
        ambientLight.color.set(0x335577);
        // Immediately compute sun position
        const sunDir = referenceFrame === 'eci' ? computeSunDirectionECI(simTime) : computeSunDirection(simTime);
        sunLight.position.copy(sunDir).multiplyScalar(20);
        if (earthDayNightMat) {
            earthDayNightMat.uniforms.sunDirection.value.copy(sunDir);
        }
    } else {
        sunLight.visible = false;
        ambientLight.intensity = 1.8;
        ambientLight.color.set(0xffffff);
    }
    // Update shader sun toggle
    if (earthDayNightMat) {
        earthDayNightMat.uniforms.sunEnabled.value = sunEnabled;
    }
    if (atmosphereMesh && atmosphereMesh.material.uniforms) {
        atmosphereMesh.material.uniforms.sunEnabled.value = sunEnabled;
    }
    if (sunMesh) sunMesh.visible = sunEnabled;
});

// Reference frame toggle — hover tooltips
const $frameTooltip = document.getElementById('frame-tooltip');
document.getElementById('frame-ecef').addEventListener('mouseenter', () => {
    $frameTooltip.textContent = 'Earth-Centered Earth-Fixed';
});
document.getElementById('frame-eci').addEventListener('mouseenter', () => {
    $frameTooltip.textContent = 'Earth-Centered Inertial';
});

// Set reference frame programmatically (used by toggle + auto-switch for viz)
function setReferenceFrame(frame) {
    if (frame === referenceFrame) return;
    const isEci = frame === 'eci';

    // Rotate camera to compensate for the Earth rotation change, keeping the view stable.
    // ECEF→ECI: Earth rotates to gmst, satellites rotate to ECI — rotate camera by +gmst to follow.
    // ECI→ECEF: Earth snaps to 0, satellites snap to ECEF — rotate camera by -gmst to follow.
    const gmst = satellite.gstime(simTime);
    const angle = isEci ? gmst : -gmst;
    const c = Math.cos(angle), s = Math.sin(angle);
    const cx = camera.position.x, cz = camera.position.z;
    camera.position.x = cx * c + cz * s;
    camera.position.z = -cx * s + cz * c;

    // Set Earth rotation immediately (don't wait for animate loop)
    earthGroup.rotation.y = isEci ? gmst : 0;

    // Temporarily disable damping so OrbitControls fully adopts the new
    // camera position in one update (damping would interpolate and flicker)
    controls.enableDamping = false;
    controls.update();
    controls.enableDamping = true;

    referenceFrame = frame;
    document.getElementById('frame-toggle').classList.toggle('eci', isEci);
    document.getElementById('frame-ecef').classList.toggle('active', !isEci);
    document.getElementById('frame-eci').classList.toggle('active', isEci);

    // Clear and rebuild orbit path for selected satellite
    clearOrbitPath();
    if (selectedIndex >= 0 && !orbitalVizMode) {
        showOrbitPath(selectedIndex);
    }

    // Mark all active constellation trails as dirty for recompute in new frame
    for (const key of Object.keys(_constellationTrails)) {
        const trail = _constellationTrails[key];
        if (trail.enabled) trail.dirty = true;
    }

    // Force immediate sun/light update to prevent lighting flicker
    if (sunEnabled) {
        const sunDir = isEci ? computeSunDirectionECI(simTime) : computeSunDirection(simTime);
        sunLight.position.copy(sunDir).multiplyScalar(20);
        if (earthDayNightMat) earthDayNightMat.uniforms.sunDirection.value.copy(sunDir);
        if (atmosphereMesh && atmosphereMesh.material.uniforms) atmosphereMesh.material.uniforms.sunDirection.value.copy(sunDir);
        if (sunMesh) sunMesh.position.copy(sunDir).multiplyScalar(150);
        if (moonMesh) {
            const moonDir = isEci ? computeMoonDirectionECI(simTime) : computeMoonDirection(simTime);
            moonMesh.position.copy(moonDir).multiplyScalar(60);
        }
    }

    // Force immediate satellite position update
    updateSatellitePositions();
    // Clear _prev positions so tracking arrow doesn't jolt from cross-frame delta
    for (const sat of satellites) {
        sat._prevX = sat.x; sat._prevY = sat.y; sat._prevZ = sat.z;
    }

    // Force GEO position update on frame switch
    if (geoSatellites.length) {
        updateGeoPositions(true);
        for (const gs of geoSatellites) {
            gs._screenX = 0; gs._screenY = 0;
        }
    }

    // Invalidate cached ground station world positions so they recompute
    for (const gs of ALL_STATIONS) {
        gs._screenX = 0; gs._screenY = 0;
    }

    // Render immediately so the frame switch is visually instant
    renderer.render(scene, camera);
}

// Reference frame toggle (ECEF ↔ ECI)
document.getElementById('frame-toggle').addEventListener('click', () => {
    // Manual toggle clears any auto-switch state
    _frameBeforeViz = null;
    const newFrame = referenceFrame === 'ecef' ? 'eci' : 'ecef';
    // Close ECI-dependent vizzes when leaving ECI
    if (referenceFrame === 'eci' && (orbitalVizMode === 'inclination' || orbitalVizMode === 'raan' || orbitalVizMode === 'aol')) {
        clearOrbitalViz();
    }
    setReferenceFrame(newFrame);
});

// ============================================================
// SOURCE INFO MODAL
// ============================================================
const $sourceModal = document.getElementById('source-modal');

function openSourceModal() {
    // Set statuses based on active source
    const $ps = document.getElementById('primary-status');
    const $ss = document.getElementById('secondary-status');
    if (activeDataSource === 'primary') {
        $ps.textContent = 'Active';
        $ps.className = 'source-status status-active';
        $ss.textContent = 'Standby';
        $ss.className = 'source-status status-inactive';
    } else if (activeDataSource === 'secondary') {
        $ps.textContent = 'Failed';
        $ps.className = 'source-status status-inactive';
        $ss.textContent = 'Active';
        $ss.className = 'source-status status-fallback';
    } else {
        $ps.textContent = '--';
        $ps.className = 'source-status status-inactive';
        $ss.textContent = '--';
        $ss.className = 'source-status status-inactive';
    }

    // Select the active tab
    const activeTab = activeDataSource || 'primary';
    document.querySelectorAll('.source-tab').forEach(t => t.classList.toggle('active-tab', t.dataset.tab === activeTab));
    document.querySelectorAll('.source-tab-content').forEach(c => c.classList.toggle('active-content', c.id === 'tab-' + activeTab));

    $sourceModal.classList.add('open');
}

document.getElementById('source-click-area').addEventListener('click', openSourceModal);
document.getElementById('source-modal-close').addEventListener('click', () => $sourceModal.classList.remove('open'));
$sourceModal.addEventListener('click', (e) => { if (e.target === $sourceModal) $sourceModal.classList.remove('open'); });

document.querySelectorAll('.source-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.source-tab').forEach(t => t.classList.remove('active-tab'));
        tab.classList.add('active-tab');
        document.querySelectorAll('.source-tab-content').forEach(c => c.classList.remove('active-content'));
        document.getElementById('tab-' + tab.dataset.tab).classList.add('active-content');
    });
});

// ============================================================
// DATETIME PICKER MODAL
// ============================================================
const $dtModal = document.getElementById('datetime-modal');
const $dtInput = document.getElementById('datetime-input');
const $dtError = document.getElementById('datetime-error');

function openDatetimeModal() {
    // Pre-fill with current sim time in local datetime-local format
    const iso = simTime.toISOString().slice(0, 19);
    $dtInput.value = iso;
    $dtError.textContent = '';
    $dtModal.classList.add('open');
    $dtInput.focus();
}

document.getElementById('clock-time').addEventListener('click', openDatetimeModal);
document.getElementById('datetime-modal-close').addEventListener('click', () => $dtModal.classList.remove('open'));
$dtModal.addEventListener('click', (e) => { if (e.target === $dtModal) $dtModal.classList.remove('open'); });

document.getElementById('datetime-go').addEventListener('click', () => {
    const val = $dtInput.value;
    if (!val) { $dtError.textContent = 'Please enter a date and time'; return; }
    const d = new Date(val + 'Z'); // treat input as UTC
    if (isNaN(d.getTime())) { $dtError.textContent = 'Invalid date/time format'; return; }
    simTime = d;
    _liveMode = false;
    _ttcDirty = true;
    $dtModal.classList.remove('open');
});

document.getElementById('datetime-now').addEventListener('click', () => {
    simTime = new Date();
    _liveMode = true;
    _paused = false;
    document.getElementById('pause-btn').classList.remove('paused');
    document.getElementById('pause-btn').innerHTML = '&#x23F8;';
    _ttcDirty = true;
    timeMultiplier = 1;
    $speedSlider.value = 0;
    updateSpeedLabel(1);
    $dtModal.classList.remove('open');
});

$dtInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') document.getElementById('datetime-go').click();
    if (e.key === 'Escape') $dtModal.classList.remove('open');
});

// ============================================================
// ORBITAL VIZ CLICK LISTENERS
// ============================================================
$detailInc.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    if (orbitalVizMode === 'inclination') {
        clearOrbitalViz();
    } else {
        disableFollowMode();
        showInclinationViz(selectedIndex);
    }
});

$detailRaan.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    if (orbitalVizMode === 'raan') {
        clearOrbitalViz();
    } else {
        disableFollowMode();
        showRaanViz(selectedIndex);
    }
});

$detailAol.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    if (orbitalVizMode === 'aol') {
        clearOrbitalViz();
    } else {
        disableFollowMode();
        showAolViz(selectedIndex);
    }
});

$detailEcc.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    if (orbitalVizMode === 'eccentricity') {
        clearOrbitalViz();
    } else {
        disableFollowMode();
        showEccentricityViz(selectedIndex);
    }
});

document.getElementById('ecc-info-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    document.getElementById('ecc-info-popup').classList.add('visible');
    document.getElementById('ecc-info-overlay').classList.add('visible');
});
document.getElementById('ecc-info-close').addEventListener('click', () => {
    document.getElementById('ecc-info-popup').classList.remove('visible');
    document.getElementById('ecc-info-overlay').classList.remove('visible');
});
document.getElementById('ecc-info-overlay').addEventListener('click', () => {
    document.getElementById('ecc-info-popup').classList.remove('visible');
    document.getElementById('ecc-info-overlay').classList.remove('visible');
});

document.getElementById('tle-info-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    document.getElementById('tle-info-popup').classList.add('visible');
    document.getElementById('tle-info-overlay').classList.add('visible');
});
document.getElementById('tle-info-close').addEventListener('click', () => {
    document.getElementById('tle-info-popup').classList.remove('visible');
    document.getElementById('tle-info-overlay').classList.remove('visible');
});
document.getElementById('tle-info-overlay').addEventListener('click', () => {
    document.getElementById('tle-info-popup').classList.remove('visible');
    document.getElementById('tle-info-overlay').classList.remove('visible');
});

$detailPlane.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    const sat = satellites[selectedIndex];
    if (!sat || sat.plane <= 0) return;
    selectPlane(sat.plane);
});

$detailTleAge.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    openTleAgeGraph();
});

function openTleAgeGraph() {
    const bins = [
        { label: '0-6h',  max: 0.25,     color: 'rgba(76, 175, 80, 0.85)' },
        { label: '6-12h', max: 0.5,      color: 'rgba(76, 175, 80, 0.85)' },
        { label: '12-24h',max: 1,        color: 'rgba(76, 175, 80, 0.85)' },
        { label: '1-2d',  max: 2,        color: 'rgba(76, 175, 80, 0.75)' },
        { label: '2-3d',  max: 3,        color: 'rgba(76, 175, 80, 0.65)' },
        { label: '3-5d',  max: 5,        color: 'rgba(255, 235, 59, 0.8)' },
        { label: '5-7d',  max: 7,        color: 'rgba(255, 235, 59, 0.7)' },
        { label: '7-14d', max: 14,       color: 'rgba(255, 82, 82, 0.8)' },
        { label: '14d+',  max: Infinity, color: 'rgba(255, 82, 82, 0.65)' }
    ];
    const counts = new Array(bins.length).fill(0);
    const satAges = []; // {index, name, ageDays}
    const now = Date.now();
    for (let i = 0; i < satellites.length; i++) {
        const s = satellites[i];
        if (!s.satrec || !s.satrec.jdsatepoch) continue;
        const ageDays = (now - (s.satrec.jdsatepoch - 2440587.5) * 86400000) / 86400000;
        if (ageDays < 0) continue;
        satAges.push({ index: i, name: s.name, ageDays: ageDays, plane: s.plane });
        for (let b = 0; b < bins.length; b++) {
            if (ageDays < bins[b].max || b === bins.length - 1) { counts[b]++; break; }
        }
    }
    const total = satAges.length;
    satAges.sort((a, b) => b.ageDays - a.ageDays); // oldest first
    const agesSorted = satAges.map(s => s.ageDays).slice().sort((a, b) => a - b);
    const median = total > 0 ? agesSorted[Math.floor(total / 2)] : 0;
    const mean = total > 0 ? agesSorted.reduce((s, v) => s + v, 0) / total : 0;
    const maxCount = Math.max(...counts, 1);

    const popup = document.getElementById('tle-graph-popup');
    const overlay = document.getElementById('tle-graph-overlay');
    const canvas = document.getElementById('tle-graph-canvas');
    const oldestHeader = document.getElementById('tle-graph-oldest-header');
    const oldestList = document.getElementById('tle-graph-oldest-list');
    popup.classList.add('visible');
    overlay.classList.add('visible');

    // Defer rendering to next frame so popup has layout dimensions
    requestAnimationFrame(() => {
        const dpr = window.devicePixelRatio || 1;
        const container = document.getElementById('tle-graph-container');
        const cw = container.clientWidth;
        const ch = 260;
        canvas.style.width = cw + 'px';
        canvas.style.height = ch + 'px';
        canvas.width = cw * dpr;
        canvas.height = ch * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);

        const ml = 44, mr = 14, mt = 32, mb = 38;
        const pw = cw - ml - mr;
        const ph = ch - mt - mb;
        const barW = pw / bins.length;
        const gap = Math.max(2, barW * 0.15);

        ctx.clearRect(0, 0, cw, ch);

        // Summary text
        ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        ctx.fillStyle = '#aaa';
        ctx.textAlign = 'left';
        const medStr = median < 1 ? (median * 24).toFixed(0) + 'h' : median.toFixed(1) + 'd';
        const meanStr = mean < 1 ? (mean * 24).toFixed(0) + 'h' : mean.toFixed(1) + 'd';
        ctx.fillText(total + ' sats  \u2502  median ' + medStr + '  \u2502  mean ' + meanStr, ml, mt - 10);

        // Y-axis gridlines + labels
        const yTicks = 5;
        const niceMax = Math.ceil(maxCount / 10) * 10 || 10;
        ctx.strokeStyle = 'rgba(255,255,255,0.07)';
        ctx.lineWidth = 1;
        ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'right';
        for (let i = 0; i <= yTicks; i++) {
            const val = Math.round(niceMax * i / yTicks);
            const y = mt + ph - (val / niceMax) * ph;
            ctx.beginPath(); ctx.moveTo(ml, y); ctx.lineTo(ml + pw, y); ctx.stroke();
            ctx.fillText(val, ml - 6, y + 4);
        }

        // Bars
        for (let i = 0; i < bins.length; i++) {
            const barH = counts[i] > 0 ? Math.max((counts[i] / niceMax) * ph, 2) : 0;
            const x = ml + i * barW + gap / 2;
            const y = mt + ph - barH;
            const w = barW - gap;
            const r = Math.min(3, w / 2, barH / 2);
            ctx.fillStyle = bins[i].color;
            ctx.beginPath();
            ctx.moveTo(x, y + r);
            ctx.arcTo(x, y, x + r, y, r);
            ctx.arcTo(x + w, y, x + w, y + r, r);
            ctx.lineTo(x + w, mt + ph);
            ctx.lineTo(x, mt + ph);
            ctx.closePath();
            ctx.fill();
            // Count label above bar
            if (counts[i] > 0) {
                ctx.fillStyle = '#ccc';
                ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(counts[i], x + w / 2, y - 5);
            }
        }

        // X-axis labels
        ctx.fillStyle = '#888';
        ctx.font = '9px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        ctx.textAlign = 'center';
        for (let i = 0; i < bins.length; i++) {
            const x = ml + i * barW + barW / 2;
            ctx.fillText(bins[i].label, x, mt + ph + 14);
        }
        // X-axis title
        ctx.fillStyle = '#666';
        ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        ctx.fillText('TLE Age', ml + pw / 2, mt + ph + 30);

        // Bottom axis line
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.beginPath(); ctx.moveTo(ml, mt + ph); ctx.lineTo(ml + pw, mt + ph); ctx.stroke();
    });

    // Build oldest-TLE list (top 20 oldest)
    const oldest = satAges.slice(0, 20);
    if (oldest.length > 0) {
        oldestHeader.style.display = 'block';
        oldestList.style.display = 'block';
        oldestList.innerHTML = '';
        for (let i = 0; i < oldest.length; i++) {
            const s = oldest[i];
            const row = document.createElement('div');
            row.style.cssText = 'display:flex; align-items:center; padding:4px 6px; cursor:pointer; border-radius:5px; transition:background 0.15s; font-size:11px; font-family:var(--font-mono);';
            const ageColor = s.ageDays >= 7 ? '#ff5252' : s.ageDays >= 3 ? '#ffeb3b' : 'var(--success)';
            const ageStr = s.ageDays < 1 ? Math.floor(s.ageDays * 24) + 'h' : s.ageDays.toFixed(1) + 'd';
            const planeStr = s.plane > 0 ? 'P' + s.plane : '--';
            row.innerHTML = '<span style="color:#555;width:20px;flex-shrink:0;text-align:right;margin-right:8px;font-size:10px;">' + (i + 1) + '</span>' +
                '<span style="color:var(--text-primary);flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + s.name.replace('ONEWEB-', 'OW-') + '</span>' +
                '<span style="color:#666;font-size:10px;margin:0 8px;flex-shrink:0;">' + planeStr + '</span>' +
                '<span style="color:' + ageColor + ';font-weight:600;flex-shrink:0;min-width:44px;text-align:right;">' + ageStr + '</span>';
            row.addEventListener('mouseenter', function() { this.style.background = 'rgba(255,255,255,0.06)'; });
            row.addEventListener('mouseleave', function() { this.style.background = 'none'; });
            row.addEventListener('click', (function(idx) {
                return function() {
                    popup.classList.remove('visible');
                    overlay.classList.remove('visible');
                    selectSatellite(idx);
                };
            })(s.index));
            oldestList.appendChild(row);
        }
    } else {
        oldestHeader.style.display = 'none';
        oldestList.style.display = 'none';
    }
}

document.getElementById('tle-graph-close').addEventListener('click', () => {
    document.getElementById('tle-graph-popup').classList.remove('visible');
    document.getElementById('tle-graph-overlay').classList.remove('visible');
});
document.getElementById('tle-graph-overlay').addEventListener('click', () => {
    document.getElementById('tle-graph-popup').classList.remove('visible');
    document.getElementById('tle-graph-overlay').classList.remove('visible');
});

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        if (document.getElementById('tle-graph-popup').classList.contains('visible')) {
            document.getElementById('tle-graph-popup').classList.remove('visible');
            document.getElementById('tle-graph-overlay').classList.remove('visible');
        } else if (orbitalVizMode) {
            clearOrbitalViz();
        }
    }
});

</script>

<div class="ecc-info-overlay" id="tle-info-overlay"></div>
<div class="ecc-info-popup" id="tle-info-popup">
    <button class="ecc-info-popup-close" id="tle-info-close">&times;</button>
    <div class="ecc-info-popup-title">TLE Age</div>
    <div class="ecc-info-popup-body">
        A <b>TLE</b> (Two-Line Element set) is a standardised format for describing a satellite's orbit. It contains the orbital parameters &mdash; inclination, eccentricity, RAAN, argument of perigee, mean anomaly, and mean motion &mdash; at a specific point in time called the <b>epoch</b>.<br><br>
        <b>TLE Age</b> is the time elapsed since that epoch. The SGP4 propagator uses the TLE to predict the satellite's position forward (or backward) in time, but prediction accuracy degrades the further you get from the epoch.<br><br>
        <span style="color:var(--success)">&bull;</span>&ensp;<b>&lt;&nbsp;3 days</b> &mdash; Fresh. Positions accurate to within ~1&nbsp;km.<br>
        <span style="color:#ffeb3b">&bull;</span>&ensp;<b>3&ndash;7 days</b> &mdash; Stale. Errors grow to several km; pass time predictions may shift.<br>
        <span style="color:#ff5252">&bull;</span>&ensp;<b>&gt;&nbsp;7 days</b> &mdash; Old. Position errors can exceed 10&nbsp;km. TLE should be refreshed.
    </div>
</div>

<div class="ecc-info-overlay" id="ecc-info-overlay"></div>
<div class="ecc-info-popup" id="ecc-info-popup">
    <button class="ecc-info-popup-close" id="ecc-info-close">&times;</button>
    <div class="ecc-info-popup-title">Orbital Eccentricity</div>
    <div class="ecc-info-popup-body">
        OneWeb satellites have near-circular orbits (e&nbsp;&asymp;&nbsp;0.001). The perigee/apogee altitude difference is only ~15&nbsp;km.<br><br>
        However, Earth is an oblate spheroid &mdash; the equatorial radius is ~21&nbsp;km larger than the polar radius. This means the satellite's geodetic altitude varies more from latitude changes than from its orbital eccentricity.<br><br>
        The displayed perigee &amp; apogee altitudes use a mean Earth radius (6,371&nbsp;km) and represent the orbital shape, not the full geodetic variation you see in the live altitude readout.
    </div>
</div>

<div class="ecc-info-overlay" id="tle-graph-overlay"></div>
<div class="ecc-info-popup" id="tle-graph-popup" style="width: 520px; max-width: 94vw;">
    <button class="ecc-info-popup-close" id="tle-graph-close">&times;</button>
    <div class="ecc-info-popup-title">Fleet TLE Age Distribution</div>
    <div id="tle-graph-container" style="width: 100%; padding-top: 4px;">
        <canvas id="tle-graph-canvas"></canvas>
    </div>
    <div id="tle-graph-oldest-header" style="display:none; margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08); font-size: 11px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px;">Oldest TLEs</div>
    <div id="tle-graph-oldest-list" style="display:none; max-height: 180px; overflow-y: auto; margin-top: 6px; scrollbar-width: thin; scrollbar-color: rgba(255,255,255,0.15) transparent;"></div>
</div>
</body>
</html>
