<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
<title>OneWeb Constellation Tracker</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
    --bg-primary: #050a14;
    --bg-panel: rgba(8, 16, 32, 0.88);
    --bg-panel-hover: rgba(12, 24, 48, 0.92);
    --border: rgba(0, 163, 224, 0.15);
    --border-bright: rgba(0, 163, 224, 0.35);
    --accent: #00a3e0;
    --accent-bright: #00e5ff;
    --accent-glow: rgba(0, 229, 255, 0.15);
    --orange: #ff6b35;
    --text-primary: #e0e8f0;
    --text-secondary: #6a7b90;
    --text-dim: #3a4a5a;
    --success: #00e676;
    --font-ui: 'Inter', -apple-system, sans-serif;
    --font-mono: 'JetBrains Mono', 'SF Mono', monospace;
}

html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: var(--bg-primary);
    color: var(--text-primary);
    font-family: var(--font-ui);
}

#canvas-container {
    position: fixed;
    inset: 0;
    z-index: 0;
}

canvas { display: block; }

/* === LOADING SCREEN === */
#loading-screen {
    position: fixed; inset: 0; z-index: 1000;
    background: var(--bg-primary);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    transition: opacity 0.8s ease, visibility 0.8s ease;
}
#loading-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

.loading-logo {
    font-size: 28px; font-weight: 700; letter-spacing: 2px;
    color: var(--accent-bright);
    margin-bottom: 32px;
}
.loading-logo span { color: var(--text-secondary); font-weight: 300; }

.loading-spinner {
    width: 48px; height: 48px;
    border: 2px solid var(--border);
    border-top-color: var(--accent-bright);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
}
@keyframes spin { to { transform: rotate(360deg); } }

.loading-status {
    font-size: 13px; color: var(--text-secondary);
    font-family: var(--font-mono);
}

/* === HEADER === */
#header {
    position: fixed; top: 0; left: 0; right: 0; z-index: 10;
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 24px;
    background: linear-gradient(180deg, rgba(5,10,20,0.95) 0%, rgba(5,10,20,0) 100%);
    pointer-events: none;
}
#header > * { pointer-events: auto; }

.logo-area {
    display: flex; align-items: center; gap: 14px;
}
.logo-mark {
    width: 36px; height: 36px;
    border-radius: 8px;
    background: linear-gradient(135deg, var(--accent) 0%, var(--accent-bright) 100%);
    display: flex; align-items: center; justify-content: center;
    font-weight: 700; font-size: 14px; color: #050a14;
}
.logo-text h1 {
    font-size: 16px; font-weight: 600; letter-spacing: 0.5px;
    line-height: 1.2;
}
.logo-text p {
    font-size: 11px; color: var(--text-secondary);
    font-family: var(--font-mono); letter-spacing: 1px;
    text-transform: uppercase;
}

.header-stats {
    display: flex; gap: 28px; align-items: center;
}
.stat-item {
    text-align: center;
}
.stat-value {
    font-family: var(--font-mono); font-size: 20px; font-weight: 600;
    color: var(--accent-bright); line-height: 1.2;
}
.stat-label {
    font-size: 10px; color: var(--text-secondary);
    text-transform: uppercase; letter-spacing: 1.5px;
    margin-top: 2px;
}
.source-stat-item {
    cursor: pointer; padding: 6px 12px; margin: -6px -12px;
    border-radius: 8px; transition: background 0.2s;
}
.source-stat-item:hover { background: rgba(255, 255, 255, 0.06); }
.data-source-value { font-size: 13px; }
.data-source-value.source-primary { color: var(--success); }
.data-source-value.source-secondary { color: var(--orange); }

/* Source Info Modal */
.source-modal-overlay {
    display: none; position: fixed; inset: 0; z-index: 100;
    background: rgba(0, 0, 0, 0.6); justify-content: center; align-items: center;
}
.source-modal-overlay.open { display: flex; }
.source-modal {
    background: var(--bg-panel); border: 1px solid var(--border-bright);
    border-radius: 14px; padding: 0; width: 380px; max-width: 90vw;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
}
.source-modal-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 14px 18px 0; margin-bottom: 0;
}
.source-modal-header h3 {
    margin: 0; font-size: 14px; color: var(--text-primary);
    font-family: var(--font-mono); letter-spacing: 0.5px;
}
.source-modal-close {
    background: none; border: none; color: var(--text-secondary);
    font-size: 18px; cursor: pointer; padding: 0 4px; line-height: 1;
}
.source-modal-close:hover { color: var(--text-primary); }
.source-tabs {
    display: flex; gap: 0; padding: 12px 18px 0; border-bottom: 1px solid var(--border);
}
.source-tab {
    flex: 1; padding: 8px 0; text-align: center; cursor: pointer;
    font-family: var(--font-mono); font-size: 12px; color: var(--text-secondary);
    border: none; background: none; border-bottom: 2px solid transparent;
    transition: all 0.2s;
}
.source-tab:hover { color: var(--text-primary); }
.source-tab.active-tab {
    color: var(--accent-bright); border-bottom-color: var(--accent-bright);
}
.source-tab-content {
    display: none; padding: 16px 18px 18px;
    font-family: var(--font-mono); font-size: 12px; color: var(--text-primary);
    line-height: 1.7;
}
.source-tab-content.active-content { display: block; }
.source-tab-content .source-field { color: var(--text-secondary); }
.source-tab-content .source-status {
    display: inline-block; padding: 2px 8px; border-radius: 4px;
    font-size: 11px; font-weight: 600;
}
.source-status.status-active { background: rgba(0, 230, 118, 0.15); color: var(--success); }
.source-status.status-fallback { background: rgba(255, 107, 53, 0.15); color: var(--orange); }
.source-status.status-inactive { background: rgba(255, 255, 255, 0.08); color: var(--text-dim); }

/* DateTime Picker Modal */
.datetime-modal-overlay {
    display: none; position: fixed; inset: 0; z-index: 100;
    background: rgba(0, 0, 0, 0.6); justify-content: center; align-items: center;
}
.datetime-modal-overlay.open { display: flex; }
.datetime-modal {
    background: var(--bg-panel); border: 1px solid var(--border-bright);
    border-radius: 14px; padding: 0; width: 340px; max-width: 90vw;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
}
.datetime-modal-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 14px 18px 0;
}
.datetime-modal-header h3 {
    margin: 0; font-size: 14px; color: var(--text-primary);
    font-family: var(--font-mono); letter-spacing: 0.5px;
}
.datetime-modal-close {
    background: none; border: none; color: var(--text-secondary);
    font-size: 18px; cursor: pointer; padding: 0 4px; line-height: 1;
}
.datetime-modal-close:hover { color: var(--text-primary); }
.datetime-modal-body {
    padding: 16px 18px 18px;
}
.datetime-input {
    width: 100%; padding: 10px 12px; box-sizing: border-box;
    background: rgba(255, 255, 255, 0.06); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text-primary);
    font-family: var(--font-mono); font-size: 14px;
    outline: none; transition: border-color 0.2s;
}
.datetime-input:focus { border-color: var(--accent-bright); }
.datetime-buttons {
    display: flex; gap: 8px; margin-top: 14px;
}
.datetime-btn {
    flex: 1; padding: 9px 0; border-radius: 8px; border: none;
    font-family: var(--font-mono); font-size: 12px; cursor: pointer;
    transition: all 0.2s;
}
.datetime-btn-go {
    background: var(--accent); color: #fff;
}
.datetime-btn-go:hover { background: var(--accent-bright); }
.datetime-btn-now {
    background: rgba(255, 255, 255, 0.08); color: var(--text-primary);
    border: 1px solid var(--border);
}
.datetime-btn-now:hover { background: rgba(255, 255, 255, 0.12); }
.datetime-error {
    color: var(--orange); font-size: 11px; font-family: var(--font-mono);
    margin-top: 8px; min-height: 16px;
}
.clock-time { cursor: pointer; }
.clock-time:hover { color: #fff; }

/* === CLOCK === */
#clock {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    z-index: 10;
    display: flex; align-items: center; gap: 16px;
    padding: 10px 22px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
}
.clock-time {
    font-family: var(--font-mono); font-size: 16px; font-weight: 500;
    color: var(--accent-bright);
}
.clock-label {
    font-size: 10px; color: var(--text-secondary);
    text-transform: uppercase; letter-spacing: 1.5px;
    text-align: center; margin-top: 4px;
}
.clock-divider {
    width: 1px; height: 24px;
    background: var(--border);
}
.speed-controls {
    display: flex; align-items: center; gap: 8px;
}
.speed-slider {
    -webkit-appearance: none; appearance: none;
    width: 100px; height: 4px;
    background: var(--border); border-radius: 2px;
    outline: none; cursor: pointer;
}
.speed-slider::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 14px; height: 14px;
    background: var(--accent-bright); border-radius: 50%;
    cursor: pointer; border: none;
}
.speed-slider::-moz-range-thumb {
    width: 14px; height: 14px;
    background: var(--accent-bright); border-radius: 50%;
    cursor: pointer; border: none;
}
.speed-label {
    font-family: var(--font-mono); font-size: 11px;
    color: var(--accent-bright); min-width: 42px;
    text-align: right;
}

/* === SIDE PANEL === */
#side-panel {
    position: fixed; top: 80px; right: 16px; bottom: 80px;
    width: 320px; z-index: 10;
    display: flex; flex-direction: column;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 14px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
    transition: transform 0.3s ease, opacity 0.3s ease;
}
#side-panel.collapsed {
    transform: translateX(340px); opacity: 0; pointer-events: none;
}

.panel-header {
    padding: 16px 18px;
    border-bottom: 1px solid var(--border);
    display: flex; flex-direction: column; gap: 10px;
}
.panel-title {
    font-size: 12px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 1.5px;
    color: var(--text-secondary);
}
.search-box {
    position: relative;
}
.search-box input {
    width: 100%; padding: 8px 12px 8px 34px;
    background: rgba(0,0,0,0.3); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text-primary);
    font-family: var(--font-ui); font-size: 13px;
    outline: none; transition: border-color 0.2s;
}
.search-box input::placeholder { color: var(--text-dim); }
.search-box input:focus { border-color: var(--accent); }
.search-icon {
    position: absolute; left: 10px; top: 50%; transform: translateY(-50%);
    color: var(--text-dim); font-size: 14px;
}

.sat-list {
    flex: 1; overflow-y: auto; padding: 6px;
}
.sat-list::-webkit-scrollbar { width: 4px; }
.sat-list::-webkit-scrollbar-track { background: transparent; }
.sat-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.sat-item {
    padding: 10px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.15s;
    display: flex; align-items: center; gap: 10px;
    border: 1px solid transparent;
}
.sat-item:hover { background: rgba(0, 163, 224, 0.06); }
.sat-item.selected {
    background: var(--accent-glow);
    border-color: var(--border-bright);
}
.sat-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--accent-bright);
    box-shadow: 0 0 6px var(--accent-bright);
    flex-shrink: 0;
}
.sat-item.selected .sat-dot { background: var(--orange); box-shadow: 0 0 6px var(--orange); }
.sat-info { flex: 1; min-width: 0; }
.sat-name {
    font-size: 12px; font-weight: 500;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.sat-meta {
    font-family: var(--font-mono); font-size: 10px;
    color: var(--text-secondary); margin-top: 2px;
}

.plane-item {
    padding: 10px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.15s;
    display: none;
    align-items: center; gap: 10px;
    border: 1px solid transparent;
}
.plane-item:hover { background: rgba(255, 107, 53, 0.08); }
.plane-item.selected {
    background: rgba(255, 107, 53, 0.12);
    border-color: var(--orange);
}
.plane-item .plane-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--orange);
    box-shadow: 0 0 6px var(--orange);
    flex-shrink: 0;
}
.plane-item .sat-name { color: var(--orange); font-weight: 600; }
.plane-item .sat-meta { color: var(--text-secondary); }

/* === DETAIL PANEL === */
#detail-panel {
    position: fixed; top: 80px; left: 16px;
    width: 300px; z-index: 10;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 14px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    overflow: hidden;
    transition: transform 0.3s ease, opacity 0.3s ease;
}
#detail-panel.hidden {
    transform: translateX(-320px); opacity: 0; pointer-events: none;
}

.detail-header {
    padding: 16px 18px;
    border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: space-between;
}
.detail-name {
    font-size: 15px; font-weight: 600;
}
.detail-close {
    width: 28px; height: 28px; display: flex;
    align-items: center; justify-content: center;
    background: transparent; border: 1px solid var(--border);
    border-radius: 6px; color: var(--text-secondary);
    cursor: pointer; font-size: 16px;
    transition: all 0.2s;
}
.detail-close:hover { border-color: var(--accent); color: var(--text-primary); }

.detail-body { padding: 16px 18px; }
.detail-section {
    margin-bottom: 16px;
}
.detail-section-title {
    font-size: 10px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 1.5px;
    color: var(--text-secondary);
    margin-bottom: 8px;
}
.detail-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
}
.detail-field {}
.detail-field-label {
    font-size: 10px; color: var(--text-dim);
    text-transform: uppercase; letter-spacing: 0.5px;
}
.detail-field-value {
    font-family: var(--font-mono); font-size: 13px;
    color: var(--text-primary); margin-top: 1px;
}
.detail-track-row { padding: 4px 0 8px; }
.detail-track-btn {
    width: 100%; padding: 8px;
    background: transparent;
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-secondary);
    font-family: var(--font-mono); font-size: 11px;
    cursor: pointer; transition: all 0.2s;
}
.detail-track-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.detail-track-btn.active {
    border-color: var(--orange); color: var(--orange);
    background: rgba(255, 107, 53, 0.08);
}

.detail-field-value.accent { color: var(--accent-bright); }
.detail-field-value.clickable { cursor: pointer; transition: color 0.2s, text-shadow 0.2s; }
.detail-field-value.clickable:hover { color: var(--accent-bright); text-shadow: 0 0 8px var(--accent-glow); }
.detail-field-value.clickable.viz-active { color: var(--orange); text-shadow: 0 0 8px rgba(255, 107, 53, 0.3); }

.orbital-viz-label {
    position: fixed; z-index: 15;
    padding: 8px 14px;
    background: rgba(5, 10, 20, 0.85);
    backdrop-filter: blur(8px);
    border: 1px solid var(--border-bright);
    border-radius: 8px;
    font-family: var(--font-mono); font-size: 12px;
    color: var(--text-primary);
    pointer-events: none;
    transform: translate(-50%, -100%);
    white-space: nowrap;
    opacity: 0; transition: opacity 0.3s;
}
.orbital-viz-label.visible { opacity: 1; }
.orbital-viz-label .viz-title { font-weight: 600; color: var(--success); }
.orbital-viz-label .viz-subtitle { color: var(--text-secondary); margin-top: 2px; }

.viz-tag {
    position: fixed; z-index: 14;
    padding: 3px 8px;
    background: rgba(5, 10, 20, 0.75);
    backdrop-filter: blur(4px);
    border-radius: 4px;
    font-family: var(--font-mono); font-size: 10px;
    letter-spacing: 0.5px;
    pointer-events: none;
    transform: translate(-50%, -50%);
    white-space: nowrap;
    opacity: 0; transition: opacity 0.3s;
}
.viz-tag.visible { opacity: 1; }

/* === TOGGLE BUTTON === */
#panel-toggle {
    position: fixed; right: 16px; top: 50%;
    transform: translateY(-50%);
    z-index: 11;
    width: 32px; height: 80px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; color: var(--text-secondary);
    font-size: 14px;
    transition: all 0.3s;
}
#panel-toggle:hover { border-color: var(--accent); color: var(--text-primary); }
#panel-toggle.panel-open { right: 348px; }

/* === TOOLTIP === */
#tooltip {
    position: fixed; left: 0; top: 0; z-index: 20;
    padding: 8px 12px;
    background: rgba(5, 10, 20, 0.95);
    border: 1px solid var(--border-bright);
    border-radius: 8px;
    font-size: 12px; font-family: var(--font-mono);
    pointer-events: none;
    opacity: 0; transition: opacity 0.15s;
    white-space: nowrap;
    will-change: transform;
}
#tooltip.visible { opacity: 1; }

.live-indicator {
    display: flex; align-items: center; gap: 8px; flex-direction: row;
}
.live-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--text-dim);
    box-shadow: none;
    transition: background 0.3s, box-shadow 0.3s;
}
.live-indicator.is-live .live-dot {
    background: var(--success);
    box-shadow: 0 0 8px var(--success);
    animation: pulse 2s ease-in-out infinite;
}
.live-indicator:not(.is-live) .live-dot {
    animation: none;
}
.live-indicator:not(.is-live) span {
    color: var(--text-dim);
}
@keyframes pulse {
    0%, 100% { opacity: 1; box-shadow: 0 0 8px var(--success); }
    50% { opacity: 0.5; box-shadow: 0 0 4px var(--success); }
}

/* === GROUND STATIONS === */
.ground-station {
    position: fixed; left: 0; top: 0; z-index: 9;
    pointer-events: none;
    display: flex; align-items: center; gap: 6px;
    transition: opacity 0.3s;
    will-change: transform;
}
.ground-station.gs-hidden { opacity: 0; pointer-events: none; }
.ground-station.behind-globe { opacity: 0; }

/* TT&C markers — diamond */
.gs-marker-ttc {
    width: 10px; height: 10px;
    border: 2px solid #ff6b9d;
    border-radius: 2px;
    transform: rotate(45deg);
    box-shadow: 0 0 8px rgba(255, 107, 157, 0.5);
    flex-shrink: 0;
}
.gs-label-ttc {
    font-family: var(--font-mono);
    font-size: 11px; font-weight: 500;
    color: #ff6b9d;
    text-shadow: 0 1px 6px rgba(0,0,0,0.9), 0 0 12px rgba(0,0,0,0.7);
    white-space: nowrap;
}

/* Gateway markers — circle */
.gs-marker-gw {
    width: 8px; height: 8px;
    border: 2px solid #4ecdc4;
    border-radius: 50%;
    box-shadow: 0 0 6px rgba(78, 205, 196, 0.5);
    flex-shrink: 0;
}
.gs-label-gw {
    font-family: var(--font-mono);
    font-size: 10px; font-weight: 500;
    color: #4ecdc4;
    text-shadow: 0 1px 6px rgba(0,0,0,0.9), 0 0 12px rgba(0,0,0,0.7);
    white-space: nowrap;
}

.gs-sublabel {
    font-size: 9px; font-weight: 400;
    color: var(--text-secondary);
    display: block;
}

/* === STATION TOGGLES PANEL === */
#gs-controls {
    position: fixed; bottom: 70px; left: 16px; z-index: 10;
    display: flex; flex-direction: column; gap: 6px;
}
.gs-toggle-btn {
    display: flex; align-items: center; gap: 8px;
    padding: 7px 14px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    cursor: pointer; transition: all 0.2s;
    font-family: var(--font-ui); font-size: 11px;
    color: var(--text-secondary);
    user-select: none;
    white-space: nowrap;
}
.gs-toggle-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.gs-toggle-btn.active-ttc { border-color: #ff6b9d; color: #ff6b9d; }
.gs-toggle-btn.active-gw { border-color: #4ecdc4; color: #4ecdc4; }
.gs-toggle-icon {
    width: 14px; height: 14px;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
}
.gs-toggle-icon .diamond {
    width: 7px; height: 7px;
    border: 1.5px solid var(--text-dim);
    border-radius: 1px;
    transform: rotate(45deg);
    transition: border-color 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-ttc .diamond {
    border-color: #ff6b9d;
    box-shadow: 0 0 4px #ff6b9d;
}
.gs-toggle-icon .circle {
    width: 6px; height: 6px;
    border: 1.5px solid var(--text-dim);
    border-radius: 50%;
    transition: border-color 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-gw .circle {
    border-color: #4ecdc4;
    box-shadow: 0 0 4px #4ecdc4;
}
.gs-toggle-btn.active-sun { border-color: #ffb74d; color: #ffb74d; }
.gs-toggle-icon .sun-icon {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--text-dim);
    transition: background 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-sun .sun-icon {
    background: #ffb74d;
    box-shadow: 0 0 6px #ffb74d;
}
.gs-toggle-btn.active-saa { border-color: #ff5252; color: #ff5252; }
.gs-toggle-icon .saa-icon {
    width: 7px; height: 7px;
    border: 1.5px solid var(--text-dim);
    border-radius: 2px;
    transition: border-color 0.2s, box-shadow 0.2s;
}
.gs-toggle-btn.active-saa .saa-icon {
    border-color: #ff5252;
    box-shadow: 0 0 4px #ff5252;
    background: rgba(255, 82, 82, 0.3);
}
#frame-toggle {
    display: flex; align-items: center;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    padding: 2px;
    cursor: pointer; user-select: none;
    position: relative;
}
#frame-toggle .frame-opt {
    flex: 1;
    padding: 5px 10px;
    font-family: var(--font-mono); font-size: 10px; font-weight: 500;
    color: var(--text-dim);
    border-radius: 8px;
    transition: color 0.25s;
    position: relative; z-index: 1;
    letter-spacing: 0.5px;
}
#frame-ecef { text-align: left; }
#frame-eci { text-align: left; }
#frame-toggle .frame-opt.active {
    color: #e0e8f0;
}
#frame-toggle .frame-opt:hover {
    color: var(--text-secondary);
}
#frame-toggle .frame-opt.active:hover {
    color: #e0e8f0;
}
#frame-toggle .frame-slider {
    position: absolute;
    top: 2px; left: 2px;
    width: calc(50% - 2px);
    height: calc(100% - 4px);
    background: rgba(179, 136, 255, 0.2);
    border: 1px solid #b388ff;
    border-radius: 8px;
    transition: transform 0.25s ease;
    box-shadow: 0 0 8px rgba(179, 136, 255, 0.15);
}
#frame-toggle.eci .frame-slider {
    transform: translateX(100%);
}
#frame-toggle.eci {
    border-color: rgba(179, 136, 255, 0.35);
}
#frame-toggle:hover {
    border-color: rgba(179, 136, 255, 0.4);
}
.frame-tooltip {
    position: absolute;
    left: calc(100% + 10px);
    top: 50%; transform: translateY(-50%);
    background: var(--bg-panel);
    border: 1px solid var(--border-bright);
    border-radius: 6px;
    padding: 4px 8px;
    font-family: var(--font-ui); font-size: 10px;
    color: var(--text-secondary);
    white-space: nowrap;
    pointer-events: none;
    opacity: 0; transition: opacity 0.15s;
    backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    z-index: 20;
}
#frame-toggle:hover .frame-tooltip { opacity: 1; }

/* === BOTTOM ACTIONS (Reset View + Live) === */
#bottom-actions {
    position: fixed; bottom: 84px; left: 50%; transform: translateX(-50%);
    z-index: 10;
    display: flex; gap: 8px; align-items: center;
}
.bottom-action-btn {
    padding: 8px 20px;
    background: var(--bg-panel);
    border-radius: 10px;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    cursor: pointer;
    font-family: var(--font-mono); font-size: 12px;
    transition: all 0.3s;
    user-select: none;
}
#reset-view {
    border: 1px solid var(--orange);
    color: var(--orange);
}
#reset-view:hover { background: rgba(255, 107, 53, 0.15); }
#live-btn {
    border: 1px solid var(--border);
    color: var(--text-secondary);
}
#live-btn:hover { border-color: var(--border-bright); }
#live-btn.is-live { border-color: var(--success); color: var(--success); }

/* === ROTATE BUTTONS === */
.rotate-btn {
    border: 1px solid var(--accent);
    color: var(--accent-bright);
}
.rotate-btn:hover {
    background: var(--accent-glow);
    border-color: var(--accent-bright);
}

/* === RESPONSIVE === */
@media (max-width: 768px) {
    #side-panel { width: 260px; right: 8px; top: 70px; bottom: 70px; }
    #detail-panel { width: 260px; left: 8px; }
    .header-stats { gap: 16px; }
    .stat-value { font-size: 16px; }
    #panel-toggle.panel-open { right: 278px; }
}

/* === MOBILE (iPhone) === */
@media (max-width: 480px) {
    /* Header: compact single row */
    #header { padding: 10px 12px; }
    .logo-mark { width: 28px; height: 28px; font-size: 11px; }
    .logo-area { gap: 8px; }
    .logo-text h1 { font-size: 12px; }
    .logo-text p { display: none; }
    .header-stats { gap: 6px; }
    .stat-value { font-size: 12px; }
    .stat-label { font-size: 7px; letter-spacing: 0.8px; }
    .data-source-value { font-size: 10px; }
    .source-stat-item { padding: 4px 6px; margin: -4px -6px; }

    /* Side panel: bottom sheet */
    #side-panel {
        width: 100vw; right: 0; left: 0;
        top: auto; bottom: 0; max-height: 50vh;
        border-radius: 14px 14px 0 0;
        padding-bottom: env(safe-area-inset-bottom);
    }
    #side-panel.collapsed { transform: translateY(100%); }
    .panel-header { padding: 12px 14px; }
    .search-box input {
        padding: 12px 12px 12px 34px;
        font-size: 16px; /* prevents iOS zoom on focus */
    }

    /* Panel toggle: bottom right, 44px touch target */
    #panel-toggle {
        right: 12px; top: auto;
        transform: none;
        width: 44px; height: 44px;
        border-radius: 50%;
        font-size: 12px;
        bottom: calc(56px + env(safe-area-inset-bottom));
    }
    #panel-toggle.panel-open {
        right: 12px;
        bottom: calc(50vh + 8px + env(safe-area-inset-bottom));
    }

    /* Detail panel: bottom sheet, collapses side panel */
    #detail-panel {
        width: 100vw; left: 0; right: 0;
        top: auto; bottom: 0; max-height: 55vh;
        border-radius: 14px 14px 0 0;
        overflow-y: auto;
        z-index: 12;
        padding-bottom: env(safe-area-inset-bottom);
    }
    #detail-panel.hidden { transform: translateY(100%); }
    .detail-body { padding: 12px 14px; }
    .detail-header { padding: 12px 14px; }
    .detail-close { width: 44px; height: 44px; font-size: 20px; }

    /* Clock: bottom center, above safe area */
    #clock {
        bottom: 0;
        padding: 8px 14px;
        padding-bottom: calc(8px + env(safe-area-inset-bottom));
        gap: 10px;
        border-radius: 12px 12px 0 0;
        width: 100vw; left: 0; transform: none;
    }
    .clock-time { font-size: 13px; }
    .clock-label { font-size: 8px; margin-top: 2px; }
    .speed-slider {
        width: 70px; height: 20px;
        /* bigger touch area, same visual track */
    }
    .speed-slider::-webkit-slider-thumb {
        width: 24px; height: 24px;
    }
    .speed-slider::-moz-range-thumb {
        width: 24px; height: 24px;
    }
    .speed-label { font-size: 10px; min-width: 32px; }

    /* Bottom actions: row above clock */
    #bottom-actions {
        bottom: calc(48px + env(safe-area-inset-bottom));
        gap: 6px;
    }
    .bottom-action-btn {
        padding: 10px 14px; font-size: 10px;
        border-radius: 8px;
        min-height: 38px;
    }

    /* Toggle controls: top left below header (not bottom) */
    #gs-controls {
        bottom: auto; top: 56px; left: 8px;
        gap: 4px;
    }
    .gs-toggle-btn {
        padding: 8px 10px; font-size: 10px; gap: 6px;
        border-radius: 8px;
        min-height: 34px;
    }
    .gs-toggle-icon { width: 12px; height: 12px; }
    #frame-toggle .frame-opt {
        padding: 6px 10px; font-size: 9px;
    }

    /* Ground station labels: smaller, avoid clutter */
    .gs-label-ttc, .gs-label-gw {
        font-size: 8px; padding: 2px 5px;
        max-width: 90px; overflow: hidden; text-overflow: ellipsis;
    }
    .gs-sublabel { font-size: 7px; }

    /* Tooltip */
    #tooltip { font-size: 11px; padding: 6px 10px; }

    /* Modals: full width with max-height */
    .source-modal, .datetime-modal {
        width: calc(100vw - 24px);
        max-height: 80vh; overflow-y: auto;
    }

    /* Rotate buttons: hide when not needed to save space */
    .rotate-btn { padding: 10px 12px; min-height: 38px; }
}

/* === PORTRAIT WARNING (mobile only) === */
#portrait-warning {
    display: none;
    position: fixed; inset: 0; z-index: 2000;
    background: var(--bg-primary);
    flex-direction: column;
    align-items: center; justify-content: center;
    gap: 20px;
    text-align: center;
    padding: 32px;
}
.portrait-icon {
    width: 56px; height: 56px;
    border: 2px solid var(--accent);
    border-radius: 10px;
    position: relative;
    animation: rotate-hint 2s ease-in-out infinite;
}
.portrait-icon::after {
    content: '';
    position: absolute; bottom: 6px; left: 50%; transform: translateX(-50%);
    width: 12px; height: 2px;
    background: var(--accent); border-radius: 1px;
}
@keyframes rotate-hint {
    0%, 30% { transform: rotate(0deg); }
    50%, 80% { transform: rotate(90deg); }
    100% { transform: rotate(0deg); }
}
.portrait-title {
    font-size: 18px; font-weight: 600;
    color: var(--text-primary);
}
.portrait-subtitle {
    font-size: 13px; color: var(--text-secondary);
    font-family: var(--font-mono);
    line-height: 1.6;
}

@media (max-width: 480px) and (orientation: portrait) {
    #portrait-warning { display: flex; }
}

/* === MOBILE LANDSCAPE === */
@media (max-height: 440px) and (orientation: landscape) {
    /* Header: compact single row, hide subtitle */
    #header { padding: 6px 12px; }
    .logo-mark { width: 24px; height: 24px; font-size: 10px; }
    .logo-area { gap: 6px; }
    .logo-text h1 { font-size: 11px; }
    .logo-text p { display: none; }
    .header-stats { gap: 6px; }
    .stat-value { font-size: 11px; }
    .stat-label { font-size: 7px; letter-spacing: 0.6px; }
    .data-source-value { font-size: 9px; }
    .source-stat-item { padding: 3px 5px; margin: -3px -5px; }

    /* Side panel: right-side vertical panel */
    #side-panel {
        width: 220px; right: 0; left: auto;
        top: 38px; bottom: 0; max-height: none;
        border-radius: 0;
        padding-bottom: 0;
    }
    #side-panel.collapsed { transform: translateX(100%); }
    .panel-header { padding: 8px 10px; }
    .search-box input { padding: 8px 8px 8px 30px; font-size: 13px; }
    #sat-list { max-height: calc(100vh - 140px); }

    /* Panel toggle: right edge, small circular */
    #panel-toggle {
        right: 4px; top: 50%;
        transform: translateY(-50%);
        width: 32px; height: 32px;
        border-radius: 50%;
        font-size: 10px;
        bottom: auto;
    }
    #panel-toggle.panel-open {
        right: 224px;
        bottom: auto;
    }

    /* Detail panel: left-side vertical panel */
    #detail-panel {
        width: 220px; left: 0; right: auto;
        top: 38px; bottom: 0; max-height: none;
        border-radius: 0;
        overflow-y: auto;
        z-index: 12;
        padding-bottom: 0;
    }
    #detail-panel.hidden { transform: translateX(-100%); }
    .detail-body { padding: 8px 10px; }
    .detail-header { padding: 8px 10px; }
    .detail-close { width: 36px; height: 36px; font-size: 16px; }
    .detail-title { font-size: 13px; }
    .detail-subtitle { font-size: 10px; }
    .detail-grid { gap: 4px; }
    .detail-grid dt { font-size: 9px; }
    .detail-grid dd { font-size: 11px; }
    #detail-track { padding: 6px 10px; font-size: 10px; min-height: 30px; }

    /* Clock: slim bar at bottom */
    #clock {
        bottom: 0;
        padding: 4px 12px;
        gap: 8px;
        border-radius: 8px 8px 0 0;
        left: 50%; transform: translateX(-50%);
        width: auto;
    }
    .clock-time { font-size: 11px; }
    .clock-label { font-size: 7px; margin-top: 1px; }
    .speed-slider { width: 60px; height: 16px; }
    .speed-label { font-size: 9px; min-width: 28px; }

    /* Bottom actions: compact, above clock */
    #bottom-actions {
        bottom: 32px;
        gap: 4px;
    }
    .bottom-action-btn {
        padding: 6px 10px; font-size: 9px;
        border-radius: 6px;
        min-height: 28px;
    }

    /* Toggle controls: top-left, very compact */
    #gs-controls {
        bottom: auto; top: 42px; left: 4px;
        gap: 2px;
    }
    .gs-toggle-btn {
        padding: 4px 6px; font-size: 9px; gap: 4px;
        border-radius: 6px;
        min-height: 26px;
    }
    .gs-toggle-icon { width: 10px; height: 10px; }
    #frame-toggle .frame-opt {
        padding: 4px 6px; font-size: 8px;
    }

    /* Rotate buttons: compact */
    .rotate-btn { padding: 6px 8px; min-height: 28px; font-size: 10px; }

    /* Ground station labels */
    .gs-label-ttc, .gs-label-gw {
        font-size: 7px; padding: 1px 4px;
    }

    /* Tooltip */
    #tooltip { font-size: 10px; padding: 4px 8px; }

    /* Modals */
    .source-modal, .datetime-modal {
        max-height: 90vh; overflow-y: auto;
    }
}
</style>
</head>
<body>

<!-- Portrait Warning -->
<div id="portrait-warning">
    <div class="portrait-icon"></div>
    <div class="portrait-title">Rotate Your Device</div>
    <div class="portrait-subtitle">This tracker is best experienced<br>in landscape orientation</div>
</div>

<!-- Loading Screen -->
<div id="loading-screen">
    <div class="loading-logo">OW<span>TRACK</span></div>
    <div class="loading-spinner"></div>
    <div class="loading-status" id="loading-status">Initializing...</div>
</div>

<!-- 3D Canvas -->
<div id="canvas-container"></div>

<!-- Header -->
<div id="header">
    <div class="logo-area">
        <div class="logo-mark">OW</div>
        <div class="logo-text">
            <h1>OneWeb Constellation Tracker</h1>
            <p>Real-time LEO Satellite Monitoring</p>
        </div>
    </div>
    <div class="header-stats">
        <div class="stat-item">
            <div class="stat-value" id="stat-total">--</div>
            <div class="stat-label">Satellites</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="stat-planes">--</div>
            <div class="stat-label">Planes</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="stat-altitude">--</div>
            <div class="stat-label">Avg Alt (km)</div>
        </div>
        <div class="stat-item source-stat-item" id="source-click-area">
            <div class="stat-value data-source-value" id="stat-source">--</div>
            <div class="stat-label">Source</div>
        </div>
    </div>
</div>

<!-- Clock / Time Controls -->

<div id="clock">
    <div>
        <div class="clock-time" id="clock-time">---------- --:--:--</div>
        <div class="clock-label">UTC</div>
    </div>
    <div class="clock-divider"></div>
    <div class="speed-controls">
        <input type="range" class="speed-slider" id="speed-slider" min="0" max="100" value="0">
        <span class="speed-label" id="speed-label">1x</span>
    </div>
</div>

<!-- Side Panel: Satellite List -->
<div id="side-panel">
    <div class="panel-header">
        <div class="panel-title">Constellation</div>
        <div class="search-box">
            <span class="search-icon">&gt;</span>
            <input type="text" id="search-input" placeholder="Search satellites...">
        </div>
    </div>
    <div class="sat-list" id="sat-list"></div>
</div>

<!-- Panel Toggle -->
<div id="panel-toggle" class="panel-open" title="Toggle satellite list">&#x25C0;</div>

<!-- Detail Panel (selected satellite) -->
<div id="detail-panel" class="hidden">
    <div class="detail-header">
        <div class="detail-name" id="detail-name">--</div>
        <button class="detail-close" id="detail-close">&times;</button>
    </div>
    <div class="detail-body">
        <div class="detail-section">
            <div class="detail-section-title">Position</div>
            <div class="detail-grid">
                <div class="detail-field">
                    <div class="detail-field-label">Latitude</div>
                    <div class="detail-field-value clickable" id="detail-lat">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Longitude</div>
                    <div class="detail-field-value clickable" id="detail-lon">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Altitude</div>
                    <div class="detail-field-value accent" id="detail-alt">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Velocity</div>
                    <div class="detail-field-value" id="detail-vel">--</div>
                </div>
            </div>
        </div>
        <div class="detail-section">
            <div class="detail-section-title">Orbital Elements</div>
            <div class="detail-grid">
                <div class="detail-field">
                    <div class="detail-field-label">Inclination</div>
                    <div class="detail-field-value clickable" id="detail-inc">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Eccentricity</div>
                    <div class="detail-field-value clickable" id="detail-ecc">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Period</div>
                    <div class="detail-field-value" id="detail-period">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">NORAD ID</div>
                    <div class="detail-field-value" id="detail-norad">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">RAAN</div>
                    <div class="detail-field-value clickable" id="detail-raan">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Arg of Latitude</div>
                    <div class="detail-field-value clickable" id="detail-aol">--</div>
                </div>
                <div class="detail-field">
                    <div class="detail-field-label">Plane</div>
                    <div class="detail-field-value" id="detail-plane">--</div>
                </div>
            </div>
        </div>
        <div class="detail-track-row">
            <button class="detail-track-btn" id="detail-track">Follow Satellite</button>
        </div>
    </div>
</div>

<!-- TT&C Station Labels -->
<div class="ground-station gs-ttc" id="gs-svalbard">
    <div class="gs-marker-ttc"></div>
    <div class="gs-label-ttc">Svalbard<span class="gs-sublabel">TT&C Station</span></div>
</div>
<div class="ground-station gs-ttc" id="gs-inuvik">
    <div class="gs-marker-ttc"></div>
    <div class="gs-label-ttc">Inuvik<span class="gs-sublabel">TT&C Station</span></div>
</div>

<!-- Gateway / SNP Station Labels -->
<div class="ground-station gs-gw" id="gs-talkeetna">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Talkeetna<span class="gs-sublabel">SNP &middot; Alaska</span></div>
</div>
<div class="ground-station gs-gw" id="gs-connecticut">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Connecticut<span class="gs-sublabel">SNP</span></div>
</div>
<div class="ground-station gs-gw" id="gs-florida">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Florida<span class="gs-sublabel">SNP</span></div>
</div>
<div class="ground-station gs-gw" id="gs-hawaii">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Hawaii<span class="gs-sublabel">SNP</span></div>
</div>
<div class="ground-station gs-gw" id="gs-yellowknife">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Yellowknife<span class="gs-sublabel">SNP &middot; Canada</span></div>
</div>
<div class="ground-station gs-gw" id="gs-toluca">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Toluca<span class="gs-sublabel">SNP &middot; Mexico</span></div>
</div>
<div class="ground-station gs-gw" id="gs-santiago">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Santiago<span class="gs-sublabel">SNP &middot; Chile</span></div>
</div>
<div class="ground-station gs-gw" id="gs-arica">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Arica<span class="gs-sublabel">SNP &middot; Chile</span></div>
</div>
<div class="ground-station gs-gw" id="gs-cali">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Cali<span class="gs-sublabel">SNP &middot; Colombia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-marica">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Maric&aacute;<span class="gs-sublabel">SNP &middot; Brazil</span></div>
</div>
<div class="ground-station gs-gw" id="gs-tahiti">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Tahiti<span class="gs-sublabel">SNP &middot; French Polynesia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-rambouillet">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Rambouillet<span class="gs-sublabel">SNP &middot; France</span></div>
</div>
<div class="ground-station gs-gw" id="gs-sintra">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Sintra<span class="gs-sublabel">SNP &middot; Portugal</span></div>
</div>
<div class="ground-station gs-gw" id="gs-bulgaria">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Sofia<span class="gs-sublabel">SNP &middot; Bulgaria</span></div>
</div>
<div class="ground-station gs-gw" id="gs-pitea">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Pite&aring;<span class="gs-sublabel">SNP &middot; Sweden</span></div>
</div>
<div class="ground-station gs-gw" id="gs-tabuk">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Tabuk<span class="gs-sublabel">SNP &middot; Saudi Arabia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-luanda">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Luanda<span class="gs-sublabel">SNP &middot; Angola</span></div>
</div>
<div class="ground-station gs-gw" id="gs-darwin">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Darwin<span class="gs-sublabel">SNP &middot; Australia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-toowoomba">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Toowoomba<span class="gs-sublabel">SNP &middot; Australia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-wangara">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Perth<span class="gs-sublabel">SNP &middot; Australia</span></div>
</div>
<div class="ground-station gs-gw" id="gs-sirindhorn">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Sirindhorn<span class="gs-sublabel">SNP &middot; Thailand</span></div>
</div>
<div class="ground-station gs-gw" id="gs-gujarat">
    <div class="gs-marker-gw"></div>
    <div class="gs-label-gw">Gujarat<span class="gs-sublabel">SNP &middot; India</span></div>
</div>

<!-- Toggle Controls -->
<div id="gs-controls">
    <div class="gs-toggle-btn active-ttc" id="toggle-ttc">
        <div class="gs-toggle-icon"><div class="diamond"></div></div>
        TT&C Stations
    </div>
    <div class="gs-toggle-btn active-gw" id="toggle-gw">
        <div class="gs-toggle-icon"><div class="circle"></div></div>
        Gateway Stations
    </div>
    <div class="gs-toggle-btn active-sun" id="toggle-sun">
        <div class="gs-toggle-icon"><div class="sun-icon"></div></div>
        Sun Lighting
    </div>
    <div class="gs-toggle-btn" id="toggle-saa">
        <div class="gs-toggle-icon"><div class="saa-icon"></div></div>
        SAA Zone
    </div>
    <div id="frame-toggle">
        <div class="frame-slider"></div>
        <div class="frame-opt active" id="frame-ecef">ECEF</div>
        <div class="frame-opt" id="frame-eci">ECI</div>
        <div class="frame-tooltip" id="frame-tooltip">Earth-Centered Earth-Fixed</div>
    </div>
</div>

<!-- Bottom Actions -->
<div id="bottom-actions">
    <button class="bottom-action-btn rotate-btn" id="rotate-plus">+90&deg;</button>
    <div id="reset-view" class="bottom-action-btn">Reset View</div>
    <button class="bottom-action-btn rotate-btn" id="rotate-minus">&minus;90&deg;</button>
    <div id="live-btn" class="bottom-action-btn live-indicator is-live" title="Click to sync to real time">
        <div class="live-dot"></div>
        <span>LIVE</span>
    </div>
</div>

<!-- Source Info Modal -->
<div class="source-modal-overlay" id="source-modal">
    <div class="source-modal">
        <div class="source-modal-header">
            <h3>Data Sources</h3>
            <button class="source-modal-close" id="source-modal-close">&times;</button>
        </div>
        <div class="source-tabs">
            <button class="source-tab active-tab" data-tab="primary">Primary</button>
            <button class="source-tab" data-tab="secondary">Secondary</button>
        </div>
        <div class="source-tab-content active-content" id="tab-primary">
            <div><span class="source-field">Name:</span> CelesTrak (Direct)</div>
            <div><span class="source-field">URL:</span> celestrak.org</div>
            <div><span class="source-field">Type:</span> Direct HTTPS fetch</div>
            <div><span class="source-field">Data:</span> GP TLE format (OneWeb group)</div>
            <div><span class="source-field">Status:</span> <span class="source-status" id="primary-status">--</span></div>
        </div>
        <div class="source-tab-content" id="tab-secondary">
            <div><span class="source-field">Name:</span> CORS Proxy Fallback</div>
            <div><span class="source-field">URL:</span> corsproxy.io / codetabs.com</div>
            <div><span class="source-field">Type:</span> Proxied HTTPS fetch</div>
            <div><span class="source-field">Data:</span> GP TLE format (via CelesTrak)</div>
            <div><span class="source-field">Status:</span> <span class="source-status" id="secondary-status">--</span></div>
        </div>
    </div>
</div>

<!-- DateTime Picker Modal -->
<div class="datetime-modal-overlay" id="datetime-modal">
    <div class="datetime-modal">
        <div class="datetime-modal-header">
            <h3>Jump to Date &amp; Time</h3>
            <button class="datetime-modal-close" id="datetime-modal-close">&times;</button>
        </div>
        <div class="datetime-modal-body">
            <input type="datetime-local" class="datetime-input" id="datetime-input" step="1">
            <div class="datetime-error" id="datetime-error"></div>
            <div class="datetime-buttons">
                <button class="datetime-btn datetime-btn-now" id="datetime-now">Now</button>
                <button class="datetime-btn datetime-btn-go" id="datetime-go">Go</button>
            </div>
        </div>
    </div>
</div>

<!-- Tooltip -->
<div id="tooltip"></div>

<script src="https://cdn.jsdelivr.net/npm/satellite.js@5.0.0/dist/satellite.min.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ============================================================
// CONSTANTS
// ============================================================
const EARTH_RADIUS = 5;
const EARTH_RADIUS_KM = 6371;
const SAT_SCALE = EARTH_RADIUS / EARTH_RADIUS_KM;
const TLE_URL = 'https://celestrak.org/NORAD/elements/gp.php?GROUP=oneweb&FORMAT=tle';
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// ============================================================
// STATE
// ============================================================
let scene, camera, renderer, controls;
let ambientLight, sunLight, sunMesh, moonMesh;
let sunEnabled = true;
let activeDataSource = null; // 'primary' or 'secondary'
let earthGroup, earthMesh, atmosphereMesh, starField;
let earthDayNightMat = null;
let satPointCloud, satGeometry, satColorAttr;
let planeGlowCloud = null, planeGlowGeo = null, planeGlowIndices = [];
let satellites = [];
let selectedIndex = -1;
let orbitLine = null;
let groundTrack = null;
let pastOrbitLine = null;
let pastGroundTrack = null;
let trackingHalo = null;
let trackingArrow = null;
let haloTexture = null; // shared texture for tracking halo
let raycaster, mouse, hoveredIndex = -1;
let simTime = new Date();
let timeMultiplier = 1;
let lastFrameTime = performance.now();
let panelOpen = true;

// Tracking / focus state
let trackingIndex = -1;
let followMode = false;
let cameraAnim = null; // { startDir, endDir, dist, startTarget, endTarget, progress, duration }
// Default camera facing the UK (lat ~54, lon ~-2)
const ukLat = 54 * Math.PI / 180;
const ukLon = -(-2) * Math.PI / 180; // negate for Three.js convention
const defaultDist = 14;
let defaultCameraPos = new THREE.Vector3(
    defaultDist * Math.cos(ukLat) * Math.cos(ukLon),
    defaultDist * Math.sin(ukLat),
    defaultDist * Math.cos(ukLat) * Math.sin(ukLon)
);
let defaultCameraTarget = new THREE.Vector3(0, 0, 0);
let ttcVisible = true;
let gwVisible = true;
let saaVisible = false;
let saaMesh = null;
let saaOutline = null;

// SAA contour at LEO altitude (~500-1200km), approx 10^2 protons/cm²/s flux boundary
// Center ~27°S 49°W, extends ~5°S-45°S lat, ~80°W-5°E lon (tilted NW-SE oval)
const SAA_BOUNDARY = [
    [-3, -42],    // north
    [-6, -30],    // NE
    [-10, -18],   // NE
    [-15, -8],    // east
    [-21, -2],    // east
    [-28, 0],     // east (widest east, near center lat)
    [-34, -5],    // SE
    [-38, -15],   // SE
    [-42, -28],   // south
    [-44, -40],   // south
    [-45, -52],   // SW
    [-43, -62],   // west
    [-38, -70],   // west
    [-32, -76],   // NW
    [-25, -78],   // NW (widest west)
    [-19, -74],   // NW
    [-14, -66],   // NW
    [-9, -56],    // north
    [-3, -42],    // close
];
let selectedPlane = -1;
let _mouseDirty = false;
let _lastMouseX = 0, _lastMouseY = 0;
let _tooltipContent = '';
let _tooltipX = 0, _tooltipY = 0;
let orbitalVizMode = null; // null | 'inclination' | 'raan' | 'aol' | 'eccentricity' | 'lat' | 'lon'
let orbitalVizObjects = [];
let orbitalVizLabel = null;
let vizLabelAnchor = null;
let vizTags = []; // { el, anchor: Vector3 }
let vizGmst = 0;
let referenceFrame = 'ecef'; // 'ecef' | 'eci'
let _frameBeforeViz = null; // saved frame when auto-switching to ECI for viz

// Reusable objects for per-frame functions (avoid GC pressure)
const _earthSphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), EARTH_RADIUS);
const _camToStation = new THREE.Vector3();
const _projectedVec = new THREE.Vector3();
const _intersectPt = new THREE.Vector3();
const _satPos = new THREE.Vector3();
const _toCamera = new THREE.Vector3();
const _velDir = new THREE.Vector3();
const _arrowOrigin = new THREE.Vector3();
const _trackDir = new THREE.Vector3();
const _trackTarget = new THREE.Vector3();
const _upVec = new THREE.Vector3(0, 1, 0);
const _quatTemp = new THREE.Quaternion();

// TT&C stations (Svalbard + Inuvik)
const TTC_STATIONS = [
    { id: 'gs-svalbard', lat: 78.2306, lon: 15.3894 },
    { id: 'gs-inuvik', lat: 68.3607, lon: -133.723 },
];

// Gateway / SNP stations (verified OneWeb Satellite Network Portals)
const GW_STATIONS = [
    // Americas (SSC-installed)
    { id: 'gs-talkeetna',    lat: 62.3209, lon: -150.1066 },  // Alaska
    { id: 'gs-connecticut',  lat: 41.3400, lon: -72.9200 },   // Connecticut, USA
    { id: 'gs-florida',      lat: 28.4885, lon: -80.5780 },   // Florida, USA
    { id: 'gs-hawaii',       lat: 21.5728, lon: -158.1134 },  // Hawaii, USA
    { id: 'gs-yellowknife',  lat: 62.4540, lon: -114.3718 },  // Yellowknife, Canada
    { id: 'gs-toluca',       lat: 19.2826, lon: -99.6557 },   // Toluca, Mexico
    { id: 'gs-santiago',     lat: -33.4489, lon: -70.6693 },  // Santiago, Chile
    { id: 'gs-arica',        lat: -18.4783, lon: -70.3126 },  // Arica, Chile
    { id: 'gs-cali',         lat: 3.4516,  lon: -76.5320 },   // Cali, Colombia
    { id: 'gs-marica',       lat: -22.9195, lon: -42.8190 },  // Maricá, Brazil
    { id: 'gs-tahiti',       lat: -17.5516, lon: -149.5585 }, // Tahiti, French Polynesia
    // Europe
    { id: 'gs-rambouillet',  lat: 48.6443, lon: 1.8352 },     // Rambouillet, France (Eutelsat teleport)
    { id: 'gs-sintra',       lat: 38.7998, lon: -9.3817 },    // Sintra, Portugal
    { id: 'gs-bulgaria',     lat: 42.6977, lon: 23.3219 },    // Bulgaria (Vivacom)
    { id: 'gs-pitea',        lat: 65.3173, lon: 21.4798 },    // Piteå, Sweden (Arctic Space)
    // Middle East & Africa
    { id: 'gs-tabuk',        lat: 28.3838, lon: 36.5550 },    // Tabuk, Saudi Arabia (stc)
    { id: 'gs-luanda',       lat: -8.8390, lon: 13.2894 },    // Luanda, Angola
    // Asia-Pacific
    { id: 'gs-darwin',       lat: -12.4634, lon: 130.8456 },  // Darwin, Australia (Telstra)
    { id: 'gs-toowoomba',    lat: -27.5598, lon: 151.9507 },  // Toowoomba, Australia (Telstra)
    { id: 'gs-wangara',      lat: -31.7881, lon: 115.8283 },  // Perth/Wangara, Australia (Telstra)
    { id: 'gs-sirindhorn',   lat: 15.1400, lon: 105.4300 },   // Sirindhorn, Thailand
    { id: 'gs-gujarat',      lat: 22.3072, lon: 70.8022 },    // Gujarat, India
];

// Combined for label projection
const ALL_STATIONS = [...TTC_STATIONS, ...GW_STATIONS];

// ============================================================
// DOM REFS
// ============================================================
const $loading = document.getElementById('loading-screen');
const $loadingStatus = document.getElementById('loading-status');
const $statTotal = document.getElementById('stat-total');
const $statPlanes = document.getElementById('stat-planes');
const $statAlt = document.getElementById('stat-altitude');
const $clockTime = document.getElementById('clock-time');
const $satList = document.getElementById('sat-list');
const $searchInput = document.getElementById('search-input');
const $detailPanel = document.getElementById('detail-panel');
const $tooltip = document.getElementById('tooltip');
const $detailName = document.getElementById('detail-name');
const $detailLat = document.getElementById('detail-lat');
const $detailLon = document.getElementById('detail-lon');
const $detailAlt = document.getElementById('detail-alt');
const $detailVel = document.getElementById('detail-vel');
const $detailInc = document.getElementById('detail-inc');
const $detailEcc = document.getElementById('detail-ecc');
const $detailPeriod = document.getElementById('detail-period');
const $detailNorad = document.getElementById('detail-norad');
const $detailPlane = document.getElementById('detail-plane');
const $detailRaan = document.getElementById('detail-raan');
const $detailAol = document.getElementById('detail-aol');

// ============================================================
// INIT THREE.JS
// ============================================================
function initScene() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.copy(defaultCameraPos);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 2;
    controls.maxDistance = 200;
    controls.enablePan = true;
    controls.rotateSpeed = 0.5;

    raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 0.15;
    mouse = new THREE.Vector2(-999, -999);

    // Ambient light
    ambientLight = new THREE.AmbientLight(0x335577, 0.6);
    scene.add(ambientLight);

    // Directional light (sun)
    sunLight = new THREE.DirectionalLight(0xffeedd, 2.0);
    sunLight.position.set(10, 5, 8);
    scene.add(sunLight);

    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('click', onMouseClick);
}

// ============================================================
// SUN DIRECTION (simplified solar ephemeris)
// ============================================================
function computeSunDirection(date) {
    // Julian date from JS Date
    const JD = date.getTime() / 86400000 + 2440587.5;
    const n = JD - 2451545.0; // days since J2000.0

    // Mean longitude & mean anomaly (degrees)
    const L = (280.460 + 0.9856474 * n) % 360;
    const g = ((357.528 + 0.9856003 * n) % 360) * DEG2RAD;

    // Ecliptic longitude (degrees)
    const lambda = (L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2 * g)) * DEG2RAD;

    // Obliquity of ecliptic
    const epsilon = 23.439 * DEG2RAD;

    // Right ascension & declination
    const ra = Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
    const dec = Math.asin(Math.sin(epsilon) * Math.sin(lambda));

    // Greenwich sidereal time (using satellite.js)
    const gmst = satellite.gstime(date);

    // Sun geographic longitude (hour angle from Greenwich)
    const sunLon = ra - gmst;

    // Convert to Three.js world coords (same convention as sat positions: lon negated, Y up)
    const x = Math.cos(dec) * Math.cos(-sunLon);
    const y = Math.sin(dec);
    const z = Math.cos(dec) * Math.sin(-sunLon);

    return _sunDirOut.set(x, y, z).normalize();
}
const _sunDirOut = new THREE.Vector3();

function computeSunDirectionECI(date) {
    const JD = date.getTime() / 86400000 + 2440587.5;
    const n = JD - 2451545.0;
    const L = (280.460 + 0.9856474 * n) % 360;
    const g = ((357.528 + 0.9856003 * n) % 360) * DEG2RAD;
    const lambda = (L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2 * g)) * DEG2RAD;
    const epsilon = 23.439 * DEG2RAD;
    const ra = Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
    const dec = Math.asin(Math.sin(epsilon) * Math.sin(lambda));
    return _sunDirEciOut.set(
        Math.cos(dec) * Math.cos(ra),
        Math.sin(dec),
        -Math.cos(dec) * Math.sin(ra)
    ).normalize();
}
const _sunDirEciOut = new THREE.Vector3();

// ============================================================
// EARTH DAY/NIGHT SHADER MATERIAL
// ============================================================
function buildEarthShaderMaterial(dayTex, nightTex) {
    return new THREE.ShaderMaterial({
        uniforms: {
            dayMap: { value: dayTex },
            nightMap: { value: nightTex },
            sunDirection: { value: new THREE.Vector3(1, 0, 0) },
            sunEnabled: { value: true },
        },
        vertexShader: `
            varying vec2 vUv;
            varying vec3 vWorldNormal;
            void main() {
                vUv = uv;
                vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D dayMap;
            uniform sampler2D nightMap;
            uniform vec3 sunDirection;
            uniform bool sunEnabled;
            varying vec2 vUv;
            varying vec3 vWorldNormal;

            void main() {
                vec4 dayColor = texture2D(dayMap, vUv);
                vec4 nightColor = texture2D(nightMap, vUv);

                if (!sunEnabled) {
                    // Flat-lit day texture, no night lights
                    gl_FragColor = vec4(dayColor.rgb * 0.85, 1.0);
                    return;
                }

                // NdotL > 0 = facing sun = daytime
                float NdotL = dot(vWorldNormal, sunDirection);
                // dayBlend: 0 on night side, 1 on day side
                float dayBlend = smoothstep(-0.02, 0.08, NdotL);

                // Day: well-lit blue-marble (high ambient so always brighter than night)
                vec3 day = dayColor.rgb * (0.8 + 0.6 * max(NdotL, 0.0));

                // Night: very dim base + city lights only
                vec3 night = dayColor.rgb * 0.06 + nightColor.rgb * 1.5;

                gl_FragColor = vec4(mix(night, day, dayBlend), 1.0);
            }
        `,
    });
}

// ============================================================
// CREATE EARTH
// ============================================================
function createEarth() {
    earthGroup = new THREE.Group();
    scene.add(earthGroup);

    const textureLoader = new THREE.TextureLoader();

    // Earth sphere
    const earthGeo = new THREE.SphereGeometry(EARTH_RADIUS, 96, 64);

    // Create procedural fallback texture
    const fallbackMat = new THREE.MeshPhongMaterial({
        color: 0x0a1628,
        emissive: 0x040810,
        shininess: 15,
    });

    earthMesh = new THREE.Mesh(earthGeo, fallbackMat);
    earthGroup.add(earthMesh);

    // Load day + night textures in parallel
    const dayUrl = 'https://unpkg.com/three-globe@2.31.1/example/img/earth-blue-marble.jpg';
    const nightUrl = 'https://unpkg.com/three-globe@2.31.1/example/img/earth-night.jpg';
    let dayTex = null, nightTex = null;

    function tryBuildMaterial() {
        if (!dayTex || !nightTex) return;
        earthDayNightMat = buildEarthShaderMaterial(dayTex, nightTex);
        // Set initial sun direction
        const sunDir = computeSunDirection(simTime);
        earthDayNightMat.uniforms.sunDirection.value.copy(sunDir);
        earthDayNightMat.uniforms.sunEnabled.value = sunEnabled;
        earthMesh.material = earthDayNightMat;
    }

    textureLoader.load(dayUrl, (tex) => { dayTex = tex; tryBuildMaterial(); },
        undefined, () => console.warn('Failed to load day earth texture'));
    textureLoader.load(nightUrl, (tex) => { nightTex = tex; tryBuildMaterial(); },
        undefined, () => console.warn('Failed to load night earth texture'));

    // Atmosphere glow (back-side shader)
    const atmosGeo = new THREE.SphereGeometry(EARTH_RADIUS * 1.025, 64, 64);
    const atmosMat = new THREE.ShaderMaterial({
        uniforms: {
            sunDirection: { value: new THREE.Vector3(1, 0, 0) },
            sunEnabled: { value: true },
        },
        vertexShader: `
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 sunDirection;
            uniform bool sunEnabled;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            void main() {
                float intensity = pow(0.72 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.5);
                vec3 color = mix(vec3(0.1, 0.4, 0.8), vec3(0.2, 0.7, 1.0), intensity);
                float alpha = intensity * 0.65;
                if (sunEnabled) {
                    float atmosBoost = smoothstep(-0.3, 0.5, dot(normalize(vWorldPos), sunDirection));
                    alpha *= mix(0.25, 1.0, atmosBoost);
                }
                gl_FragColor = vec4(color, alpha);
            }
        `,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide,
        transparent: true,
        depthWrite: false,
    });
    atmosphereMesh = new THREE.Mesh(atmosGeo, atmosMat);
    earthGroup.add(atmosphereMesh);

    // Subtle lat/lon grid
    const gridMat = new THREE.LineBasicMaterial({ color: 0x1a3050, transparent: true, opacity: 0.2 });
    for (let lat = -60; lat <= 60; lat += 30) {
        const pts = [];
        const r = EARTH_RADIUS * 1.001;
        const phi = (90 - lat) * DEG2RAD;
        for (let lon = 0; lon <= 360; lon += 2) {
            const theta = lon * DEG2RAD;
            pts.push(new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            ));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        earthGroup.add(new THREE.Line(geo, gridMat));
    }
    for (let lon = 0; lon < 360; lon += 30) {
        const pts = [];
        const r = EARTH_RADIUS * 1.001;
        const theta = lon * DEG2RAD;
        for (let lat = -90; lat <= 90; lat += 2) {
            const phi = (90 - lat) * DEG2RAD;
            pts.push(new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            ));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        earthGroup.add(new THREE.Line(geo, gridMat));
    }
}

// ============================================================
// CREATE STARS
// ============================================================
function createStars() {
    const starsGeo = new THREE.BufferGeometry();
    const count = 6000;
    const positions = new Float32Array(count * 3);
    const sizes = new Float32Array(count);
    for (let i = 0; i < count; i++) {
        const r = 80 + Math.random() * 120;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);
        sizes[i] = 0.5 + Math.random() * 1.5;
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    starsGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const starsMat = new THREE.PointsMaterial({
        color: 0xccddff,
        size: 0.12,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true,
    });
    starField = new THREE.Points(starsGeo, starsMat);
    scene.add(starField);
}

// ============================================================
// SUN VISUAL (glowing sphere visible when zoomed out)
// ============================================================
function createSunVisual() {
    const sunGroup = new THREE.Group();

    // Core sphere
    const coreGeo = new THREE.SphereGeometry(2.5, 32, 32);
    const coreMat = new THREE.MeshBasicMaterial({ color: 0xffee88 });
    const core = new THREE.Mesh(coreGeo, coreMat);
    sunGroup.add(core);

    // Glow sprite
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(64, 64, 8, 64, 64, 64);
    gradient.addColorStop(0, 'rgba(255, 238, 136, 0.9)');
    gradient.addColorStop(0.3, 'rgba(255, 200, 80, 0.4)');
    gradient.addColorStop(0.7, 'rgba(255, 160, 40, 0.1)');
    gradient.addColorStop(1, 'rgba(255, 120, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);
    const glowTex = new THREE.CanvasTexture(canvas);
    const glowMat = new THREE.SpriteMaterial({
        map: glowTex,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
    });
    const glow = new THREE.Sprite(glowMat);
    glow.scale.set(18, 18, 1);
    sunGroup.add(glow);

    // Position far along sun direction
    const sunDir = computeSunDirection(simTime);
    sunGroup.position.copy(sunDir.multiplyScalar(150));

    scene.add(sunGroup);
    sunMesh = sunGroup;
}

// ============================================================
// MOON DIRECTION (simplified lunar ephemeris)
// ============================================================
function computeMoonDirection(date) {
    const JD = date.getTime() / 86400000 + 2440587.5;
    const T = (JD - 2451545.0) / 36525.0; // Julian centuries since J2000

    // Mean elements (degrees)
    const Lm = (218.316 + 481267.8813 * T) % 360;  // mean longitude
    const Mm = (134.963 + 477198.8676 * T) % 360;   // mean anomaly
    const F  = (93.272 + 483202.0175 * T) % 360;    // mean distance from ascending node

    const LmR = Lm * DEG2RAD, MmR = Mm * DEG2RAD, FR = F * DEG2RAD;

    // Ecliptic longitude and latitude (degrees, simplified)
    const lon = Lm + 6.289 * Math.sin(MmR);
    const lat = 5.128 * Math.sin(FR);
    const lonR = lon * DEG2RAD, latR = lat * DEG2RAD;

    // Obliquity
    const epsilon = 23.439 * DEG2RAD;

    // Ecliptic to equatorial
    const sinLon = Math.sin(lonR), cosLon = Math.cos(lonR);
    const sinLat = Math.sin(latR), cosLat = Math.cos(latR);
    const ra = Math.atan2(
        sinLon * Math.cos(epsilon) * cosLat - sinLat * Math.sin(epsilon),
        cosLon * cosLat
    );
    const dec = Math.asin(sinLat * Math.cos(epsilon) + cosLat * Math.sin(epsilon) * sinLon);

    const gmst = satellite.gstime(date);
    const moonLon = ra - gmst;

    const x = Math.cos(dec) * Math.cos(-moonLon);
    const y = Math.sin(dec);
    const z = Math.cos(dec) * Math.sin(-moonLon);

    return _moonDirOut.set(x, y, z).normalize();
}
const _moonDirOut = new THREE.Vector3();

function computeMoonDirectionECI(date) {
    const JD = date.getTime() / 86400000 + 2440587.5;
    const T = (JD - 2451545.0) / 36525.0;
    const Lm = (218.316 + 481267.8813 * T) % 360;
    const Mm = (134.963 + 477198.8676 * T) % 360;
    const F  = (93.272 + 483202.0175 * T) % 360;
    const LmR = Lm * DEG2RAD, MmR = Mm * DEG2RAD, FR = F * DEG2RAD;
    const lon = Lm + 6.289 * Math.sin(MmR);
    const lat = 5.128 * Math.sin(FR);
    const lonR = lon * DEG2RAD, latR = lat * DEG2RAD;
    const epsilon = 23.439 * DEG2RAD;
    const sinLon = Math.sin(lonR), cosLon = Math.cos(lonR);
    const sinLat = Math.sin(latR), cosLat = Math.cos(latR);
    const ra = Math.atan2(
        sinLon * Math.cos(epsilon) * cosLat - sinLat * Math.sin(epsilon),
        cosLon * cosLat
    );
    const dec = Math.asin(sinLat * Math.cos(epsilon) + cosLat * Math.sin(epsilon) * sinLon);
    return _moonDirEciOut.set(
        Math.cos(dec) * Math.cos(ra),
        Math.sin(dec),
        -Math.cos(dec) * Math.sin(ra)
    ).normalize();
}
const _moonDirEciOut = new THREE.Vector3();

// ============================================================
// MOON VISUAL
// ============================================================
function createMoonVisual() {
    const moonGroup = new THREE.Group();

    // Moon sphere (grey)
    const moonGeo = new THREE.SphereGeometry(1.35, 32, 32);
    const moonMat = new THREE.MeshBasicMaterial({ color: 0xcccccc });
    const moonCore = new THREE.Mesh(moonGeo, moonMat);
    moonGroup.add(moonCore);

    // Subtle glow
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(32, 32, 6, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(200, 210, 220, 0.5)');
    gradient.addColorStop(0.5, 'rgba(180, 190, 200, 0.15)');
    gradient.addColorStop(1, 'rgba(160, 170, 180, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    const glowTex = new THREE.CanvasTexture(canvas);
    const glowMat = new THREE.SpriteMaterial({
        map: glowTex,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
    });
    const glow = new THREE.Sprite(glowMat);
    glow.scale.set(6, 6, 1);
    moonGroup.add(glow);

    const moonDir = computeMoonDirection(simTime);
    moonGroup.position.copy(moonDir.multiplyScalar(60));

    scene.add(moonGroup);
    moonMesh = moonGroup;
}

// ============================================================
// SATELLITE DATA
// ============================================================
async function loadTLEData() {
    $loadingStatus.textContent = 'Fetching TLE data from CelesTrak...';

    let tleText;
    const $source = document.getElementById('stat-source');
    try {
        const resp = await fetch(TLE_URL);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        tleText = await resp.text();
        $source.textContent = 'Primary';
        $source.className = 'stat-value data-source-value source-primary';
        activeDataSource = 'primary';
    } catch (e) {
        console.warn('Direct fetch failed, trying CORS proxies...', e);
        $loadingStatus.textContent = 'Trying alternate data source...';
        const proxies = [
            'https://corsproxy.io/?' + encodeURIComponent(TLE_URL),
            'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(TLE_URL),
        ];
        let proxyOk = false;
        for (const proxyUrl of proxies) {
            try {
                const resp = await fetch(proxyUrl);
                if (!resp.ok) throw new Error(`Proxy HTTP ${resp.status}`);
                tleText = await resp.text();
                proxyOk = true;
                $source.textContent = 'Secondary';
                $source.className = 'stat-value data-source-value source-secondary';
                activeDataSource = 'secondary';
                break;
            } catch (pe) {
                console.warn('Proxy failed:', proxyUrl, pe);
            }
        }
        if (!proxyOk) {
            console.error('All fetches failed');
            $loadingStatus.textContent = 'Failed to load satellite data. Please try again later.';
            return;
        }
    }

    $loadingStatus.textContent = 'Parsing orbital elements...';
    parseTLEData(tleText);
}

function parseTLEData(text) {
    const lines = text.trim().split('\n').map(l => l.trim()).filter(l => l.length > 0);
    satellites = [];

    for (let i = 0; i < lines.length - 2; i++) {
        // TLE format: name line, then line1 (starts with 1), then line2 (starts with 2)
        if (lines[i + 1]?.[0] === '1' && lines[i + 2]?.[0] === '2') {
            const name = lines[i];
            const line1 = lines[i + 1];
            const line2 = lines[i + 2];
            try {
                const satrec = satellite.twoline2satrec(line1, line2);
                if (satrec.error === 0) {
                    const inclination = satrec.inclo * RAD2DEG;
                    const eccentricity = satrec.ecco;
                    const meanMotion = satrec.no * (1440 / (2 * Math.PI)); // rev/day
                    const period = 1440 / meanMotion; // minutes

                    satellites.push({
                        name,
                        satrec,
                        noradId: satrec.satnum,
                        inclination,
                        eccentricity,
                        period,
                        // Updated each frame:
                        lat: 0, lon: 0, alt: 0,
                        vx: 0, vy: 0, vz: 0,
                        x: 0, y: 0, z: 0,
                    });
                }
            } catch (e) { /* skip bad TLEs */ }
            i += 2;
        }
    }

    console.log(`Parsed ${satellites.length} satellites`);
    $loadingStatus.textContent = `Loaded ${satellites.length} satellites. Building visualization...`;

    classifyPlanes();
    createSatellitePoints();
    buildSatList();
    updateStats();
}

// Satellites excluded from plane assignment (e.g. deorbiting, drifting)
const PLANE_EXCLUDE = ['0013', '0050', '0618'];

function classifyPlanes() {
    // Only nominal sats: inclination ~87.5-88.5 deg, mean motion ~13.1-13.3 rev/day
    const nominal = [];
    for (const sat of satellites) {
        const excluded = PLANE_EXCLUDE.some(id => sat.name.includes(id));
        const mm = sat.satrec.no * (1440 / (2 * Math.PI));
        if (!excluded && sat.inclination >= 87.5 && sat.inclination <= 88.5 && mm >= 13.1 && mm <= 13.3) {
            const raan = (sat.satrec.nodeo * RAD2DEG % 360 + 360) % 360;
            nominal.push({ sat, raan });
        } else {
            sat.plane = 0;
        }
    }

    if (nominal.length === 0) return;

    // Brute-force best offset for 12 bins at 15 deg spacing (Walker-Star, 180 deg span)
    const SPACING = 15;
    let bestOffset = 0, bestError = Infinity;
    for (let off = 0; off < SPACING; off += 0.5) {
        let err = 0;
        for (const { raan } of nominal) {
            const binCenter = Math.round((raan - off) / SPACING) * SPACING + off;
            let d = raan - binCenter;
            if (d > 180) d -= 360;
            if (d < -180) d += 360;
            err += d * d;
        }
        if (err < bestError) { bestError = err; bestOffset = off; }
    }

    // Assign to bins, compute mean RAAN per bin
    const bins = new Map(); // binKey -> { sats: [], raanSum, count }
    for (const entry of nominal) {
        const binKey = Math.round((entry.raan - bestOffset) / SPACING);
        if (!bins.has(binKey)) bins.set(binKey, { sats: [], raanSum: 0, count: 0 });
        const b = bins.get(binKey);
        b.sats.push(entry.sat);
        b.raanSum += entry.raan;
        b.count++;
    }

    // Sort bins by mean RAAN, assign plane 1-12
    const sorted = [...bins.values()].sort((a, b) => (a.raanSum / a.count) - (b.raanSum / b.count));
    sorted.forEach((bin, i) => {
        const planeNum = i + 1;
        for (const sat of bin.sats) sat.plane = planeNum;
    });

    // Any nominal sat not in a bin (shouldn't happen) gets plane 0
    for (const { sat } of nominal) {
        if (sat.plane === undefined) sat.plane = 0;
    }

    console.log(`Classified ${nominal.length} nominal sats into ${sorted.length} planes`);
}

// ============================================================
// SATELLITE RENDERING
// ============================================================
function createSatellitePoints() {
    const count = satellites.length;
    satGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);

    satGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    satGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    satColorAttr = satGeometry.getAttribute('color');

    // Point texture
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.2, 'rgba(0,229,255,0.9)');
    gradient.addColorStop(0.5, 'rgba(0,163,224,0.3)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    const pointTexture = new THREE.CanvasTexture(canvas);

    const mat = new THREE.PointsMaterial({
        size: 0.22,
        map: pointTexture,
        vertexColors: true,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
    });

    satPointCloud = new THREE.Points(satGeometry, mat);
    satPointCloud.renderOrder = 1;
    scene.add(satPointCloud);

    // Set initial colors
    const baseColor = new THREE.Color(0x00e5ff);
    for (let i = 0; i < count; i++) {
        colors[i * 3] = baseColor.r;
        colors[i * 3 + 1] = baseColor.g;
        colors[i * 3 + 2] = baseColor.b;
    }
    satColorAttr.needsUpdate = true;

    // First position update
    updateSatellitePositions();

    // Hide loading
    setTimeout(() => $loading.classList.add('hidden'), 400);
}

function showPlaneGlow(planeNum) {
    removePlaneGlow();

    // Collect indices of satellites in this plane
    planeGlowIndices = [];
    for (let i = 0; i < satellites.length; i++) {
        if (satellites[i].plane === planeNum) planeGlowIndices.push(i);
    }
    if (planeGlowIndices.length === 0) return;

    const count = planeGlowIndices.length;
    planeGlowGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);

    // Copy current positions from main geometry
    const mainPos = satGeometry.getAttribute('position');
    for (let j = 0; j < count; j++) {
        const i = planeGlowIndices[j];
        positions[j * 3] = mainPos.getX(i);
        positions[j * 3 + 1] = mainPos.getY(i);
        positions[j * 3 + 2] = mainPos.getZ(i);
    }
    planeGlowGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // Big soft blue glow texture
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.1, 'rgba(100,200,255,0.9)');
    gradient.addColorStop(0.3, 'rgba(0,180,255,0.5)');
    gradient.addColorStop(0.6, 'rgba(0,120,255,0.15)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);
    const glowTexture = new THREE.CanvasTexture(canvas);

    const mat = new THREE.PointsMaterial({
        size: 0.65,
        map: glowTexture,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
        color: 0x44bbff,
    });

    planeGlowCloud = new THREE.Points(planeGlowGeo, mat);
    scene.add(planeGlowCloud);
}

function removePlaneGlow() {
    if (planeGlowCloud) {
        scene.remove(planeGlowCloud);
        planeGlowGeo.dispose();
        planeGlowCloud.material.map.dispose();
        planeGlowCloud.material.dispose();
        planeGlowCloud = null;
        planeGlowGeo = null;
        planeGlowIndices = [];
    }
    // Hide rotate buttons
}

function updatePlaneGlow() {
    if (!planeGlowCloud || !planeGlowGeo || planeGlowIndices.length === 0) return;
    const mainPos = satGeometry.getAttribute('position');
    const glowPos = planeGlowGeo.getAttribute('position');
    for (let j = 0; j < planeGlowIndices.length; j++) {
        const i = planeGlowIndices[j];
        glowPos.setXYZ(j, mainPos.getX(i), mainPos.getY(i), mainPos.getZ(i));
    }
    glowPos.needsUpdate = true;
}

function geoToVec3(latDeg, lonDeg, altKm) {
    const r = EARTH_RADIUS + altKm * SAT_SCALE;
    const latRad = latDeg * DEG2RAD;
    const lonRad = -lonDeg * DEG2RAD; // negate for Three.js convention
    return new THREE.Vector3(
        r * Math.cos(latRad) * Math.cos(lonRad),
        r * Math.sin(latRad),
        r * Math.cos(latRad) * Math.sin(lonRad)
    );
}

// Allocation-free version that writes into an existing Vector3
const _geoOut = new THREE.Vector3();
function geoToVec3Into(latDeg, lonDeg, altKm, out) {
    const r = EARTH_RADIUS + altKm * SAT_SCALE;
    const latRad = latDeg * DEG2RAD;
    const lonRad = -lonDeg * DEG2RAD;
    return out.set(
        r * Math.cos(latRad) * Math.cos(lonRad),
        r * Math.sin(latRad),
        r * Math.cos(latRad) * Math.sin(lonRad)
    );
}

function updateSatellitePositions() {
    if (!satellites.length || !satGeometry) return;

    const posAttr = satGeometry.getAttribute('position');
    const gmst = satellite.gstime(simTime);
    let totalAlt = 0;
    let validCount = 0;

    for (let i = 0; i < satellites.length; i++) {
        const sat = satellites[i];
        const posVel = satellite.propagate(sat.satrec, simTime);

        if (posVel.position && typeof posVel.position !== 'boolean') {
            const eci = posVel.position;
            const geo = satellite.eciToGeodetic(eci, gmst);

            sat.lat = satellite.degreesLat(geo.latitude);
            sat.lon = satellite.degreesLong(geo.longitude);
            sat.alt = geo.height;

            // Cache ECI position for reuse by detail panel
            sat.eciX = eci.x; sat.eciY = eci.y; sat.eciZ = eci.z;

            if (posVel.velocity) {
                const v = posVel.velocity;
                sat.speed = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
            }

            // Store previous world position for velocity direction (tracking arrow)
            sat._prevX = sat.x; sat._prevY = sat.y; sat._prevZ = sat.z;

            if (referenceFrame === 'eci') {
                // ECI → scene directly: (eciX, eciZ, -eciY) * SAT_SCALE
                const s = SAT_SCALE;
                sat.x = eci.x * s;
                sat.y = eci.z * s;
                sat.z = -eci.y * s;
            } else {
                geoToVec3Into(sat.lat, sat.lon, sat.alt, _geoOut);
                sat.x = _geoOut.x;
                sat.y = _geoOut.y;
                sat.z = _geoOut.z;
            }

            posAttr.setXYZ(i, sat.x, sat.y, sat.z);
            totalAlt += sat.alt;
            validCount++;
        }
    }

    posAttr.needsUpdate = true;

    // Sync plane glow overlay positions
    updatePlaneGlow();

    // Update average altitude stat
    if (validCount > 0) {
        $statAlt.textContent = Math.round(totalAlt / validCount).toLocaleString();
    }
}

// ============================================================
// ORBIT PATH FOR SELECTED SAT
// ============================================================
function computePathPoints(sat, startMs, endMs, steps) {
    const dt = (endMs - startMs) / steps;
    const orbitPts = [];
    const trackPts = [];
    const isEci = referenceFrame === 'eci';
    for (let s = 0; s <= steps; s++) {
        const t = new Date(startMs + s * dt);
        const pv = satellite.propagate(sat.satrec, t);
        if (pv.position && typeof pv.position !== 'boolean') {
            if (isEci) {
                const e = pv.position;
                const sc = SAT_SCALE;
                orbitPts.push(new THREE.Vector3(e.x * sc, e.z * sc, -e.y * sc));
            } else {
                const gmst = satellite.gstime(t);
                const geo = satellite.eciToGeodetic(pv.position, gmst);
                const lat = satellite.degreesLat(geo.latitude);
                const lon = satellite.degreesLong(geo.longitude);
                const alt = geo.height;
                orbitPts.push(geoToVec3(lat, lon, alt));
                trackPts.push(geoToVec3(lat, lon, 0));
            }
        }
    }
    return { orbitPts, trackPts };
}

function makeLine(pts, color, opacity, additive) {
    if (pts.length < 2) return null;
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({
        color, transparent: true, opacity, depthWrite: false,
        blending: additive ? THREE.AdditiveBlending : THREE.NormalBlending,
    });
    const line = new THREE.Line(geo, mat);
    scene.add(line);
    return line;
}

function disposeLine(line) {
    if (!line) return null;
    scene.remove(line);
    line.geometry.dispose();
    line.material.dispose();
    return null;
}

function showOrbitPath(satIndex) {
    clearOrbitPath();
    if (satIndex < 0 || satIndex >= satellites.length) return;

    const sat = satellites[satIndex];
    const periodMs = sat.period * 60 * 1000;
    const nowMs = simTime.getTime();
    const isTracking = trackingIndex === satIndex;

    // Reduce path resolution at high speed (less noticeable + much cheaper)
    const hiSpeed = Math.abs(timeMultiplier) > 50;

    if (isTracking) {
        // Past: vivid green, 2 revolutions back
        const past = computePathPoints(sat, nowMs - periodMs * 2, nowMs, hiSpeed ? 150 : 400);
        pastOrbitLine = makeLine(past.orbitPts, 0x00ff88, 0.85, true);
        if (past.trackPts.length > 1) pastGroundTrack = makeLine(past.trackPts, 0x00ff88, 0.2, false);
    } else {
        // Default select: orange, 1 revolution forward
        const fwd = computePathPoints(sat, nowMs, nowMs + periodMs, hiSpeed ? 80 : 200);
        orbitLine = makeLine(fwd.orbitPts, 0xff6b35, 0.6, false);
        if (fwd.trackPts.length > 1) groundTrack = makeLine(fwd.trackPts, 0xff6b35, 0.15, false);
    }
}

function clearOrbitPath() {
    orbitLine = disposeLine(orbitLine);
    groundTrack = disposeLine(groundTrack);
    pastOrbitLine = disposeLine(pastOrbitLine);
    pastGroundTrack = disposeLine(pastGroundTrack);
}

// ============================================================
// ORBITAL ELEMENT VISUALISATIONS
// ============================================================
function eciToScene(eciX, eciY, eciZ, gmst) {
    const cosG = Math.cos(gmst), sinG = Math.sin(gmst);
    const ecefX = eciX * cosG + eciY * sinG;
    const ecefY = -eciX * sinG + eciY * cosG;
    const ecefZ = eciZ;
    return new THREE.Vector3(ecefX, ecefZ, -ecefY);
}

function makeRingPoints(radius, normal, center, segments) {
    segments = segments || 64;
    const n = normal.clone().normalize();
    const arb = Math.abs(n.y) < 0.9 ? new THREE.Vector3(0, 1, 0) : new THREE.Vector3(1, 0, 0);
    const u = new THREE.Vector3().crossVectors(n, arb).normalize();
    const v = new THREE.Vector3().crossVectors(n, u).normalize();
    const pts = [];
    for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        const ct = Math.cos(theta), st = Math.sin(theta);
        pts.push(new THREE.Vector3(
            center.x + radius * (ct * u.x + st * v.x),
            center.y + radius * (ct * u.y + st * v.y),
            center.z + radius * (ct * u.z + st * v.z)
        ));
    }
    return pts;
}

function makeArcPoints(radius, axis, center, startDir, angleDeg, segments) {
    segments = segments || 32;
    const k = axis.clone().normalize();
    const d = startDir.clone().normalize();
    const angleRad = angleDeg * DEG2RAD;
    const kCrossD = new THREE.Vector3().crossVectors(k, d);
    const kDotD = k.dot(d);
    const pts = [];
    for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * angleRad;
        const cosT = Math.cos(theta), sinT = Math.sin(theta);
        const rotated = new THREE.Vector3()
            .copy(d).multiplyScalar(cosT)
            .addScaledVector(kCrossD, sinT)
            .addScaledVector(k, kDotD * (1 - cosT));
        pts.push(new THREE.Vector3(
            center.x + radius * rotated.x,
            center.y + radius * rotated.y,
            center.z + radius * rotated.z
        ));
    }
    return pts;
}

function addVizObject(obj) {
    scene.add(obj);
    orbitalVizObjects.push(obj);
}

function hideOrbitOverlays() {
    if (orbitLine) orbitLine.visible = false;
    if (groundTrack) groundTrack.visible = false;
    if (pastOrbitLine) pastOrbitLine.visible = false;
    if (pastGroundTrack) pastGroundTrack.visible = false;
    if (trackingArrow) trackingArrow.visible = false;
    // Keep trackingHalo visible so the satellite stays highlighted
}

function showOrbitOverlays() {
    if (orbitLine) orbitLine.visible = true;
    if (groundTrack) groundTrack.visible = true;
    if (pastOrbitLine) pastOrbitLine.visible = true;
    if (pastGroundTrack) pastGroundTrack.visible = true;
    if (trackingArrow) trackingArrow.visible = true;
}

function clearOrbitalViz() {
    for (const obj of orbitalVizObjects) {
        scene.remove(obj);
        obj.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
    }
    orbitalVizObjects = [];
    if (orbitalVizLabel) {
        orbitalVizLabel.remove();
        orbitalVizLabel = null;
    }
    vizLabelAnchor = null;
    for (const tag of vizTags) tag.el.remove();
    vizTags = [];
    $detailInc.classList.remove('viz-active');
    $detailRaan.classList.remove('viz-active');
    $detailAol.classList.remove('viz-active');
    $detailEcc.classList.remove('viz-active');
    $detailLat.classList.remove('viz-active');
    $detailLon.classList.remove('viz-active');
    // Clean up AoL live-update state
    if (_aolVizState) {
        if (_aolVizState.satMarker) { scene.remove(_aolVizState.satMarker); _aolVizState.satMarker.geometry.dispose(); _aolVizState.satMarker.material.dispose(); }
        if (_aolVizState.satArm) { scene.remove(_aolVizState.satArm); _aolVizState.satArm.geometry.dispose(); _aolVizState.satArm.material.dispose(); }
        if (_aolVizState.arcGroup) {
            scene.remove(_aolVizState.arcGroup);
            _aolVizState.arcGroup.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
        }
        _aolVizState = null;
    }
    if (orbitalVizMode) showOrbitOverlays();
    orbitalVizMode = null;

    // Restore previous reference frame if auto-switched for viz
    if (_frameBeforeViz !== null) {
        setReferenceFrame(_frameBeforeViz);
        _frameBeforeViz = null;
    }
}

function addVizTag(text, anchor, color) {
    const el = document.createElement('div');
    el.className = 'viz-tag';
    el.textContent = text;
    el.style.color = color || '#e0e8f0';
    document.body.appendChild(el);
    vizTags.push({ el, anchor: anchor.clone() });
    requestAnimationFrame(() => el.classList.add('visible'));
}

function createEquatorialRing(orbitRadius) {
    const eqNormal = new THREE.Vector3(0, 1, 0);
    const eqCenter = new THREE.Vector3(0, 0, 0);
    const ringPts = makeRingPoints(orbitRadius, eqNormal, eqCenter, 96);
    const ringGeo = new THREE.BufferGeometry().setFromPoints(ringPts);
    const ringMat = new THREE.LineBasicMaterial({
        color: 0x00e5ff, transparent: true, opacity: 0.6, depthWrite: false
    });
    addVizObject(new THREE.Line(ringGeo, ringMat));

    // Shaded equatorial disc
    const discGeo = new THREE.RingGeometry(EARTH_RADIUS * 1.02, orbitRadius, 64);
    const discMat = new THREE.MeshBasicMaterial({
        color: 0x00e5ff, transparent: true, opacity: 0.12,
        side: THREE.DoubleSide, depthWrite: false
    });
    const disc = new THREE.Mesh(discGeo, discMat);
    disc.rotation.x = -Math.PI / 2;
    addVizObject(disc);
}

function createOrbitalRing(orbitRadius, orbNormal) {
    const center = new THREE.Vector3(0, 0, 0);
    const ringPts = makeRingPoints(orbitRadius, orbNormal, center, 96);
    const ringGeo = new THREE.BufferGeometry().setFromPoints(ringPts);
    const ringMat = new THREE.LineBasicMaterial({
        color: 0xff6b35, transparent: true, opacity: 0.6, depthWrite: false
    });
    addVizObject(new THREE.Line(ringGeo, ringMat));

    // Shaded orbital disc
    const discGeo = new THREE.RingGeometry(EARTH_RADIUS * 1.02, orbitRadius, 64);
    const discMat = new THREE.MeshBasicMaterial({
        color: 0xff6b35, transparent: true, opacity: 0.12,
        side: THREE.DoubleSide, depthWrite: false
    });
    const disc = new THREE.Mesh(discGeo, discMat);
    // Orient disc to match orbital plane normal
    const up = new THREE.Vector3(0, 0, 1); // RingGeometry default normal
    const quat = new THREE.Quaternion().setFromUnitVectors(up, orbNormal.clone().normalize());
    disc.quaternion.copy(quat);
    addVizObject(disc);
}

function createLineOfNodes(anDir, orbitRadius) {
    const len = orbitRadius * 1.15;
    const pts = [anDir.clone().multiplyScalar(-len), anDir.clone().multiplyScalar(len)];
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineDashedMaterial({
        color: 0x6a7b90, transparent: true, opacity: 0.5,
        dashSize: 0.2, gapSize: 0.1, depthWrite: false
    });
    const line = new THREE.Line(geo, mat);
    line.computeLineDistances();
    addVizObject(line);
}

function createArcTicks(radius, axis, center, startDir, angleDeg, tickInterval) {
    tickInterval = tickInterval || 10;
    const k = axis.clone().normalize();
    const d = startDir.clone().normalize();
    const kCrossD = new THREE.Vector3().crossVectors(k, d);
    const kDotD = k.dot(d);
    const pts = [];
    for (let deg = tickInterval; deg < angleDeg; deg += tickInterval) {
        const theta = deg * DEG2RAD;
        const cosT = Math.cos(theta), sinT = Math.sin(theta);
        const rotated = new THREE.Vector3()
            .copy(d).multiplyScalar(cosT)
            .addScaledVector(kCrossD, sinT)
            .addScaledVector(k, kDotD * (1 - cosT));
        pts.push(rotated.clone().multiplyScalar(radius * 0.92).add(center));
        pts.push(rotated.clone().multiplyScalar(radius * 1.08).add(center));
    }
    if (pts.length < 2) return;
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({
        color: 0x00e676, transparent: true, opacity: 0.5, depthWrite: false
    });
    addVizObject(new THREE.LineSegments(geo, mat));
}

function createVizArrow(from, to, color) {
    const dir = new THREE.Vector3().subVectors(to, from);
    const len = dir.length();
    if (len < 0.001) return;
    dir.normalize();
    const shaftLen = len * 0.82;
    const headLen = len * 0.18;
    const shaftGeo = new THREE.CylinderGeometry(0.05, 0.05, shaftLen, 8);
    const headGeo = new THREE.ConeGeometry(0.14, headLen, 10);
    const mat = new THREE.MeshBasicMaterial({ color });
    const shaft = new THREE.Mesh(shaftGeo, mat);
    shaft.position.y = shaftLen / 2;
    const head = new THREE.Mesh(headGeo, mat.clone());
    head.position.y = shaftLen + headLen / 2;
    const group = new THREE.Group();
    group.add(shaft);
    group.add(head);
    const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
    group.quaternion.copy(quat);
    group.position.copy(from);
    addVizObject(group);
}

function createBoldArc(arcPts, color) {
    if (arcPts.length < 3) return;
    // Arrowhead dimensions (matching createVizArrow style)
    const headLen = 0.25;
    const headRadius = 0.14;
    const tubeRadius = 0.05;

    // Shorten tube so it ends at the base of the arrowhead
    const endPt = arcPts[arcPts.length - 1];
    const prevPt = arcPts[arcPts.length - 2];
    const tangent = new THREE.Vector3().subVectors(endPt, prevPt).normalize();
    const headBase = endPt.clone().addScaledVector(tangent, -headLen);

    // Trim arc points: replace the last point with the head base
    const trimmed = arcPts.slice(0, -1);
    trimmed.push(headBase);

    // Tube shaft
    const curve = new THREE.CatmullRomCurve3(trimmed);
    const tubeGeo = new THREE.TubeGeometry(curve, trimmed.length * 2, tubeRadius, 8, false);
    const tubeMat = new THREE.MeshBasicMaterial({ color });
    addVizObject(new THREE.Mesh(tubeGeo, tubeMat));

    // Arrowhead — tip at end of measurement
    const headGeo = new THREE.ConeGeometry(headRadius, headLen, 10);
    const headMat = new THREE.MeshBasicMaterial({ color });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.copy(endPt).addScaledVector(tangent, -headLen / 2);
    const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), tangent);
    head.quaternion.copy(quat);
    addVizObject(head);
}

function createVizLabel(title, subtitle) {
    if (orbitalVizLabel) orbitalVizLabel.remove();
    const el = document.createElement('div');
    el.className = 'orbital-viz-label';
    el.innerHTML = '<div class="viz-title">' + title + '</div><div class="viz-subtitle">' + subtitle + '</div>';
    document.body.appendChild(el);
    orbitalVizLabel = el;
    requestAnimationFrame(() => el.classList.add('visible'));
}

function updateOrbitalVizLabel() {
    const w = window.innerWidth, h = window.innerHeight;
    if (orbitalVizLabel && vizLabelAnchor) {
        _projectedVec.copy(vizLabelAnchor).project(camera);
        if (_projectedVec.z > 1) {
            orbitalVizLabel.classList.remove('visible');
        } else {
            orbitalVizLabel.classList.add('visible');
            orbitalVizLabel.style.left = ((_projectedVec.x * 0.5 + 0.5) * w) + 'px';
            orbitalVizLabel.style.top = ((-_projectedVec.y * 0.5 + 0.5) * h - 12) + 'px';
        }
    }
    for (const tag of vizTags) {
        _projectedVec.copy(tag.anchor).project(camera);
        if (_projectedVec.z > 1) {
            tag.el.classList.remove('visible');
        } else {
            tag.el.classList.add('visible');
            tag.el.style.left = ((_projectedVec.x * 0.5 + 0.5) * w) + 'px';
            tag.el.style.top = ((-_projectedVec.y * 0.5 + 0.5) * h) + 'px';
        }
    }
}

function animateCameraToVizView(endLatRad, endLonRad, endDist) {
    const cp = camera.position;
    const currentDist = cp.length();
    const startLat = Math.asin(cp.y / currentDist);
    const startLon = Math.atan2(cp.z, cp.x);
    let dLon = endLonRad - startLon;
    if (dLon > Math.PI) dLon -= 2 * Math.PI;
    if (dLon < -Math.PI) dLon += 2 * Math.PI;
    const totalAngle = Math.abs(dLon) + Math.abs(endLatRad - startLat);
    const ratio = totalAngle / Math.PI;
    const duration = 1.0 + ratio * ratio * 3.0;
    cameraAnim = {
        startLat, startLon, endLat: endLatRad, dLon,
        startDist: currentDist, endDist: endDist,
        startTarget: controls.target.clone(),
        endTarget: new THREE.Vector3(0, 0, 0),
        progress: 0, duration
    };
}

function showInclinationViz(satIndex) {
    clearOrbitalViz();
    if (satIndex < 0 || satIndex >= satellites.length) return;
    // Auto-switch to ECI — inclination is defined in inertial frame
    if (referenceFrame !== 'eci') {
        _frameBeforeViz = referenceFrame;
        setReferenceFrame('eci');
    }
    hideOrbitOverlays();
    const sat = satellites[satIndex];
    const incRad = sat.satrec.inclo;
    const raanRad = sat.satrec.nodeo;
    const incDeg = incRad * RAD2DEG;
    vizGmst = 0;
    const orbitRadius = EARTH_RADIUS + (sat.alt || 1200) * SAT_SCALE;

    // Ascending node direction in ECI → scene
    const anScene = eciToScene(Math.cos(raanRad), Math.sin(raanRad), 0, vizGmst).normalize();

    // Orbital plane normal in ECI → scene
    const si = Math.sin(incRad), ci = Math.cos(incRad);
    const sO = Math.sin(raanRad), cO = Math.cos(raanRad);
    const normalScene = eciToScene(si * sO, -si * cO, ci, vizGmst).normalize();

    // Equatorial ring + disc
    createEquatorialRing(orbitRadius);

    // Orbital ring
    createOrbitalRing(orbitRadius, normalScene);

    // Line of nodes
    createLineOfNodes(anScene, orbitRadius);

    // Forward directions at ascending node
    const eqNormal = new THREE.Vector3(0, 1, 0);
    const eqForward = new THREE.Vector3().crossVectors(eqNormal, anScene).normalize();
    const orbForward = new THREE.Vector3().crossVectors(normalScene, anScene).normalize();

    // Reference arms from ascending node along each plane (frames the angle)
    const anPoint = anScene.clone().multiplyScalar(orbitRadius);
    const armLen = orbitRadius * 0.55;
    // Equatorial arm (cyan)
    const eqArmEnd = anPoint.clone().addScaledVector(eqForward, armLen);
    const eqArmGeo = new THREE.BufferGeometry().setFromPoints([anPoint.clone(), eqArmEnd]);
    const eqArmMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.7, depthWrite: false });
    addVizObject(new THREE.Line(eqArmGeo, eqArmMat));
    // Orbital arm (orange)
    const orbArmEnd = anPoint.clone().addScaledVector(orbForward, armLen);
    const orbArmGeo = new THREE.BufferGeometry().setFromPoints([anPoint.clone(), orbArmEnd]);
    const orbArmMat = new THREE.LineBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.7, depthWrite: false });
    addVizObject(new THREE.Line(orbArmGeo, orbArmMat));

    // Inclination measurement arc (bold 3D tube + arrowhead)
    const arcRadius = armLen * 0.6;
    const arcPts = makeArcPoints(arcRadius, anScene, anPoint, eqForward, incDeg, 48);
    createBoldArc(arcPts, 0x00e676);

    // Tick marks every 10°
    createArcTicks(arcRadius, anScene, anPoint, eqForward, incDeg, 10);

    // Label anchor at arc midpoint, offset outward
    const midTheta = (incDeg / 2) * DEG2RAD;
    const kCrossD = new THREE.Vector3().crossVectors(anScene.clone().normalize(), eqForward);
    const midDir = new THREE.Vector3()
        .copy(eqForward).multiplyScalar(Math.cos(midTheta))
        .addScaledVector(kCrossD, Math.sin(midTheta));
    vizLabelAnchor = anPoint.clone().addScaledVector(midDir.normalize(), arcRadius * 1.6);

    createVizLabel('INCLINATION', incDeg.toFixed(2) + '\u00B0');

    // Feature labels
    addVizTag('EQUATORIAL PLANE', anScene.clone().negate().multiplyScalar(orbitRadius * 1.06), '#00e5ff');
    addVizTag('ORBITAL PLANE', anScene.clone().negate().multiplyScalar(orbitRadius * 0.5).addScaledVector(orbForward, orbitRadius * 0.8), '#ff6b35');
    addVizTag('ASCENDING NODE', anPoint.clone().addScaledVector(anScene, 0.4), '#6a7b90');
    addVizTag('LINE OF NODES', anScene.clone().multiplyScalar(-orbitRadius * 0.9), '#6a7b90');

    orbitalVizMode = 'inclination';
    $detailInc.classList.add('viz-active');

    // Camera: side-on to line of nodes, slight elevation
    const viewDir = new THREE.Vector3().crossVectors(eqNormal, anScene).normalize();
    const camDir = camera.position.clone().normalize();
    if (viewDir.dot(camDir) < 0) viewDir.negate();
    const endLat = 15 * DEG2RAD;
    const endLon = Math.atan2(viewDir.z, viewDir.x);
    animateCameraToVizView(endLat, endLon, 20);
}

function showRaanViz(satIndex) {
    clearOrbitalViz();
    if (satIndex < 0 || satIndex >= satellites.length) return;
    // Auto-switch to ECI — RAAN is defined in inertial frame
    if (referenceFrame !== 'eci') {
        _frameBeforeViz = referenceFrame;
        setReferenceFrame('eci');
    }
    hideOrbitOverlays();
    const sat = satellites[satIndex];
    const incRad = sat.satrec.inclo;
    const raanRad = sat.satrec.nodeo;
    const raanDeg = ((raanRad * RAD2DEG) % 360 + 360) % 360;
    vizGmst = 0;
    const orbitRadius = EARTH_RADIUS + (sat.alt || 1200) * SAT_SCALE;

    // Ascending node direction in scene
    const anScene = eciToScene(Math.cos(raanRad), Math.sin(raanRad), 0, vizGmst).normalize();

    // Orbital plane normal in scene
    const si = Math.sin(incRad), ci = Math.cos(incRad);
    const sO = Math.sin(raanRad), cO = Math.cos(raanRad);
    const normalScene = eciToScene(si * sO, -si * cO, ci, vizGmst).normalize();

    // Vernal equinox direction in scene
    const veScene = eciToScene(1, 0, 0, vizGmst).normalize();

    // Equatorial ring + disc
    createEquatorialRing(orbitRadius);

    // Orbital ring
    createOrbitalRing(orbitRadius, normalScene);

    // Vernal equinox 3D arrow
    const arrowLen = orbitRadius * 1.2;
    createVizArrow(new THREE.Vector3(0, 0, 0), veScene.clone().multiplyScalar(arrowLen), 0x00e5ff);

    // Ascending node marker (orange sphere)
    const anPoint = anScene.clone().multiplyScalar(orbitRadius);
    const markerGeo = new THREE.SphereGeometry(0.18, 16, 16);
    const markerMat = new THREE.MeshBasicMaterial({ color: 0xff6b35 });
    const marker = new THREE.Mesh(markerGeo, markerMat);
    marker.position.copy(anPoint);
    addVizObject(marker);

    // Reference arm from origin to ascending node (orange, solid)
    const anArmGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), anPoint.clone()]);
    const anArmMat = new THREE.LineBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.7, depthWrite: false });
    addVizObject(new THREE.Line(anArmGeo, anArmMat));

    // Reference arm from origin along vernal equinox (cyan, solid)
    const veArmEnd = veScene.clone().multiplyScalar(orbitRadius);
    const veArmGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), veArmEnd]);
    const veArmMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.7, depthWrite: false });
    addVizObject(new THREE.Line(veArmGeo, veArmMat));

    // RAAN measurement arc (bold 3D tube + arrowhead) — above Earth surface
    const arcRadius = EARTH_RADIUS * 1.12;
    const eqUp = new THREE.Vector3(0, 1, 0);
    const arcPts = makeArcPoints(arcRadius, eqUp, new THREE.Vector3(0, 0, 0), veScene, raanDeg, 64);
    createBoldArc(arcPts, 0x00e676);

    // Tick marks every 30°
    createArcTicks(arcRadius, eqUp, new THREE.Vector3(0, 0, 0), veScene, raanDeg, 30);

    // Label anchor at arc midpoint
    const midTheta = (raanDeg / 2) * DEG2RAD;
    const vePerp = new THREE.Vector3().crossVectors(eqUp, veScene);
    const midDir = new THREE.Vector3()
        .copy(veScene).multiplyScalar(Math.cos(midTheta))
        .addScaledVector(vePerp, Math.sin(midTheta));
    vizLabelAnchor = midDir.normalize().multiplyScalar(arcRadius * 1.3);
    vizLabelAnchor.y += 0.5;

    createVizLabel('RAAN', raanDeg.toFixed(2) + '\u00B0');

    // Feature labels
    addVizTag('VERNAL EQUINOX  \u2648', veScene.clone().multiplyScalar(arrowLen * 1.08), '#00e5ff');
    addVizTag('ASCENDING NODE', anPoint.clone().addScaledVector(anScene, 0.4), '#ff6b35');
    addVizTag('EQUATORIAL PLANE', veScene.clone().negate().multiplyScalar(orbitRadius * 1.06), '#00e5ff');
    addVizTag('ORBITAL PLANE', anScene.clone().multiplyScalar(orbitRadius * 0.5).addScaledVector(new THREE.Vector3().crossVectors(normalScene, anScene).normalize(), orbitRadius * 0.8), '#ff6b35');

    orbitalVizMode = 'raan';
    $detailRaan.classList.add('viz-active');

    // Camera: near-polar looking down, oriented above arc midpoint
    const endLat = 75 * DEG2RAD;
    const endLon = Math.atan2(midDir.z, midDir.x);
    animateCameraToVizView(endLat, endLon, 20);
}

// AoL viz dynamic state — updated every frame
let _aolVizState = null;

function showAolViz(satIndex) {
    clearOrbitalViz();
    if (satIndex < 0 || satIndex >= satellites.length) return;
    // Auto-switch to ECI — argument of latitude is defined in inertial frame
    if (referenceFrame !== 'eci') {
        _frameBeforeViz = referenceFrame;
        setReferenceFrame('eci');
    }
    hideOrbitOverlays();
    const sat = satellites[satIndex];
    const incRad = sat.satrec.inclo;
    const raanRad = sat.satrec.nodeo;
    vizGmst = 0;
    const orbitRadius = EARTH_RADIUS + (sat.alt || 1200) * SAT_SCALE;

    // Ascending node direction in ECI → scene
    const anScene = eciToScene(Math.cos(raanRad), Math.sin(raanRad), 0, vizGmst).normalize();

    // Orbital plane normal in ECI → scene
    const si = Math.sin(incRad), ci = Math.cos(incRad);
    const sO = Math.sin(raanRad), cO = Math.cos(raanRad);
    const normalScene = eciToScene(si * sO, -si * cO, ci, vizGmst).normalize();

    // Equatorial ring + disc
    createEquatorialRing(orbitRadius);

    // Orbital ring
    createOrbitalRing(orbitRadius, normalScene);

    // Line of nodes
    createLineOfNodes(anScene, orbitRadius);

    // Ascending node point (static)
    const anPoint = anScene.clone().multiplyScalar(orbitRadius);
    const markerGeo = new THREE.SphereGeometry(0.18, 16, 16);
    const markerMat = new THREE.MeshBasicMaterial({ color: 0xff6b35 });
    const marker = new THREE.Mesh(markerGeo, markerMat);
    marker.position.copy(anPoint);
    addVizObject(marker);

    // Ascending node arm (static — orange)
    const arcCenter = new THREE.Vector3(0, 0, 0);
    const anArmGeo = new THREE.BufferGeometry().setFromPoints([arcCenter.clone(), anPoint.clone()]);
    const anArmMat = new THREE.LineBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.7, depthWrite: false });
    addVizObject(new THREE.Line(anArmGeo, anArmMat));

    const orbForward = new THREE.Vector3().crossVectors(normalScene, anScene).normalize();

    // Static feature labels
    addVizTag('ASCENDING NODE', anPoint.clone().addScaledVector(anScene, 0.4), '#ff6b35');
    addVizTag('ORBITAL PLANE', anScene.clone().negate().multiplyScalar(orbitRadius * 0.5).addScaledVector(orbForward, orbitRadius * 0.8), '#ff6b35');

    // Store state for live updates — dynamic objects created in updateAolViz
    _aolVizState = {
        satIndex,
        incRad, raanRad,
        orbitRadius,
        anScene: anScene.clone(),
        normalScene: normalScene.clone(),
        arcRadius: orbitRadius * 0.85,
        // Dynamic Three.js objects (rebuilt each frame)
        satMarker: null,
        arcGroup: null, // holds arc tube + ticks
        satArm: null,
        satTag: null, // DOM element for satellite tag
    };

    // Initial build of dynamic parts
    updateAolViz();

    orbitalVizMode = 'aol';
    $detailAol.classList.add('viz-active');

    // Camera: side-on to orbital plane
    const viewDir = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), normalScene).normalize();
    const camDir = camera.position.clone().normalize();
    if (viewDir.dot(camDir) < 0) viewDir.negate();
    const endLat = 25 * DEG2RAD;
    const endLon = Math.atan2(viewDir.z, viewDir.x);
    animateCameraToVizView(endLat, endLon, 20);
}

function updateAolViz() {
    if (!_aolVizState) return;
    const st = _aolVizState;
    const sat = satellites[st.satIndex];
    if (!sat || sat.eciX === undefined) return;

    // Compute current AoL
    const nx = Math.cos(st.raanRad), ny = Math.sin(st.raanRad);
    const px = sat.eciX * nx + sat.eciY * ny;
    const py = (-sat.eciX * ny + sat.eciY * nx) * Math.cos(st.incRad) + sat.eciZ * Math.sin(st.incRad);
    const aolDeg = ((Math.atan2(py, px) * RAD2DEG) % 360 + 360) % 360;

    // Satellite position in scene
    const satScene = eciToScene(sat.eciX, sat.eciY, sat.eciZ, vizGmst).normalize().multiplyScalar(st.orbitRadius);
    const arcCenter = new THREE.Vector3(0, 0, 0);

    // --- Remove old dynamic objects ---
    if (st.satMarker) { scene.remove(st.satMarker); st.satMarker.geometry.dispose(); st.satMarker.material.dispose(); }
    if (st.satArm) { scene.remove(st.satArm); st.satArm.geometry.dispose(); st.satArm.material.dispose(); }
    if (st.arcGroup) {
        scene.remove(st.arcGroup);
        st.arcGroup.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
    }
    if (st.satTag) { st.satTag.remove(); vizTags = vizTags.filter(t => t.el !== st.satTag); }

    // --- Satellite marker ---
    const satMarkerGeo = new THREE.SphereGeometry(0.22, 16, 16);
    const satMarkerMat = new THREE.MeshBasicMaterial({ color: 0x00e676 });
    st.satMarker = new THREE.Mesh(satMarkerGeo, satMarkerMat);
    st.satMarker.position.copy(satScene);
    scene.add(st.satMarker);

    // --- Sat arm line ---
    const satArmGeo = new THREE.BufferGeometry().setFromPoints([arcCenter.clone(), satScene.clone()]);
    const satArmMat = new THREE.LineBasicMaterial({ color: 0x00e676, transparent: true, opacity: 0.7, depthWrite: false });
    st.satArm = new THREE.Line(satArmGeo, satArmMat);
    scene.add(st.satArm);

    // --- Arc + ticks as a group ---
    st.arcGroup = new THREE.Group();
    const arcPts = makeArcPoints(st.arcRadius, st.normalScene, arcCenter, st.anScene, aolDeg, 64);
    // Bold arc (tube)
    if (arcPts.length >= 2) {
        const curve = new THREE.CatmullRomCurve3(arcPts);
        const tubeGeo = new THREE.TubeGeometry(curve, arcPts.length, 0.06, 8, false);
        const tubeMat = new THREE.MeshBasicMaterial({ color: 0x00e676, transparent: true, opacity: 0.9, depthWrite: false });
        st.arcGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
    }
    // Ticks every 30°
    const tickInterval = 30;
    const totalAngle = aolDeg;
    if (Math.abs(totalAngle) > tickInterval) {
        const k = st.normalScene.clone().normalize();
        const d = st.anScene.clone().normalize();
        const kCrossD = new THREE.Vector3().crossVectors(k, d);
        const kDotD = k.dot(d);
        const numTicks = Math.floor(Math.abs(totalAngle) / tickInterval);
        for (let t = 1; t <= numTicks; t++) {
            const theta = (t * tickInterval * (totalAngle > 0 ? 1 : -1)) * DEG2RAD;
            const cosT = Math.cos(theta), sinT = Math.sin(theta);
            const rotated = new THREE.Vector3()
                .copy(d).multiplyScalar(cosT)
                .addScaledVector(kCrossD, sinT)
                .addScaledVector(k, kDotD * (1 - cosT));
            const inner = rotated.clone().multiplyScalar(st.arcRadius * 0.92);
            const outer = rotated.clone().multiplyScalar(st.arcRadius * 1.08);
            const tickGeo = new THREE.BufferGeometry().setFromPoints([inner, outer]);
            const tickMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3, depthWrite: false });
            st.arcGroup.add(new THREE.Line(tickGeo, tickMat));
        }
    }
    scene.add(st.arcGroup);

    // --- Satellite tag ---
    const tagAnchor = satScene.clone().addScaledVector(satScene.clone().normalize(), 0.4);
    const el = document.createElement('div');
    el.className = 'viz-tag';
    el.textContent = 'SATELLITE';
    el.style.color = '#00e676';
    document.body.appendChild(el);
    requestAnimationFrame(() => el.classList.add('visible'));
    vizTags.push({ el, anchor: tagAnchor });
    st.satTag = el;

    // --- Update label ---
    const midTheta = (aolDeg / 2) * DEG2RAD;
    const kCross = new THREE.Vector3().crossVectors(st.normalScene.clone().normalize(), st.anScene);
    const midDir = new THREE.Vector3()
        .copy(st.anScene).multiplyScalar(Math.cos(midTheta))
        .addScaledVector(kCross, Math.sin(midTheta));
    vizLabelAnchor = midDir.normalize().multiplyScalar(st.arcRadius * 1.4);

    if (orbitalVizLabel) {
        const sub = orbitalVizLabel.querySelector('.viz-subtitle');
        if (sub) sub.textContent = aolDeg.toFixed(2) + '\u00B0';
    } else {
        createVizLabel('ARG OF LATITUDE', aolDeg.toFixed(2) + '\u00B0');
    }
}

function showEccentricityViz(satIndex) {
    clearOrbitalViz();
    if (satIndex < 0 || satIndex >= satellites.length) return;
    // Auto-switch to ECI
    if (referenceFrame !== 'eci') {
        _frameBeforeViz = referenceFrame;
        setReferenceFrame('eci');
    }
    hideOrbitOverlays();
    const sat = satellites[satIndex];
    const ecc = sat.eccentricity;
    const incRad = sat.satrec.inclo;
    const raanRad = sat.satrec.nodeo;
    const argpRad = sat.satrec.argpo;
    vizGmst = 0;

    // Semi-major axis from mean motion
    const mu = 398600.4418; // km^3/s^2
    const n = sat.satrec.no / 60; // rad/s (satrec.no is rad/min)
    const a_km = Math.pow(mu / (n * n), 1 / 3);
    const a = a_km * SAT_SCALE; // scene units (semi-major axis)
    const b = a * Math.sqrt(1 - ecc * ecc); // semi-minor axis
    const c = a * ecc; // center-to-focus distance

    // Ascending node direction in scene
    const anScene = eciToScene(Math.cos(raanRad), Math.sin(raanRad), 0, vizGmst).normalize();

    // Orbital plane normal in scene
    const si = Math.sin(incRad), ci = Math.cos(incRad);
    const sO = Math.sin(raanRad), cO = Math.cos(raanRad);
    const normalScene = eciToScene(si * sO, -si * cO, ci, vizGmst).normalize();

    // Perigee direction (in orbital plane, rotated by argument of perigee from ascending node)
    const orbForward = new THREE.Vector3().crossVectors(normalScene, anScene).normalize();
    const perigeeDir = new THREE.Vector3()
        .copy(anScene).multiplyScalar(Math.cos(argpRad))
        .addScaledVector(orbForward, Math.sin(argpRad)).normalize();
    const apogeeDir = perigeeDir.clone().negate();

    // Draw the elliptical orbit
    const ellipsePts = [];
    const segments = 128;
    for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * 2 * Math.PI;
        // Ellipse in orbital plane: perigeeDir = x-axis, cross(normal, perigeeDir) = y-axis
        const semiLatusRectum = a * (1 - ecc * ecc);
        const r = semiLatusRectum / (1 + ecc * Math.cos(theta));
        const localX = r * Math.cos(theta);
        const localY = r * Math.sin(theta);
        const perpDir = new THREE.Vector3().crossVectors(normalScene, perigeeDir).normalize();
        const pt = new THREE.Vector3()
            .addScaledVector(perigeeDir, localX)
            .addScaledVector(perpDir, localY);
        ellipsePts.push(pt);
    }
    const ellipseGeo = new THREE.BufferGeometry().setFromPoints(ellipsePts);
    const ellipseMat = new THREE.LineBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.8, depthWrite: false });
    addVizObject(new THREE.Line(ellipseGeo, ellipseMat));

    // Earth (center / focus) marker
    const earthMarkerGeo = new THREE.SphereGeometry(0.15, 16, 16);
    const earthMarkerMat = new THREE.MeshBasicMaterial({ color: 0x00e5ff });
    const earthMarker = new THREE.Mesh(earthMarkerGeo, earthMarkerMat);
    addVizObject(earthMarker);

    // Perigee marker
    const rPerigee = a * (1 - ecc);
    const perigeePos = perigeeDir.clone().multiplyScalar(rPerigee);
    const periGeo = new THREE.SphereGeometry(0.18, 16, 16);
    const periMat = new THREE.MeshBasicMaterial({ color: 0x00e676 });
    const periMarker = new THREE.Mesh(periGeo, periMat);
    periMarker.position.copy(perigeePos);
    addVizObject(periMarker);

    // Apogee marker
    const rApogee = a * (1 + ecc);
    const apogeePos = apogeeDir.clone().multiplyScalar(rApogee);
    const apoGeo = new THREE.SphereGeometry(0.18, 16, 16);
    const apoMat = new THREE.MeshBasicMaterial({ color: 0xff6b35 });
    const apoMarker = new THREE.Mesh(apoGeo, apoMat);
    apoMarker.position.copy(apogeePos);
    addVizObject(apoMarker);

    // Semi-major axis line (perigee to apogee through center)
    const axisGeo = new THREE.BufferGeometry().setFromPoints([perigeePos.clone(), apogeePos.clone()]);
    const axisMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, depthWrite: false });
    addVizObject(new THREE.Line(axisGeo, axisMat));

    // Circular reference orbit (same semi-major axis, dashed feel via segments)
    const circPts = [];
    for (let i = 0; i <= 128; i++) {
        const theta = (i / 128) * 2 * Math.PI;
        const perpDir = new THREE.Vector3().crossVectors(normalScene, perigeeDir).normalize();
        const pt = new THREE.Vector3()
            .addScaledVector(perigeeDir, a * Math.cos(theta))
            .addScaledVector(perpDir, a * Math.sin(theta));
        circPts.push(pt);
    }
    const circGeo = new THREE.BufferGeometry().setFromPoints(circPts);
    const circMat = new THREE.LineDashedMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.3, dashSize: 0.3, gapSize: 0.2, depthWrite: false });
    const circLine = new THREE.Line(circGeo, circMat);
    circLine.computeLineDistances();
    addVizObject(circLine);

    // Label
    const labelPos = perigeeDir.clone().multiplyScalar(rPerigee * 0.5).addScaledVector(normalScene, 1.5);
    vizLabelAnchor = labelPos;
    createVizLabel('ECCENTRICITY', ecc.toFixed(6));

    // Feature labels
    addVizTag('PERIGEE', perigeePos.clone().addScaledVector(perigeeDir, 0.5), '#00e676');
    addVizTag('APOGEE', apogeePos.clone().addScaledVector(apogeeDir, 0.5), '#ff6b35');
    addVizTag('EARTH (FOCUS)', new THREE.Vector3(0, -0.6, 0), '#00e5ff');

    // For OneWeb (near-circular), add note about how close perigee/apogee are
    const periKm = a_km * (1 - ecc) - 6371;
    const apoKm = a_km * (1 + ecc) - 6371;
    addVizTag(Math.round(periKm) + ' km', perigeePos.clone().addScaledVector(perigeeDir, -0.8), '#6a7b90');
    addVizTag(Math.round(apoKm) + ' km', apogeePos.clone().addScaledVector(apogeeDir, -0.8), '#6a7b90');

    orbitalVizMode = 'eccentricity';
    $detailEcc.classList.add('viz-active');

    // Camera: side-on to orbital plane, slightly elevated
    const viewDir = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), normalScene).normalize();
    const camDir = camera.position.clone().normalize();
    if (viewDir.dot(camDir) < 0) viewDir.negate();
    const endLat = 20 * DEG2RAD;
    const endLon = Math.atan2(viewDir.z, viewDir.x);
    animateCameraToVizView(endLat, endLon, 22);
}

function showLatViz(satIndex) {
    clearOrbitalViz();
    if (satIndex < 0 || satIndex >= satellites.length) return;
    if (referenceFrame !== 'ecef') {
        _frameBeforeViz = referenceFrame;
        setReferenceFrame('ecef');
    }
    hideOrbitOverlays();
    const sat = satellites[satIndex];
    const lat = sat.lat;
    const lon = sat.lon;
    const lonRad = -lon * DEG2RAD;

    // Subsatellite point on Earth surface
    const surfacePos = geoToVec3(lat, lon, 0);
    const satPos = geoToVec3(lat, lon, sat.alt);

    // Earth equatorial ring
    const eqRadius = EARTH_RADIUS * 1.005;
    const eqPts = [];
    for (let i = 0; i <= 128; i++) {
        const theta = (i / 128) * 2 * Math.PI;
        eqPts.push(new THREE.Vector3(eqRadius * Math.cos(theta), 0, eqRadius * Math.sin(theta)));
    }
    const eqGeo = new THREE.BufferGeometry().setFromPoints(eqPts);
    const eqMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.5, depthWrite: false });
    addVizObject(new THREE.Line(eqGeo, eqMat));

    // Longitude meridian at satellite's longitude
    const merPts = [];
    for (let i = 0; i <= 64; i++) {
        const latStep = (i / 64) * Math.PI - Math.PI / 2;
        const r = EARTH_RADIUS * 1.005;
        merPts.push(new THREE.Vector3(
            r * Math.cos(latStep) * Math.cos(lonRad),
            r * Math.sin(latStep),
            r * Math.cos(latStep) * Math.sin(lonRad)
        ));
    }
    const merGeo = new THREE.BufferGeometry().setFromPoints(merPts);
    const merMat = new THREE.LineBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.5, depthWrite: false });
    addVizObject(new THREE.Line(merGeo, merMat));

    // Latitude arc along the satellite's meridian from equator to satellite
    // Use signed angle: positive = north, negative = south
    const latArcRadius = EARTH_RADIUS * 1.08;
    const merDir = new THREE.Vector3(Math.cos(lonRad), 0, Math.sin(lonRad)).normalize();
    // Axis: east-pointing tangent at this meridian — cross(up, merDir) gives west, so negate
    const latAxis = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), merDir).normalize().negate();
    // Positive angleDeg rotates from equator toward north pole; negative toward south
    const latArcPts = makeArcPoints(latArcRadius, latAxis, new THREE.Vector3(0, 0, 0), merDir, lat, 48);
    createBoldArc(latArcPts, 0x00e676);
    createArcTicks(latArcRadius, latAxis, new THREE.Vector3(0, 0, 0), merDir, lat, 10);

    // Subsatellite point marker
    const ssGeo = new THREE.SphereGeometry(0.15, 16, 16);
    const ssMat = new THREE.MeshBasicMaterial({ color: 0x00e676 });
    const ssMarker = new THREE.Mesh(ssGeo, ssMat);
    ssMarker.position.copy(surfacePos);
    addVizObject(ssMarker);

    // Line from surface to satellite
    const dropGeo = new THREE.BufferGeometry().setFromPoints([surfacePos.clone(), satPos.clone()]);
    const dropMat = new THREE.LineDashedMaterial({ color: 0x00e676, transparent: true, opacity: 0.5, dashSize: 0.2, gapSize: 0.15, depthWrite: false });
    const dropLine = new THREE.Line(dropGeo, dropMat);
    dropLine.computeLineDistances();
    addVizObject(dropLine);

    // Label
    const latStr = Math.abs(lat).toFixed(3) + '\u00B0' + (lat >= 0 ? 'N' : 'S');
    const midTheta = (lat / 2) * DEG2RAD;
    const kCross = new THREE.Vector3().crossVectors(latAxis, merDir);
    const midDir = new THREE.Vector3()
        .copy(merDir).multiplyScalar(Math.cos(midTheta))
        .addScaledVector(kCross, Math.sin(midTheta));
    vizLabelAnchor = midDir.normalize().multiplyScalar(latArcRadius * 1.4);
    createVizLabel('LATITUDE', latStr);

    // Feature labels
    addVizTag('EQUATOR', new THREE.Vector3(-EARTH_RADIUS * 0.8, 0.3, EARTH_RADIUS * 0.7), '#00e5ff');
    addVizTag('GROUND POINT', surfacePos.clone().addScaledVector(surfacePos.clone().normalize(), 0.4), '#00e676');

    orbitalVizMode = 'lat';
    $detailLat.classList.add('viz-active');

    // Camera: side-on to the meridian
    const endLat = (lat * DEG2RAD) * 0.3 + 15 * DEG2RAD * Math.sign(lat || 1);
    const camLon = Math.atan2(merDir.z, merDir.x) + 0.4;
    animateCameraToVizView(endLat, camLon, 18);
}

function showLonViz(satIndex) {
    clearOrbitalViz();
    if (satIndex < 0 || satIndex >= satellites.length) return;
    if (referenceFrame !== 'ecef') {
        _frameBeforeViz = referenceFrame;
        setReferenceFrame('ecef');
    }
    hideOrbitOverlays();
    const sat = satellites[satIndex];
    const lon = sat.lon;
    const lonRad = -lon * DEG2RAD;

    // Subsatellite point on Earth surface
    const surfacePos = geoToVec3(sat.lat, lon, 0);

    // Earth equatorial ring
    const eqRadius = EARTH_RADIUS * 1.005;
    const eqPts = [];
    for (let i = 0; i <= 128; i++) {
        const theta = (i / 128) * 2 * Math.PI;
        eqPts.push(new THREE.Vector3(eqRadius * Math.cos(theta), 0, eqRadius * Math.sin(theta)));
    }
    const eqGeo = new THREE.BufferGeometry().setFromPoints(eqPts);
    const eqMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.5, depthWrite: false });
    addVizObject(new THREE.Line(eqGeo, eqMat));

    // Prime meridian line (0° longitude)
    const pmPts = [];
    for (let i = 0; i <= 64; i++) {
        const latStep = (i / 64) * Math.PI - Math.PI / 2;
        const r = EARTH_RADIUS * 1.005;
        pmPts.push(new THREE.Vector3(r * Math.cos(latStep), r * Math.sin(latStep), 0));
    }
    const pmGeo = new THREE.BufferGeometry().setFromPoints(pmPts);
    const pmMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.3, depthWrite: false });
    addVizObject(new THREE.Line(pmGeo, pmMat));

    // Longitude meridian at satellite's longitude
    const merPts = [];
    for (let i = 0; i <= 64; i++) {
        const latStep = (i / 64) * Math.PI - Math.PI / 2;
        const r = EARTH_RADIUS * 1.005;
        merPts.push(new THREE.Vector3(
            r * Math.cos(latStep) * Math.cos(lonRad),
            r * Math.sin(latStep),
            r * Math.cos(latStep) * Math.sin(lonRad)
        ));
    }
    const merGeo = new THREE.BufferGeometry().setFromPoints(merPts);
    const merMat = new THREE.LineBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.5, depthWrite: false });
    addVizObject(new THREE.Line(merGeo, merMat));

    // Longitude arc on equator — use signed angle (negative = west)
    // lon is in [-180, 180], pass directly so arc sweeps the short way
    const arcRadius = EARTH_RADIUS * 1.12;
    const eqUp = new THREE.Vector3(0, 1, 0);
    const pmDir = new THREE.Vector3(1, 0, 0); // prime meridian = 0° lon
    // In scene coords, positive lon goes clockwise (negative rotation about Y)
    // makeArcPoints rotates startDir about axis by angleDeg using right-hand rule
    // Y-up + positive angle = counter-clockwise when viewed from above
    // Scene longitude: -lon in scene coords, so pass -lon to sweep correctly
    const lonArcPts = makeArcPoints(arcRadius, eqUp, new THREE.Vector3(0, 0, 0), pmDir, -lon, 64);
    createBoldArc(lonArcPts, 0xff6b35);
    createArcTicks(arcRadius, eqUp, new THREE.Vector3(0, 0, 0), pmDir, -lon, 30);

    // Subsatellite point marker
    const ssGeo = new THREE.SphereGeometry(0.15, 16, 16);
    const ssMat = new THREE.MeshBasicMaterial({ color: 0x00e676 });
    const ssMarker = new THREE.Mesh(ssGeo, ssMat);
    ssMarker.position.copy(surfacePos);
    addVizObject(ssMarker);

    // Label
    const lonStr = Math.abs(lon).toFixed(3) + '\u00B0' + (lon >= 0 ? 'E' : 'W');
    const lonMid = (-lon / 2) * DEG2RAD;
    const lonLabelDir = new THREE.Vector3(Math.cos(lonMid), 0, Math.sin(lonMid));
    vizLabelAnchor = lonLabelDir.multiplyScalar(arcRadius * 1.3);
    vizLabelAnchor.y += 0.4;
    createVizLabel('LONGITUDE', lonStr);

    // Feature labels
    addVizTag('PRIME MERIDIAN', new THREE.Vector3(EARTH_RADIUS * 1.08, 0.5, 0), '#00e5ff');
    addVizTag('EQUATOR', new THREE.Vector3(-EARTH_RADIUS * 0.8, 0.3, EARTH_RADIUS * 0.7), '#00e5ff');
    const lonDirTag = new THREE.Vector3(Math.cos(lonRad), 0, Math.sin(lonRad)).multiplyScalar(EARTH_RADIUS * 1.2);
    lonDirTag.y = -0.3;
    addVizTag(lon.toFixed(1) + '\u00B0 MERIDIAN', lonDirTag, '#ff6b35');

    orbitalVizMode = 'lon';
    $detailLon.classList.add('viz-active');

    // Camera: near-polar looking down at the arc
    const midLon = (-lon / 2) * DEG2RAD;
    animateCameraToVizView(70 * DEG2RAD, midLon, 18);
}

// ============================================================
// TRACKING HALO
// ============================================================
function getHaloTexture() {
    if (haloTexture) return haloTexture;
    const size = 128;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    gradient.addColorStop(0, 'rgba(255,140,50,1)');
    gradient.addColorStop(0.15, 'rgba(255,107,53,0.8)');
    gradient.addColorStop(0.4, 'rgba(255,80,30,0.25)');
    gradient.addColorStop(1, 'rgba(255,50,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);
    haloTexture = new THREE.CanvasTexture(canvas);
    return haloTexture;
}

function createTrackingHalo() {
    if (trackingHalo) return;
    const mat = new THREE.SpriteMaterial({
        map: getHaloTexture(),
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        depthTest: false,
    });
    trackingHalo = new THREE.Sprite(mat);
    trackingHalo.scale.set(1.2, 1.2, 1);
    trackingHalo.renderOrder = 999;
    scene.add(trackingHalo);
}

function removeTrackingHalo() {
    if (!trackingHalo) return;
    scene.remove(trackingHalo);
    trackingHalo.material.map.dispose();
    trackingHalo.material.dispose();
    trackingHalo = null;
}

function updateTrackingHalo() {
    if (trackingIndex < 0 || !trackingHalo) return;
    const sat = satellites[trackingIndex];
    // Offset slightly toward camera to prevent z-fighting with sat point
    _satPos.set(sat.x, sat.y, sat.z);
    _toCamera.copy(camera.position).sub(_satPos).normalize().multiplyScalar(0.05);
    trackingHalo.position.copy(_satPos.add(_toCamera));
}

function createTrackingArrow() {
    if (trackingArrow) return;
    const shaftGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.35, 8);
    const headGeo = new THREE.ConeGeometry(0.035, 0.1, 8);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff6b35, transparent: true, opacity: 0.55 });
    const shaft = new THREE.Mesh(shaftGeo, mat);
    shaft.position.y = 0.175;
    const head = new THREE.Mesh(headGeo, mat.clone());
    head.position.y = 0.45;
    trackingArrow = new THREE.Group();
    trackingArrow.add(shaft);
    trackingArrow.add(head);
    scene.add(trackingArrow);
}

function removeTrackingArrow() {
    if (!trackingArrow) return;
    scene.remove(trackingArrow);
    trackingArrow.traverse(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
    });
    trackingArrow = null;
}

function updateTrackingArrow() {
    if (trackingIndex < 0 || !trackingArrow) return;
    const sat = satellites[trackingIndex];
    _satPos.set(sat.x, sat.y, sat.z);

    // Compute velocity direction from previous/current world position (cached per frame)
    if (sat._prevX !== undefined) {
        _velDir.set(sat.x - sat._prevX, sat.y - sat._prevY, sat.z - sat._prevZ);
        if (_velDir.lengthSq() > 1e-12) {
            _velDir.normalize();
            // Position arrow ahead of the satellite along its velocity
            _arrowOrigin.copy(_velDir).multiplyScalar(0.3).add(_satPos);
            trackingArrow.position.copy(_arrowOrigin);
            // Orient arrow along velocity direction
            _quatTemp.setFromUnitVectors(_upVec, _velDir);
            trackingArrow.quaternion.copy(_quatTemp);
        }
    }
}

// ============================================================
// UI: SATELLITE LIST
// ============================================================
function buildSatList() {
    $satList.innerHTML = '';
    const frag = document.createDocumentFragment();

    // Count sats per plane for the plane items
    const planeCounts = {};
    for (const sat of satellites) {
        if (sat.plane > 0) planeCounts[sat.plane] = (planeCounts[sat.plane] || 0) + 1;
    }

    // Insert plane group items (hidden by default, shown during search)
    for (let p = 1; p <= 12; p++) {
        if (!planeCounts[p]) continue;
        const div = document.createElement('div');
        div.className = 'plane-item';
        div.dataset.plane = p;
        div.innerHTML = `
            <div class="plane-dot"></div>
            <div class="sat-info">
                <div class="sat-name">Plane ${p}</div>
                <div class="sat-meta">${planeCounts[p]} satellites</div>
            </div>
        `;
        div.addEventListener('click', () => selectPlane(p));
        frag.appendChild(div);
    }

    satellites.forEach((sat, i) => {
        const div = document.createElement('div');
        div.className = 'sat-item';
        div.dataset.index = i;
        const planePart = sat.plane > 0 ? ` &middot; Plane ${sat.plane}` : '';
        div.innerHTML = `
            <div class="sat-dot"></div>
            <div class="sat-info">
                <div class="sat-name">${sat.name}</div>
                <div class="sat-meta">ID ${sat.noradId}${planePart} &middot; ${sat.inclination.toFixed(1)}&deg; inc</div>
            </div>
        `;
        div.addEventListener('click', () => selectSatellite(i));
        frag.appendChild(div);
    });

    $satList.appendChild(frag);
}

function filterSatList(query) {
    const q = query.trim();
    const ql = q.toLowerCase();
    const planeItems = $satList.querySelectorAll('.plane-item');
    const satItems = $satList.querySelectorAll('.sat-item');
    const planeExact = q.match(/^plane\s*(\d+)$/i);
    const planePartial = ql && ('plane'.startsWith(ql) || ql.startsWith('plane'));

    // Show/hide plane group items
    planeItems.forEach(item => {
        const p = parseInt(item.dataset.plane, 10);
        if (planeExact) {
            item.style.display = p === parseInt(planeExact[1], 10) ? 'flex' : 'none';
        } else if (planePartial) {
            item.style.display = 'flex';
        } else {
            item.style.display = 'none';
        }
        // Update selected state
        item.classList.toggle('selected', selectedPlane === p);
    });

    // Show/hide satellite items
    if (planeExact) {
        const planeNum = parseInt(planeExact[1], 10);
        satItems.forEach(item => {
            const i = parseInt(item.dataset.index, 10);
            item.style.display = satellites[i].plane === planeNum ? '' : 'none';
        });
    } else {
        satItems.forEach(item => {
            const i = parseInt(item.dataset.index, 10);
            const sat = satellites[i];
            const match = !ql || sat.name.toLowerCase().includes(ql) || String(sat.noradId).includes(ql);
            item.style.display = match ? '' : 'none';
        });
    }
}

// ============================================================
// SELECTION
// ============================================================
function selectSatellite(index) {
    clearOrbitalViz();
    // Clear plane selection if active
    if (selectedPlane >= 0) {
        const oldPlaneItem = $satList.querySelector('.plane-item.selected');
        if (oldPlaneItem) oldPlaneItem.classList.remove('selected');
        selectedPlane = -1;
        removePlaneGlow();
        restoreAllSatColors();
    }

    // Deselect old
    if (selectedIndex >= 0) {
        const oldItem = $satList.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        resetSatColor(selectedIndex);
    }

    if (index === selectedIndex) {
        if ($detailPanel.classList.contains('hidden')) {
            // Detail panel was dismissed — re-show it
            $detailPanel.classList.remove('hidden');
        } else {
            // Toggle off — stop tracking but keep camera where it is
            stopTracking();
            selectedIndex = -1;
            $detailPanel.classList.add('hidden');
            clearOrbitPath();
        }
        return;
    }

    // If we were tracking something else, stop without resetting view
    if (trackingIndex >= 0 && trackingIndex !== index) {
        stopTracking();
    }

    selectedIndex = index;
    const item = $satList.querySelector(`.sat-item[data-index="${index}"]`);
    if (item) {
        item.classList.add('selected');
        item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }

    // Update detail panel
    $detailPanel.classList.remove('hidden');
    updateDetailPanel();

    // Always track the selected satellite
    focusSatellite(index);

}

function setSatColor(index, r, g, b) {
    if (!satColorAttr) return;
    satColorAttr.setXYZ(index, r, g, b);
    satColorAttr.needsUpdate = true;
}

function resetSatColor(index) {
    if (trackingIndex >= 0 && index !== trackingIndex) {
        // In tracking mode, non-tracked satellites stay dim
        setSatColor(index, 0.08, 0.12, 0.18);
    } else if (selectedPlane >= 0) {
        if (satellites[index].plane === selectedPlane) {
            setSatColor(index, 0.2, 0.85, 1.0);
        } else {
            setSatColor(index, 0.05, 0.08, 0.12);
        }
    } else {
        setSatColor(index, 0, 0.9, 1.0);
    }
}

function updateDetailPanel() {
    if (selectedIndex < 0) return;
    const sat = satellites[selectedIndex];
    $detailName.textContent = sat.name;
    $detailLat.textContent = sat.lat.toFixed(3) + '\u00B0';
    $detailLon.textContent = sat.lon.toFixed(3) + '\u00B0';
    $detailAlt.textContent = Math.round(sat.alt).toLocaleString() + ' km';
    $detailVel.textContent = (sat.speed || 0).toFixed(1) + ' km/s';
    $detailInc.textContent = sat.inclination.toFixed(2) + '\u00B0';
    $detailEcc.textContent = sat.eccentricity.toFixed(6);
    $detailPeriod.textContent = sat.period.toFixed(1) + ' min';
    $detailNorad.textContent = sat.noradId;
    $detailPlane.textContent = sat.plane > 0 ? 'Plane ' + sat.plane : 'Unassigned';

    // RAAN from satrec (epoch value)
    const raan = (sat.satrec.nodeo * RAD2DEG % 360 + 360) % 360;
    $detailRaan.textContent = raan.toFixed(2) + '\u00B0';

    // Argument of Latitude — use cached ECI from updateSatellitePositions (no re-propagation)
    if (sat.eciX !== undefined) {
        const raanRad = sat.satrec.nodeo;
        const incRad = sat.satrec.inclo;
        const nx = Math.cos(raanRad), ny = Math.sin(raanRad);
        const px = sat.eciX * nx + sat.eciY * ny;
        const py = (-sat.eciX * ny + sat.eciY * nx) * Math.cos(incRad) + sat.eciZ * Math.sin(incRad);
        const aol = ((Math.atan2(py, px) * RAD2DEG) % 360 + 360) % 360;
        $detailAol.textContent = aol.toFixed(2) + '\u00B0';
    }
}

function updateStats() {
    $statTotal.textContent = satellites.length;
    $statPlanes.textContent = 12;
}

// ============================================================
// GROUND STATION LABELS
// ============================================================
function updateGroundStationLabels() {
    if (!camera || !renderer) return;
    const widthHalf = window.innerWidth / 2;
    const heightHalf = window.innerHeight / 2;

    for (const gs of ALL_STATIONS) {
        if (!gs._el) gs._el = document.getElementById(gs.id);
        const el = gs._el;
        if (!el) continue;

        // Cache base position (earth-local, stations don't move on surface)
        if (!gs._basePos) {
            gs._basePos = geoToVec3(gs.lat, gs.lon, 0).multiplyScalar(1.01);
            gs._worldPos = gs._basePos.clone();
        }

        // In ECI mode, rotate base position by earthGroup's GMST rotation
        if (referenceFrame === 'eci') {
            const gmst = earthGroup.rotation.y;
            const c = Math.cos(gmst), s = Math.sin(gmst);
            const bx = gs._basePos.x, bz = gs._basePos.z;
            gs._worldPos.set(bx * c + bz * s, gs._basePos.y, -bx * s + bz * c);
        } else {
            gs._worldPos.copy(gs._basePos);
        }

        // Check if behind globe (reuse module-level objects)
        _camToStation.copy(gs._worldPos).sub(camera.position).normalize();
        raycaster.set(camera.position, _camToStation);
        const hits = raycaster.ray.intersectSphere(_earthSphere, _intersectPt);
        const distToStation = camera.position.distanceTo(gs._worldPos);
        const isBehind = hits && camera.position.distanceTo(_intersectPt) < distToStation * 0.98;
        const wasBehind = el.classList.contains('behind-globe');
        if (isBehind !== wasBehind) el.classList.toggle('behind-globe', isBehind);

        // Project to screen (reuse _projectedVec, use transform for GPU-composited positioning)
        _projectedVec.copy(gs._worldPos).project(camera);
        const x = (_projectedVec.x * widthHalf) + widthHalf;
        const y = -(_projectedVec.y * heightHalf) + heightHalf;
        // Only update DOM if position moved more than 0.5px
        const dx = x - (gs._screenX || 0), dy = y - (gs._screenY || 0);
        if (dx * dx + dy * dy > 0.25) {
            el.style.transform = `translate(${x}px, ${y}px)`;
            gs._screenX = x; gs._screenY = y;
        }
    }
}

// ============================================================
// CAMERA ANIMATION / TRACKING
// ============================================================
function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function focusSatellite(index) {
    if (index < 0 || index >= satellites.length) return;

    // If already tracking this one, stop tracking
    if (trackingIndex === index) {
        resetView();
        return;
    }

    // Select it if not already selected
    if (selectedIndex !== index) {
        selectSatellite(index);
    }

    trackingIndex = index;
    const sat = satellites[index];
    const satPos = new THREE.Vector3(sat.x, sat.y, sat.z);
    const endDir = satPos.clone().normalize();

    // Keep current distance, rotate around the globe to face the satellite
    const dist = camera.position.length();
    const cp = camera.position;

    // Convert start/end to lat/lon so we rotate around rather than over the globe
    const startLat = Math.asin(cp.y / dist);
    const startLon = Math.atan2(cp.z, cp.x);
    const endLat = Math.asin(endDir.y);
    const endLon = Math.atan2(endDir.z, endDir.x);

    // Shortest longitude path (wrap around)
    let dLon = endLon - startLon;
    if (dLon > Math.PI) dLon -= 2 * Math.PI;
    if (dLon < -Math.PI) dLon += 2 * Math.PI;

    // Duration based on total angular distance (lon dominates)
    const totalAngle = Math.abs(dLon) + Math.abs(endLat - startLat);
    const ratio = totalAngle / Math.PI;
    const duration = 1.0 + ratio * ratio * 5.0;
    cameraAnim = {
        startLat, startLon, endLat, dLon,
        dist: dist,
        startTarget: controls.target.clone(),
        endTarget: new THREE.Vector3(0, 0, 0),
        progress: 0,
        duration: duration,
    };

    // Refresh orbit path with past/future tracking colours
    showOrbitPath(index);

    // Dim all non-selected satellites
    dimOtherSatellites(index);

    // Show tracking halo + direction arrow
    createTrackingHalo();
    updateTrackingHalo();
    createTrackingArrow();
    updateTrackingArrow();

    // Reset follow mode
    followMode = false;
    document.getElementById('detail-track').classList.remove('active');
    document.getElementById('detail-track').textContent = 'Follow Satellite';
}

function panToPlane(planeNum) {
    // Compute the orbital plane normal, then rotate 90° so the camera
    // looks along the plane edge-on from the equator — one half of the
    // satellite ring visible as a vertical line, the other half behind Earth.
    const positions = [];
    for (const sat of satellites) {
        if (sat.plane === planeNum) {
            positions.push(new THREE.Vector3(sat.x, sat.y, sat.z));
        }
    }
    if (positions.length < 2) return;

    // Average cross-products of well-spaced position pairs → plane normal
    const normal = new THREE.Vector3(0, 0, 0);
    const quarter = Math.max(1, Math.floor(positions.length / 4));
    for (let i = 0; i < positions.length; i++) {
        const j = (i + quarter) % positions.length;
        const cross = new THREE.Vector3().crossVectors(positions[i], positions[j]);
        normal.add(cross);
    }
    normal.normalize();

    // Project normal onto equatorial plane (y=0), then rotate 90° so the
    // camera looks along the plane (edge-on) — one half of the ring visible
    // as a vertical line of satellites, the other half behind the Earth.
    let nx = normal.x, nz = normal.z;
    if (Math.sqrt(nx * nx + nz * nz) < 0.01) {
        // Degenerate — fall back to RAAN-based direction
        const sat0 = satellites.find(s => s.plane === planeNum);
        const raan = sat0.satrec.nodeo;
        const gmst = satellite.gstime(simTime);
        const geoLon = raan - gmst;
        nx = Math.cos(geoLon); nz = Math.sin(geoLon);
    }
    // 90° rotation in XZ plane: (x,z) → (-z,x)
    const viewDir = new THREE.Vector3(-nz, 0, nx).normalize();

    const dist = camera.position.length();
    const cp = camera.position;
    const startLat = Math.asin(cp.y / dist);
    const startLon = Math.atan2(cp.z, cp.x);

    const endLat = 0; // equator — side of the Earth

    // Two candidate longitudes (normal and anti-normal), pick closest
    const lon1 = Math.atan2(viewDir.z, viewDir.x);
    const lon2 = Math.atan2(-viewDir.z, -viewDir.x);

    let dLon1 = lon1 - startLon;
    if (dLon1 > Math.PI) dLon1 -= 2 * Math.PI;
    if (dLon1 < -Math.PI) dLon1 += 2 * Math.PI;

    let dLon2 = lon2 - startLon;
    if (dLon2 > Math.PI) dLon2 -= 2 * Math.PI;
    if (dLon2 < -Math.PI) dLon2 += 2 * Math.PI;

    const dLon = Math.abs(dLon1) <= Math.abs(dLon2) ? dLon1 : dLon2;

    const totalAngle = Math.abs(dLon) + Math.abs(endLat - startLat);
    const ratio = totalAngle / Math.PI;
    const duration = 1.0 + ratio * ratio * 5.0;
    cameraAnim = {
        startLat, startLon, endLat, dLon,
        dist: dist,
        startTarget: controls.target.clone(),
        endTarget: new THREE.Vector3(0, 0, 0),
        progress: 0,
        duration: duration,
    };
}

function stopTracking() {
    trackingIndex = -1;
    cameraAnim = null;
    followMode = false;
    removeTrackingHalo();
    removeTrackingArrow();
    restoreAllSatColors();
}

function resetView() {
    clearOrbitalViz();
    // Clear satellite selection
    if (selectedIndex >= 0) {
        resetSatColor(selectedIndex);
        const oldItem = document.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        selectedIndex = -1;
        $detailPanel.classList.add('hidden');
        clearOrbitPath();
    }
    // Clear plane selection
    if (selectedPlane >= 0) {
        const oldPlaneItem = document.querySelector('.plane-item.selected');
        if (oldPlaneItem) oldPlaneItem.classList.remove('selected');
        selectedPlane = -1;
        removePlaneGlow();
    }
    stopTracking();
    restoreAllSatColors();

    // Animate back to default UK view
    const cp = camera.position;
    const dist = cp.length();
    const startLat = Math.asin(cp.y / dist);
    const startLon = Math.atan2(cp.z, cp.x);
    const endDir = defaultCameraPos.clone().normalize();
    const endLat = Math.asin(endDir.y);
    const endLon = Math.atan2(endDir.z, endDir.x);
    let dLon = endLon - startLon;
    if (dLon > Math.PI) dLon -= 2 * Math.PI;
    if (dLon < -Math.PI) dLon += 2 * Math.PI;
    const totalAngle = Math.abs(dLon) + Math.abs(endLat - startLat);
    const ratio = totalAngle / Math.PI;
    const duration = 1.0 + ratio * ratio * 5.0;
    cameraAnim = {
        startLat, startLon, endLat, dLon,
        dist: defaultDist,
        startTarget: controls.target.clone(),
        endTarget: defaultCameraTarget.clone(),
        progress: 0,
        duration: duration,
    };
}

function dimOtherSatellites(keepIndex) {
    if (!satColorAttr) return;
    for (let i = 0; i < satellites.length; i++) {
        if (i === keepIndex) {
            satColorAttr.setXYZ(i, 1.0, 0.42, 0.21); // orange
        } else {
            satColorAttr.setXYZ(i, 0.08, 0.12, 0.18); // very dim
        }
    }
    satColorAttr.needsUpdate = true;
}

function selectPlane(planeNum) {
    // Check if any satellites are in this plane
    const hasPlane = satellites.some(s => s.plane === planeNum);
    if (!hasPlane) return;

    // Deselect old plane item in list
    const oldPlaneItem = $satList.querySelector('.plane-item.selected');
    if (oldPlaneItem) oldPlaneItem.classList.remove('selected');

    // Toggle off if already selected
    if (selectedPlane === planeNum) {
        selectedPlane = -1;
        removePlaneGlow();
        restoreAllSatColors();
        return;
    }

    // Clear any individual satellite selection/tracking
    if (selectedIndex >= 0) {
        const oldItem = document.querySelector(`.sat-item[data-index="${selectedIndex}"]`);
        if (oldItem) oldItem.classList.remove('selected');
        selectedIndex = -1;
    }
    stopTracking();
    document.getElementById('detail-panel').classList.add('hidden');
    clearOrbitPath();

    selectedPlane = planeNum;

    // Mark plane item as selected in list
    const planeItem = $satList.querySelector(`.plane-item[data-plane="${planeNum}"]`);
    if (planeItem) planeItem.classList.add('selected');

    // Highlight all satellites in this plane bright cyan, dim the rest
    if (!satColorAttr) return;
    for (let i = 0; i < satellites.length; i++) {
        if (satellites[i].plane === planeNum) {
            satColorAttr.setXYZ(i, 0.2, 0.85, 1.0); // bright cyan
        } else {
            satColorAttr.setXYZ(i, 0.05, 0.08, 0.12); // very dim
        }
    }
    satColorAttr.needsUpdate = true;

    // Add big blue glow overlay
    showPlaneGlow(planeNum);

    // Pan camera to edge-on view of the plane
    panToPlane(planeNum);

    // Show rotate buttons
}

function restoreAllSatColors() {
    if (!satColorAttr) return;
    for (let i = 0; i < satellites.length; i++) {
        if (selectedPlane >= 0 && satellites[i].plane === selectedPlane) {
            satColorAttr.setXYZ(i, 0.2, 0.85, 1.0); // bright cyan for plane
        } else if (i === selectedIndex) {
            satColorAttr.setXYZ(i, 1.0, 0.42, 0.21);
        } else if (selectedPlane >= 0) {
            satColorAttr.setXYZ(i, 0.05, 0.08, 0.12); // dim when plane active
        } else {
            satColorAttr.setXYZ(i, 0, 0.9, 1.0);
        }
    }
    satColorAttr.needsUpdate = true;
}

function updateCameraAnimation(dt) {
    if (!cameraAnim) return;

    cameraAnim.progress = Math.min(1, cameraAnim.progress + dt / cameraAnim.duration);
    const t = easeInOutCubic(cameraAnim.progress);

    // Interpolate lat/lon separately — rotates around the globe, not over the top
    const lat = cameraAnim.startLat + (cameraAnim.endLat - cameraAnim.startLat) * t;
    const lon = cameraAnim.startLon + cameraAnim.dLon * t;
    const r = cameraAnim.startDist !== undefined
        ? cameraAnim.startDist + (cameraAnim.endDist - cameraAnim.startDist) * t
        : cameraAnim.dist;
    camera.position.set(
        r * Math.cos(lat) * Math.cos(lon),
        r * Math.sin(lat),
        r * Math.cos(lat) * Math.sin(lon)
    );
    controls.target.lerpVectors(cameraAnim.startTarget, cameraAnim.endTarget, t);

    if (cameraAnim.progress >= 1) {
        cameraAnim = null;
    }
}

function updateTracking() {
    if (!followMode) return;
    if (trackingIndex < 0 || trackingIndex >= satellites.length) return;
    if (cameraAnim) return;

    const sat = satellites[trackingIndex];
    _satPos.set(sat.x, sat.y, sat.z);
    _trackDir.copy(_satPos).normalize();

    const dist = camera.position.length();
    _trackTarget.copy(_trackDir).multiplyScalar(dist);

    camera.position.lerp(_trackTarget, 0.025);
}

// ============================================================
// INTERACTION
// ============================================================
function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    _lastMouseX = event.clientX;
    _lastMouseY = event.clientY;
    _mouseDirty = true;
}

function showTooltip(html, x, y, cursor) {
    if (_tooltipContent !== html) {
        $tooltip.innerHTML = html;
        _tooltipContent = html;
    }
    if (_tooltipX !== x || _tooltipY !== y) {
        $tooltip.style.transform = `translate(${x}px, ${y}px)`;
        _tooltipX = x; _tooltipY = y;
    }
    $tooltip.classList.add('visible');
    renderer.domElement.style.cursor = cursor;
}

function hideTooltip() {
    if (_tooltipContent !== '') {
        _tooltipContent = '';
        $tooltip.classList.remove('visible');
        renderer.domElement.style.cursor = 'grab';
    }
}

// Returns true if satellite at given index is on the visible side of the globe
function isSatVisible(idx) {
    const sat = satellites[idx];
    _satPos.set(sat.x, sat.y, sat.z);
    _camToStation.copy(_satPos).sub(camera.position).normalize();
    raycaster.set(camera.position, _camToStation);
    const hit = raycaster.ray.intersectSphere(_earthSphere, _intersectPt);
    if (!hit) return true;
    const distToSat = camera.position.distanceTo(_satPos);
    return camera.position.distanceTo(_intersectPt) >= distToSat * 0.98;
}

// Called once per frame from animate() — replaces per-mousemove raycasting
function processMouseHover() {
    if (!_mouseDirty || !satPointCloud) return;
    _mouseDirty = false;

    const tx = _lastMouseX + 14;
    const ty = _lastMouseY - 10;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(satPointCloud);

    if (intersects.length > 0) {
        // Find the nearest visible satellite (skip those behind Earth)
        let hitIdx = -1;
        for (let i = 0; i < intersects.length; i++) {
            if (isSatVisible(intersects[i].index)) {
                hitIdx = intersects[i].index;
                break;
            }
        }

        if (hitIdx >= 0) {
            if (hitIdx !== hoveredIndex) {
                if (hoveredIndex >= 0 && hoveredIndex !== selectedIndex) resetSatColor(hoveredIndex);
                hoveredIndex = hitIdx;
                if (hoveredIndex !== selectedIndex) setSatColor(hoveredIndex, 0.3, 1.0, 0.6);
            }
            const sat = satellites[hitIdx];
            showTooltip(
                `<strong>${sat.name}</strong><br>Alt: ${Math.round(sat.alt)} km &middot; ${sat.lat.toFixed(1)}&deg;, ${sat.lon.toFixed(1)}&deg;`,
                tx, ty, 'pointer'
            );
        } else {
            // All hits were behind Earth
            if (hoveredIndex >= 0 && hoveredIndex !== selectedIndex) resetSatColor(hoveredIndex);
            hoveredIndex = -1;
            hideTooltip();
        }
    } else {
        if (hoveredIndex >= 0 && hoveredIndex !== selectedIndex) resetSatColor(hoveredIndex);
        hoveredIndex = -1;

        // Check sun/moon hover (only when no satellite hit)
        let celestialHit = false;
        if (sunMesh && sunMesh.visible) {
            const sunHits = raycaster.intersectObject(sunMesh, true);
            if (sunHits.length > 0) {
                showTooltip('<strong>Sun</strong>', tx, ty, 'default');
                celestialHit = true;
            }
        }
        if (!celestialHit && moonMesh) {
            const moonHits = raycaster.intersectObject(moonMesh, true);
            if (moonHits.length > 0) {
                showTooltip('<strong>Moon</strong>', tx, ty, 'default');
                celestialHit = true;
            }
        }
        if (!celestialHit) {
            hideTooltip();
        }
    }
}

function onMouseClick(event) {
    if (!satPointCloud) return;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(satPointCloud);
    for (let i = 0; i < intersects.length; i++) {
        if (isSatVisible(intersects[i].index)) {
            selectSatellite(intersects[i].index);
            return;
        }
    }
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ============================================================
// SPEED CONTROLS (slider: 1x–1200x, exponential curve)
// ============================================================
const $speedSlider = document.getElementById('speed-slider');
const $speedLabel = document.getElementById('speed-label');

function sliderToSpeed(val) {
    // Exponential: 0→1x, 100→1200x
    if (val === 0) return 1;
    return Math.round(Math.pow(1200, val / 100));
}

function speedToSlider(speed) {
    if (speed <= 1) return 0;
    return Math.round(100 * Math.log(speed) / Math.log(1200));
}

function updateSpeedLabel(speed) {
    $speedLabel.textContent = speed + 'x';
}

$speedSlider.addEventListener('input', () => {
    const speed = sliderToSpeed(parseInt($speedSlider.value));
    timeMultiplier = speed;
    updateSpeedLabel(speed);
});

// ============================================================
// LIVE BUTTON — reset to real time at 1x
// ============================================================
document.getElementById('live-btn').addEventListener('click', () => {
    simTime = new Date();
    timeMultiplier = 1;
    $speedSlider.value = 0;
    updateSpeedLabel(1);
});

// ============================================================
// PANEL TOGGLE
// ============================================================
const $panelToggle = document.getElementById('panel-toggle');
$panelToggle.addEventListener('click', () => {
    panelOpen = !panelOpen;
    document.getElementById('side-panel').classList.toggle('collapsed', !panelOpen);
    $panelToggle.classList.toggle('panel-open', panelOpen);
    $panelToggle.innerHTML = panelOpen ? '&#x25C0;' : '&#x25B6;';
});

// ============================================================
// DETAIL CLOSE
// ============================================================
document.getElementById('detail-close').addEventListener('click', () => {
    $detailPanel.classList.add('hidden');
});

document.getElementById('detail-track').addEventListener('click', () => {
    if (trackingIndex < 0) return;
    followMode = !followMode;
    const btn = document.getElementById('detail-track');
    btn.classList.toggle('active', followMode);
    btn.textContent = followMode ? 'Following...' : 'Follow Satellite';
});

// ============================================================
// SEARCH
// ============================================================
$searchInput.addEventListener('input', (e) => filterSatList(e.target.value));

// Enter key in search: select + focus first visible result
$searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        const q = $searchInput.value.trim();
        if (!q) return;
        const planeMatch = q.match(/^plane\s*(\d+)$/i);
        if (planeMatch) {
            const planeNum = parseInt(planeMatch[1], 10);
            selectPlane(planeNum);
            return;
        }
        const ql = q.toLowerCase();
        const matchIdx = satellites.findIndex(
            s => s.name.toLowerCase().includes(ql) || String(s.noradId).includes(ql)
        );
        if (matchIdx >= 0) {
            selectSatellite(matchIdx);
        }
    }
});


// ============================================================
// RESET VIEW
// ============================================================
document.getElementById('reset-view').addEventListener('click', resetView);

// ============================================================
// ROTATE VIEW ±90°
// ============================================================
function rotateView(degrees) {
    const radians = degrees * DEG2RAD;
    const dist = camera.position.length();
    const cp = camera.position;
    const startLat = Math.asin(cp.y / dist);
    const startLon = Math.atan2(cp.z, cp.x);

    cameraAnim = {
        startLat, startLon,
        endLat: startLat, // stay at same latitude
        dLon: radians,
        dist: dist,
        startTarget: controls.target.clone(),
        endTarget: new THREE.Vector3(0, 0, 0),
        progress: 0,
        duration: 1.5,
    };
}

document.getElementById('rotate-minus').addEventListener('click', () => rotateView(-90));
document.getElementById('rotate-plus').addEventListener('click', () => rotateView(90));

// ============================================================
// ANIMATION LOOP
// ============================================================
let frameCount = 0;

function animate(now) {
    requestAnimationFrame(animate);

    const dt = (now - lastFrameTime) / 1000;
    lastFrameTime = now;

    // Advance sim time
    simTime = new Date(simTime.getTime() + dt * timeMultiplier * 1000);

    // Update sun direction — every frame at high speed, every 10th at 1x
    const sunInterval = Math.abs(timeMultiplier) > 10 ? 1 : 10;
    if (frameCount % sunInterval === 0 && sunEnabled) {
        // In ECI mode, world space = inertial, so use ECI sun/moon directions
        const isEci = referenceFrame === 'eci';
        const sunDir = isEci ? computeSunDirectionECI(simTime) : computeSunDirection(simTime);
        // Move directional light to match sun
        sunLight.position.copy(sunDir).multiplyScalar(20);
        // Update earth shader (sunDirection must match world space of earthGroup)
        if (earthDayNightMat) {
            earthDayNightMat.uniforms.sunDirection.value.copy(sunDir);
        }
        // Update atmosphere shader
        if (atmosphereMesh && atmosphereMesh.material.uniforms) {
            atmosphereMesh.material.uniforms.sunDirection.value.copy(sunDir);
        }
        // Update sun visual position
        if (sunMesh) {
            sunMesh.position.copy(sunDir).multiplyScalar(150);
        }
        // Update moon position
        if (moonMesh) {
            const moonDir = isEci ? computeMoonDirectionECI(simTime) : computeMoonDirection(simTime);
            moonMesh.position.copy(moonDir).multiplyScalar(60);
        }
    }

    // Update satellite positions — adaptive frequency based on time multiplier
    // At 1x: every 4th frame (~15/sec). At 10-100x: every 2nd. At >100x: every frame.
    frameCount++;
    const satInterval = Math.abs(timeMultiplier) > 100 ? 1 : Math.abs(timeMultiplier) > 10 ? 2 : 4;
    if (frameCount % satInterval === 0) {
        updateSatellitePositions();
    }

    // Update orbit path — more often at higher speeds so tails stay current
    const pathInterval = Math.max(3, Math.floor(150 / Math.abs(timeMultiplier || 1)));
    if (selectedIndex >= 0 && !orbitalVizMode && frameCount % pathInterval === 0) {
        showOrbitPath(selectedIndex);
    }

    // Update detail panel
    const detailInterval = Math.max(2, Math.floor(30 / Math.abs(timeMultiplier || 1)));
    if (selectedIndex >= 0 && frameCount % detailInterval === 0) {
        updateDetailPanel();
    }

    // Camera animation
    updateCameraAnimation(dt);

    // Tracking: follow satellite + halo + direction arrow
    updateTracking();
    updateTrackingHalo();
    updateTrackingArrow();

    // Process mouse hover (once per frame instead of per-mousemove event)
    processMouseHover();

    // Update orbital viz label position + live AoL
    if (orbitalVizMode === 'aol') updateAolViz();
    updateOrbitalVizLabel();

    // ECI: Earth rotates by GMST; ECEF: Earth is static
    if (referenceFrame === 'eci') {
        earthGroup.rotation.y = satellite.gstime(simTime);
    } else {
        earthGroup.rotation.y = 0;
    }

    // Stars slowly drift for subtle visual motion (skip in ECI — inertial relative to stars)
    if (starField && referenceFrame !== 'eci') {
        starField.rotation.y += 0.00002;
    }

    // Update clock + live indicator
    if (frameCount % 10 === 0) {
        const iso = simTime.toISOString();
        $clockTime.textContent = iso.slice(0, 10) + '  ' + iso.slice(11, 19);

        // Check if we're live: time multiplier is 1 and simTime is within 3s of real time
        const drift = Math.abs(Date.now() - simTime.getTime());
        const isLive = timeMultiplier === 1 && drift < 3000;
        document.getElementById('live-btn').classList.toggle('is-live', isLive);
    }

    controls.update();

    // Ground station labels (after controls.update so camera position matches rendered frame)
    if (ttcVisible || gwVisible) {
        updateGroundStationLabels();
    }

    renderer.render(scene, camera);
}

// ============================================================
// CREATE GROUND STATION 3D MARKERS
// ============================================================
function createStationMarkers3D(stations, color) {
    const markerGeo = new THREE.SphereGeometry(0.04, 8, 8);
    const markerMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 });
    const ringGeo = new THREE.RingGeometry(0.08, 0.12, 24);
    const ringMat = new THREE.MeshBasicMaterial({
        color, transparent: true, opacity: 0.5,
        side: THREE.DoubleSide, depthWrite: false,
    });

    for (const gs of stations) {
        const pos = geoToVec3(gs.lat, gs.lon, 0);
        const surfacePos = pos.clone().multiplyScalar(1.005);

        const dot = new THREE.Mesh(markerGeo, markerMat);
        dot.position.copy(surfacePos);
        gs.dot3d = dot;
        earthGroup.add(dot);

        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.copy(surfacePos);
        ring.lookAt(surfacePos.clone().multiplyScalar(2));
        gs.ring3d = ring;
        earthGroup.add(ring);
    }
}

function createGroundStationMarkers() {
    createStationMarkers3D(TTC_STATIONS, 0xff6b9d);
    createStationMarkers3D(GW_STATIONS, 0x4ecdc4);
}

function createSAAOverlay() {
    const r = EARTH_RADIUS * 1.005;

    // Catmull-Rom spline in lat/lon space for smooth boundary
    const raw = SAA_BOUNDARY.slice(0, -1); // remove closing duplicate
    const N = raw.length;
    const segsPerPt = 8;
    const smooth = [];
    for (let i = 0; i < N; i++) {
        const p0 = raw[(i - 1 + N) % N];
        const p1 = raw[i];
        const p2 = raw[(i + 1) % N];
        const p3 = raw[(i + 2) % N];
        for (let s = 0; s < segsPerPt; s++) {
            const t = s / segsPerPt;
            const t2 = t * t, t3 = t2 * t;
            const lat = 0.5 * ((2*p1[0]) + (-p0[0]+p2[0])*t + (2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2 + (-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3);
            const lon = 0.5 * ((2*p1[1]) + (-p0[1]+p2[1])*t + (2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2 + (-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3);
            smooth.push([lat, lon]);
        }
    }
    smooth.push(smooth[0]); // close

    // Project smooth boundary to 3D sphere
    function latLonTo3D(lat, lon) {
        const latRad = lat * DEG2RAD;
        const lonRad = -lon * DEG2RAD;
        return new THREE.Vector3(
            r * Math.cos(latRad) * Math.cos(lonRad),
            r * Math.sin(latRad),
            r * Math.cos(latRad) * Math.sin(lonRad)
        );
    }
    const pts3d = smooth.map(([lat, lon]) => latLonTo3D(lat, lon));

    // Compute centroid projected onto sphere
    const centroid = new THREE.Vector3();
    for (const p of pts3d) centroid.add(p);
    centroid.divideScalar(pts3d.length).normalize().multiplyScalar(r);

    // Subdivide triangles (positions only)
    function subdivide(v1, v2, v3, depth, out) {
        if (depth === 0) {
            out.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z);
            return;
        }
        const m12 = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5).normalize().multiplyScalar(r);
        const m23 = new THREE.Vector3().addVectors(v2, v3).multiplyScalar(0.5).normalize().multiplyScalar(r);
        const m31 = new THREE.Vector3().addVectors(v3, v1).multiplyScalar(0.5).normalize().multiplyScalar(r);
        subdivide(v1,  m12, m31, depth - 1, out);
        subdivide(m12, v2,  m23, depth - 1, out);
        subdivide(m31, m23, v3,  depth - 1, out);
        subdivide(m12, m23, m31, depth - 1, out);
    }

    const n = pts3d.length - 1; // closed — last == first
    const verts = [];
    for (let i = 0; i < n; i++) {
        subdivide(centroid, pts3d[i], pts3d[(i + 1) % n], 3, verts);
    }

    // Compute per-vertex distance from nearest boundary point
    // aT = 0 at boundary, 1 deep inside
    const nBoundary = pts3d.length - 1;
    const bNorms = [];
    for (let j = 0; j < nBoundary; j++) {
        const p = pts3d[j];
        const len = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);
        bNorms.push(p.x / len, p.y / len, p.z / len);
    }
    const numVerts = verts.length / 3;
    const tValues = new Float32Array(numVerts);
    let maxDist = 0;
    for (let i = 0; i < numVerts; i++) {
        const vx = verts[i * 3], vy = verts[i * 3 + 1], vz = verts[i * 3 + 2];
        const len = Math.sqrt(vx * vx + vy * vy + vz * vz);
        const nx = vx / len, ny = vy / len, nz = vz / len;
        let minAngle = Infinity;
        for (let j = 0; j < nBoundary; j++) {
            const cosA = nx * bNorms[j * 3] + ny * bNorms[j * 3 + 1] + nz * bNorms[j * 3 + 2];
            const angle = Math.acos(Math.max(-1, Math.min(1, cosA)));
            if (angle < minAngle) minAngle = angle;
        }
        tValues[i] = minAngle;
        if (minAngle > maxDist) maxDist = minAngle;
    }
    for (let i = 0; i < numVerts; i++) {
        tValues[i] /= maxDist;
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
    geo.setAttribute('aT', new THREE.Float32BufferAttribute(tValues, 1));

    // ShaderMaterial: distance-from-boundary gradient (green at edge → yellow → red inside)
    const saaMat = new THREE.ShaderMaterial({
        vertexShader: `
            attribute float aT;
            varying float vT;
            void main() {
                vT = aT;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            varying float vT;
            void main() {
                vec3 red = vec3(1.0, 0.15, 0.05);
                vec3 yellow = vec3(1.0, 0.9, 0.0);
                vec3 green = vec3(0.15, 0.8, 0.2);
                vec3 col;
                // vT: 0 = at boundary, 1 = deepest inside
                if (vT < 0.2) {
                    col = mix(green, yellow, vT / 0.2);
                } else {
                    col = mix(yellow, red, (vT - 0.2) / 0.8);
                }
                float alpha = 0.35;
                gl_FragColor = vec4(col, alpha);
            }
        `,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false,
    });
    saaMesh = new THREE.Mesh(geo, saaMat);
    saaMesh.visible = saaVisible;
    earthGroup.add(saaMesh);

    // Smooth boundary outline — green at edges
    const lineVerts = [];
    for (const p of pts3d) lineVerts.push(p.x, p.y, p.z);
    const lineGeo = new THREE.BufferGeometry();
    lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(lineVerts, 3));
    const lineMat = new THREE.LineBasicMaterial({
        color: 0x33cc44, transparent: true, opacity: 0.45
    });
    saaOutline = new THREE.Line(lineGeo, lineMat);
    saaOutline.visible = saaVisible;
    earthGroup.add(saaOutline);
}

// ============================================================
// BOOT
// ============================================================
initScene();
createStars();
createEarth();
createSunVisual();
createMoonVisual();
createGroundStationMarkers();
createSAAOverlay();
loadTLEData();
animate(performance.now());

// TT&C toggle
document.getElementById('toggle-ttc').addEventListener('click', () => {
    ttcVisible = !ttcVisible;
    document.getElementById('toggle-ttc').classList.toggle('active-ttc', ttcVisible);
    for (const gs of TTC_STATIONS) {
        const el = document.getElementById(gs.id);
        if (el) el.classList.toggle('gs-hidden', !ttcVisible);
        if (gs.dot3d) gs.dot3d.visible = ttcVisible;
        if (gs.ring3d) gs.ring3d.visible = ttcVisible;
    }
});

// Gateway toggle
document.getElementById('toggle-gw').addEventListener('click', () => {
    gwVisible = !gwVisible;
    document.getElementById('toggle-gw').classList.toggle('active-gw', gwVisible);
    for (const gs of GW_STATIONS) {
        const el = document.getElementById(gs.id);
        if (el) el.classList.toggle('gs-hidden', !gwVisible);
        if (gs.dot3d) gs.dot3d.visible = gwVisible;
        if (gs.ring3d) gs.ring3d.visible = gwVisible;
    }
});

// SAA zone toggle
document.getElementById('toggle-saa').addEventListener('click', () => {
    saaVisible = !saaVisible;
    document.getElementById('toggle-saa').classList.toggle('active-saa', saaVisible);
    if (saaMesh) saaMesh.visible = saaVisible;
    if (saaOutline) saaOutline.visible = saaVisible;
});

// Sun lighting toggle
document.getElementById('toggle-sun').addEventListener('click', () => {
    sunEnabled = !sunEnabled;
    document.getElementById('toggle-sun').classList.toggle('active-sun', sunEnabled);
    if (sunEnabled) {
        sunLight.visible = true;
        ambientLight.intensity = 0.6;
        ambientLight.color.set(0x335577);
        // Immediately compute sun position
        const sunDir = referenceFrame === 'eci' ? computeSunDirectionECI(simTime) : computeSunDirection(simTime);
        sunLight.position.copy(sunDir).multiplyScalar(20);
        if (earthDayNightMat) {
            earthDayNightMat.uniforms.sunDirection.value.copy(sunDir);
        }
    } else {
        sunLight.visible = false;
        ambientLight.intensity = 1.8;
        ambientLight.color.set(0xffffff);
    }
    // Update shader sun toggle
    if (earthDayNightMat) {
        earthDayNightMat.uniforms.sunEnabled.value = sunEnabled;
    }
    if (atmosphereMesh && atmosphereMesh.material.uniforms) {
        atmosphereMesh.material.uniforms.sunEnabled.value = sunEnabled;
    }
    if (sunMesh) sunMesh.visible = sunEnabled;
});

// Reference frame toggle — hover tooltips
const $frameTooltip = document.getElementById('frame-tooltip');
document.getElementById('frame-ecef').addEventListener('mouseenter', () => {
    $frameTooltip.textContent = 'Earth-Centered Earth-Fixed';
});
document.getElementById('frame-eci').addEventListener('mouseenter', () => {
    $frameTooltip.textContent = 'Earth-Centered Inertial';
});

// Set reference frame programmatically (used by toggle + auto-switch for viz)
function setReferenceFrame(frame) {
    if (frame === referenceFrame) return;
    const isEci = frame === 'eci';

    // Rotate camera to compensate for the Earth rotation change, keeping the view stable.
    // ECEF→ECI: Earth rotates to gmst, satellites rotate to ECI — rotate camera by +gmst to follow.
    // ECI→ECEF: Earth snaps to 0, satellites snap to ECEF — rotate camera by -gmst to follow.
    const gmst = satellite.gstime(simTime);
    const angle = isEci ? gmst : -gmst;
    const c = Math.cos(angle), s = Math.sin(angle);
    const cx = camera.position.x, cz = camera.position.z;
    camera.position.x = cx * c + cz * s;
    camera.position.z = -cx * s + cz * c;

    // Set Earth rotation immediately (don't wait for animate loop)
    earthGroup.rotation.y = isEci ? gmst : 0;

    // Temporarily disable damping so OrbitControls fully adopts the new
    // camera position in one update (damping would interpolate and flicker)
    controls.enableDamping = false;
    controls.update();
    controls.enableDamping = true;

    referenceFrame = frame;
    document.getElementById('frame-toggle').classList.toggle('eci', isEci);
    document.getElementById('frame-ecef').classList.toggle('active', !isEci);
    document.getElementById('frame-eci').classList.toggle('active', isEci);

    // Clear and rebuild orbit path for selected satellite
    clearOrbitPath();
    if (selectedIndex >= 0 && !orbitalVizMode) {
        showOrbitPath(selectedIndex);
    }

    // Force immediate satellite position update
    updateSatellitePositions();

    // Invalidate cached ground station world positions so they recompute
    for (const gs of ALL_STATIONS) {
        gs._screenX = 0; gs._screenY = 0;
    }
}

// Reference frame toggle (ECEF ↔ ECI)
document.getElementById('frame-toggle').addEventListener('click', () => {
    // Manual toggle clears any auto-switch state
    _frameBeforeViz = null;
    setReferenceFrame(referenceFrame === 'ecef' ? 'eci' : 'ecef');
});

// ============================================================
// SOURCE INFO MODAL
// ============================================================
const $sourceModal = document.getElementById('source-modal');

function openSourceModal() {
    // Set statuses based on active source
    const $ps = document.getElementById('primary-status');
    const $ss = document.getElementById('secondary-status');
    if (activeDataSource === 'primary') {
        $ps.textContent = 'Active';
        $ps.className = 'source-status status-active';
        $ss.textContent = 'Standby';
        $ss.className = 'source-status status-inactive';
    } else if (activeDataSource === 'secondary') {
        $ps.textContent = 'Failed';
        $ps.className = 'source-status status-inactive';
        $ss.textContent = 'Active';
        $ss.className = 'source-status status-fallback';
    } else {
        $ps.textContent = '--';
        $ps.className = 'source-status status-inactive';
        $ss.textContent = '--';
        $ss.className = 'source-status status-inactive';
    }

    // Select the active tab
    const activeTab = activeDataSource || 'primary';
    document.querySelectorAll('.source-tab').forEach(t => t.classList.toggle('active-tab', t.dataset.tab === activeTab));
    document.querySelectorAll('.source-tab-content').forEach(c => c.classList.toggle('active-content', c.id === 'tab-' + activeTab));

    $sourceModal.classList.add('open');
}

document.getElementById('source-click-area').addEventListener('click', openSourceModal);
document.getElementById('source-modal-close').addEventListener('click', () => $sourceModal.classList.remove('open'));
$sourceModal.addEventListener('click', (e) => { if (e.target === $sourceModal) $sourceModal.classList.remove('open'); });

document.querySelectorAll('.source-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.source-tab').forEach(t => t.classList.remove('active-tab'));
        tab.classList.add('active-tab');
        document.querySelectorAll('.source-tab-content').forEach(c => c.classList.remove('active-content'));
        document.getElementById('tab-' + tab.dataset.tab).classList.add('active-content');
    });
});

// ============================================================
// DATETIME PICKER MODAL
// ============================================================
const $dtModal = document.getElementById('datetime-modal');
const $dtInput = document.getElementById('datetime-input');
const $dtError = document.getElementById('datetime-error');

function openDatetimeModal() {
    // Pre-fill with current sim time in local datetime-local format
    const iso = simTime.toISOString().slice(0, 19);
    $dtInput.value = iso;
    $dtError.textContent = '';
    $dtModal.classList.add('open');
    $dtInput.focus();
}

document.getElementById('clock-time').addEventListener('click', openDatetimeModal);
document.getElementById('datetime-modal-close').addEventListener('click', () => $dtModal.classList.remove('open'));
$dtModal.addEventListener('click', (e) => { if (e.target === $dtModal) $dtModal.classList.remove('open'); });

document.getElementById('datetime-go').addEventListener('click', () => {
    const val = $dtInput.value;
    if (!val) { $dtError.textContent = 'Please enter a date and time'; return; }
    const d = new Date(val + 'Z'); // treat input as UTC
    if (isNaN(d.getTime())) { $dtError.textContent = 'Invalid date/time format'; return; }
    simTime = d;
    $dtModal.classList.remove('open');
});

document.getElementById('datetime-now').addEventListener('click', () => {
    simTime = new Date();
    timeMultiplier = 1;
    $speedSlider.value = 0;
    updateSpeedLabel(1);
    $dtModal.classList.remove('open');
});

$dtInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') document.getElementById('datetime-go').click();
    if (e.key === 'Escape') $dtModal.classList.remove('open');
});

// ============================================================
// ORBITAL VIZ CLICK LISTENERS
// ============================================================
$detailInc.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    if (orbitalVizMode === 'inclination') {
        clearOrbitalViz();
    } else {
        showInclinationViz(selectedIndex);
    }
});

$detailRaan.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    if (orbitalVizMode === 'raan') {
        clearOrbitalViz();
    } else {
        showRaanViz(selectedIndex);
    }
});

$detailAol.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    if (orbitalVizMode === 'aol') {
        clearOrbitalViz();
    } else {
        showAolViz(selectedIndex);
    }
});

$detailEcc.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    if (orbitalVizMode === 'eccentricity') {
        clearOrbitalViz();
    } else {
        showEccentricityViz(selectedIndex);
    }
});

$detailLat.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    if (orbitalVizMode === 'lat') {
        clearOrbitalViz();
    } else {
        showLatViz(selectedIndex);
    }
});

$detailLon.addEventListener('click', () => {
    if (selectedIndex < 0) return;
    if (orbitalVizMode === 'lon') {
        clearOrbitalViz();
    } else {
        showLonViz(selectedIndex);
    }
});

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && orbitalVizMode) {
        clearOrbitalViz();
    }
});

</script>
</body>
</html>
